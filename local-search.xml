<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【论文笔记】HermesSim (Security 24)</title>
    <link href="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/"/>
    <url>/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/</url>
    
    <content type="html"><![CDATA[<h2 id="HermesSim-Security-24">HermesSim [Security 24]</h2><p>论文：《<a href="https://www.usenix.org/system/files/sec24summer-prepub-346-he.pdf">Code is not Natural Language: Unlock the Power of Semantics-Oriented Graph Representation for Binary Code Similarity Detection</a>》</p><h3 id="提出的问题"><strong>提出的问题</strong></h3><p>二进制代码相似性检测（BCSD）是确定两个二进制函数之间的语义相似性的基本任务。</p><p><strong>现有的BCSD方法</strong>主要分为两种：基于指令流的方法和基于控制流图（CFG）的方法。基于指令流的方法将指令流视为自然语言句子，并应用自然语言处理技术。这些方法虽然先进，但<strong>预训练过程昂贵，且侧重于学习代码的有限方面</strong>。而基于CFG的方法则侧重于利用图神经网络捕获控制流特征，但同样<strong>受限于对基于NLP方法的依赖</strong>。</p><p>作者提出，指令流与自然语言句子在语法上相似，但它们在结构、语义和约定上有本质的不同：</p><ul><li>自然语言是模糊和弱结构化的，而二进制代码具有明确定义的结构和语义</li><li>在自然语言中重新排序单词可能改变语义，而在二进制代码中重新排序指令或在基本块间移动指令是可行的，不会影响语义。</li><li>第三，自然语言旨在有效地交换信息，而二进制代码旨在简化机器执行。</li></ul><p>这些差异表明，将代码视为自然语言并不是最理想的。</p><p>作者建议开发一种二进制代码表示，能够：</p><ul><li>显示指令内部结构，显示操作符如何使用操作数</li><li>显示指令间关系，例如定义使用、控制流程和必要的执行顺序</li><li>排除与语义无关的元素，例如用于临时缓存数据的寄存器和不必要的执行顺序限制</li><li>编码其他隐式知识，例如调用约定。</li></ul><blockquote><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124003235665.png" alt="image-20240124003235665" style="zoom: 80%;"><p>作者列举了三种简单的、语义上等效的转换，这些转换对NLP模型来说是必须学习的：</p><ol><li><strong>交换指令顺序：</strong> 代码片段中的前两个指令可以交换而不改变代码语义。然而，这种转换会改变产生的嵌入集，因此模型需要学习哪些指令的顺序可以调整而不改变语义。（如（b)）</li><li><strong>改变代码片段的位置：</strong> 整个代码片段可能由于在序列开始处插入了一些虚拟指令而被放置在不同的位置。这会改变所有token的位置嵌入，导致一个完全不同的嵌入集，模型需要学习不同位置的相同子序列在语义上是等价的。（如（c)）</li><li><strong>替换寄存器使用：</strong> 使用的寄存器r0可以被以前未使用的寄存器r2替换。模型需要学习所选择的确切寄存器是与语义无关的。相反，通过寄存器传递的数据流则是代码语义的一个组成部分。（如（d)）</li></ol><p>故学习这些附加的语义使得基于NLP的方法变得<strong>更加昂贵</strong>且难以泛化。</p></blockquote><h3 id="实现背景">实现背景</h3><h4 id="二进制代码的隐含结构">二进制代码的隐含结构</h4><p>作者先讨论了二进制代码的隐含结构，可以分为三个类别：指令内部结构、指令间关系和函数级别的约定。</p><ol><li><p><strong>指令内部结构（Intra-instruction Structures）</strong>：指令有其内部结构。例如，MIPS架构中的指令<code>add r1, r2, r3</code>可以解释为<code>add</code>操作符使用存储在寄存器<code>r2</code>和<code>r3</code>中的值，并将产生的值存储在寄存器<code>r1</code>中。同时，x86-64架构中的指令<code>add rax, rdx</code>可以解释为<code>add</code>操作符使用存储在寄存器<code>rax</code>和<code>rdx</code>中的值，但其输出存储在<code>rax</code>和<code>eflags</code>寄存器中。</p></li><li><p><strong>指令间关系（Inter-instruction Relations）</strong>：这些关系可以分为data (def-use relations), control (branches), and effect (execution order)。</p><ul><li><p><strong>Data relations</strong>：揭示了一些指令使用由其他指令定义的值。</p></li><li><p><strong>Control relations</strong>：在基本块级别定义控制流。</p></li><li><p><strong>Effect relations</strong>：之前的研究往往忽略了这一点，建立了指令间执行顺序的限制。（如Figure3(a)的第4行和第5行）</p><ul><li><p>一种类似于传统控制流图表示的方法是将每个基本块中的指令序列化，以限制执行顺序。然而，这种表示方式施加了过多的限制。（第4行的指令不能与前面的两条指令交换，但第2行和第3行的指令可以交换而不影响代码语义）</p></li><li><p>为了追求效果和效率，作者的目标是在最终表示中仅包含必要的执行顺序。故采用the effect model：<strong>将额外的执行顺序限制建模为潜在的数据流</strong>。在上述示例中，STORE指令修改了一个内存槽，而CALL指令调用的子程序Foo可能读取或写入同一个内存槽，这构成了一个潜在的数据流。作者使用<strong>一个抽象的临时变量</strong>来代表每一组相关的内存槽。<strong>可能</strong>从该内存槽组<strong>读取值或写入值</strong>的指令被认为<strong>使用或定义</strong>相应的临时变量。</p><blockquote><p>值得注意的是，构建的效果流与分析能力有关。例如，在（d）中，如果确定被调用的子程序不与内存交互，或STORE指令仅修改当前堆栈帧，而任何子程序都不会访问它，那么在它们之间就不需要引入效果关系。</p></blockquote></li></ul></li></ul><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124004330568.png" alt="image-20240124004330568" style="zoom:67%;"><blockquote><p>图 3a 中代码片段的语义解释如下。第 1 行的标签 L1 和第 7 行的标签 L2 分别表示两个基本模块的开始。指令 r0 = LOAD 0x1000 加载地址为 0x1000 的内存槽值，并将其放入寄存器 r0。随后，r1 = ADD r1, 2 将表达式 r1 + 2 的值存储到寄存器 r1 中。STORE r0, r1 将 r1 的值存储到 r0 所指示的内存地址中。指令 r3 = CALL Foo, r0 以 r0 为唯一参数调用子程序 Foo，并将返回值存入 r3。BR L2 直接跳转到标签 L2 标记的基本程序块。最后，RET r3 将控制权返回给调用者，返回值设置为存储在 r3 中的值。</p></blockquote></li><li><p><strong>函数级别的约定（Function-level Conventions）</strong>：调用约定定义哪些寄存器用作调用参数和返回值，这有助于恢复调用指令的定义使用关系。此外，函数将临时变量存储在自己的堆栈帧中，其他函数不会访问这些临时变量。这种理解有助于<strong>完善Effect relations</strong>。</p></li></ol><h4 id="Semantics-Oriented-Graph">Semantics-Oriented Graph</h4><p>故提出的SOG(Semantics-Oriented Graph)将通过处理三个关键方面，有效捕获二进制代码的语义：</p><ol><li><strong>位置独立性</strong>：SOG不会为每个指令或token分配位置标识符，因为二进制代码的语义与位置无关。因此，图表示被认为更适合此目的。</li><li><strong>选择性执行顺序</strong>：SOG避免完全采用执行顺序来限制指令，因为大部分执行顺序限制是机器相关的，但与语义无关。SOG使用“效果模型”仅限制必要的执行顺序。</li><li><strong>消除与语义无关的token</strong>：SOG旨在去除与语义无关的token，同时对携带语义意义的指令或token之间的关系进行建模。</li></ol><p><strong>SOG的构建</strong>包括三个步骤：</p><ul><li><strong>基于指令的完整语义图（ISCG）</strong>：第一步将指令序列提升为图形表示，展示指令之间的关系作为边。这种表示增强了数据流图（DFG），增加了额外的control flow 和 effect flow边。指令是节点，图不指定指令属于哪个基本块，允许指令在基本块之间“浮动”，而不改变语义。</li><li><strong>基于token的完整语义图（TSCG）</strong>：第二步涉及将指令分解为token，以揭示指令内部结构，这简化了节点嵌入并消除了与语义无关的元素。这个过程根据引入它们的特定指令token来细化指令间关系。</li><li><strong>最终的SOG表示</strong>：最后一步涉及去除代表临时存储（如寄存器或堆栈插槽）的节点，这些存储在语义上是独立的，并直接连接它们的输入和输出。此步骤保留了未初始化存储的使用，因为它们携带语义信息（未初始化的存储大多携带从调用者例程传递的值。如果当前函数的调用约定已知，则可以使用未初始化存储的名称来推断参数在参数列表中的位置）。</li></ul><p>SOG能够编码各种函数级约定，例如调用参数和堆栈帧。例如，它可以通过从调用节点到参数节点添加数据边来揭示调用参数，并使用抽象临时变量来模拟堆栈帧的效果。</p><h3 id="实现">实现</h3><h4 id="SOG的构建">SOG的构建</h4><p>SOG 的构建可以通过与将线性 IR 转换为 SSA 形式类似的过程来完成。</p><p>将 SOG 分为三个子图：</p><p><strong>control子图构建</strong>:</p><ul><li>在基本块的末尾插入虚拟分支（BR）指令，以确保每个基本块以branch指令结束。</li><li>branch指令作为基本块的代表，转化为图的节点。</li><li>从branch targets到branches添加<strong>控制流边</strong>。</li><li>为了避免歧义，每个节点被视为只为每种类型的关系定义单一值</li><li>对于有多个后继者的条件或间接分支指令，将其输出视为连接值，并为每个后继者引入一个<strong>投影（PROJ）节点</strong>，将连接值投影为该特定后续者的单元值。</li></ul><p><strong>data子图构建</strong>:</p><ul><li>通过定义-使用（<strong>def-use</strong>）分析来构建。</li><li>为每个指令操作符创建一个节点，并为每个操作数添加指向定义该操作数值的前一个节点的有向边。</li><li>如果找不到定义操作数的前一个节点（如整数文字或未初始化的寄存器），则引入代表该整数文字或未初始化寄存器的新节点。这样，所有引用同一未定义操作数的指令都连接到同一操作数节点。</li><li>这个过程还包括解决对齐挑战，例如多个指令同时定义一个操作数值。为此引入了一个特殊的节点类型，<strong>PIECE</strong>，用于抽象地连接多个值。</li></ul><p><strong>effect子图构建</strong>:</p><ul><li>effect子图的构建与data子图类似，将effect视为特殊类型的由特殊指令使用和定义的值。</li><li>识别两种效果模型：内存effect和I/Oeffect。</li><li>内存 effect：从内存加载值的指令使用内存effect，改变内存状态的指令使用并定义内存effect。</li><li>I/O effect：以类似方式构建。</li></ul><p>此外，还在SOG中集成<strong>phi节点</strong>。SOG的构建自然与静态单赋值（SSA）形式一致，因为它为每个指令定义了一个节点。为了保持简洁，需要为data值和effect值引入必要的phi指令。</p><ul><li>由于 phi 指令的语义取决于控制流，因此首次引入 phi 节点时，将其设置为 phi 指令所在基本块的分支节点。</li><li>其他位置引用phi 节点时，按照分支节点的出边的顺序进行设置：当分支节点通过它的第 i 条出边接收到控制流时，使用该分支节点的phi节点就会选择第 i+1 个输入作为输出。</li></ul><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124013251212.png" alt="image-20240124013251212" style="zoom:80%;"><blockquote><p>论文的Appendix A中提供了图构建算法的伪代码。</p></blockquote><h4 id="系统框架"><strong>系统框架</strong></h4><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124015400860.png" alt="image-20240124015400860" style="zoom:80%;"><p>SOG的每个节点都有一个token，每条边都有一个类型label和一个位置label。</p><h4 id="训练">训练</h4><p>我们采用<strong>基于边际的成对损失</strong>[21]和<strong>距离加权负采样策略</strong>[41]进行训练。</p><p>通过首先对 N 个<strong>不同的函数符号</strong>进行采样，然后对每个符号具有<strong>不同编译设置</strong>的 2 个函数进行采样来收集<strong>小批量</strong>。</p><p>使用<strong>余弦相似度</strong>的负值作为距离度量。</p><h4 id="函数嵌入">函数嵌入</h4><p><strong>图归一化和编码</strong></p><p>每个<strong>节点</strong>都有一个token，直接</p><p>映射到可学习的嵌入向量。</p><p>每条<strong>边</strong>都有一个类型属性（data、control或effect）和一个位置属性（相应操作数的索引）。分别将类型和位置属性转换为两个嵌入，并将它们相加形成最终的边嵌入。</p><p>模型需要学习包括token和label在内的词汇表。一些token和label在词汇表之外，故：</p><ul><li>为每个token分配一个token类型，共三种（instruction tokens, integer literals, and register tokens）<ul><li>由于不同的架构有不同的寄存器使用习惯，我们进一步根据架构将register tokens分为几种子类型。</li></ul></li><li>对于每种类型的token，识别最常见的token并将它们包含在模型的词汇中。其他不常见的token进行<strong>归一化</strong>。</li></ul><p><strong>局部结构捕捉</strong></p><p>使用<strong>双向 GGNN 层</strong>来捕捉每个节点的邻接结构。</p><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124023555892.png" alt="image-20240124023555892" style="zoom: 80%;"><p><strong>Multi-head Softmax Aggregator</strong></p><p>采用<strong>Multi-head Softmax Aggregator</strong>，将所有节点嵌入聚合成图嵌入，它改编自 softmax 聚合器 [19]。</p><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124024721038.png" alt="image-20240124024721038" style="zoom: 80%;"><ul><li>（10）定义了如何计算一个节点的加权嵌入向量，其中 t 是一个可学习的参数向量，H 是所有节点嵌入向量的集合。它通过Softmax函数对所有节点嵌入进行加权求和，得到最终的图嵌入。</li></ul><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124024817320.png" alt="image-20240124024817320" style="zoom:80%;"><ul><li><p>公式(11) ：每个头的节点嵌入首先通过一个线性层转换到不同的表示空间，然后通过ReLU函数进行非线性变换。</p></li><li><p>公式(12) ：通过Softmax聚合器对每个节点的特征进行选择性加权，其中每个头的输出 x^k_u 会减去平均值并除以标准差，实现了特征的归一化处理。ε 是一个小数，用来保证数值稳定性。</p></li><li><p>公式(13) ：最终，所有头的输出嵌入向量被拼接起来，并通过另一个线性层来生成最终的图嵌入 g。</p></li></ul><h4 id="实现工具">实现工具</h4><p><strong>图构建模块</strong>基于 Ghidra</p><ul><li>利用 Ghidra 来反汇编二进制函数并将它们提升到其 Pcode IR，然后基于该 Pcode IR 构建 SOG。</li></ul><p><strong>图嵌入模块</strong>： Pytorch 和 PyG 。</p><h3 id="效果">效果</h3><p>参数设置和结果图表详见论文。</p><p><strong>数据集</strong>: 使用先前研究发布的Dataset-1，包含三种不同架构（x86、ARM和MIPS）、两种位模式（32位和64位）、5个优化级别（O0、O1、O2、O3和Os）的257K训练、13K验证和522K测试二进制函数，由两个不同的编译器家族（GCC和CLANG）编译。</p><p>**对比实验：**Table 1、Figure 7</p><ul><li>**结果：**HermesSim在各种设置下都明显优于所有基准方法。</li><li><strong>不同子任务的性能</strong>：GMN通常在涉及跨体系结构的CFG的任务中优于基于NLP的方法，如SAFE、Asm2Vec和Trex。然而，在使用大型池大小的某些任务中，GMN的性能不如Trex。这可能是因为在大型池中搜索时，CFG可能会发生冲突。</li><li><strong>模型参数</strong>：基于NLP的方法与基于图表示的方法相比具有更多的参数，至少多一个数量级。</li><li><strong>稳定性和可扩展性</strong>：HermesSim的性能在池大小增加时保持稳定，并且在池大小增加时甚至比最先进的基准方法，如jTrans和GMN，表现得更好。</li></ul><p>**消融研究：**Table 2、Figure 8</p><ul><li>SOE表示方法在BCSD任务中具有较好的性能，相对于其他基准方法和表示方法，它在召回率和效果方面都表现出色</li><li>多头softmax聚合器也表现出色。</li></ul><p><strong>运行时效率：</strong></p><ul><li><p>运行时成本：<img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124032144350.png" alt="image-20240124032144350" style="zoom: 50%;"></p></li><li><p><strong>图表示的大小和推断时间：</strong><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240124032220967.png" alt="image-20240124032220967" style="zoom:50%;"></p><blockquote><p>CFGs和ISCGs平均而言比SOGs小，这意味着在本地结构捕捉阶段具有更低的内存和时间成本，但会增加节点属性提取的复杂性</p></blockquote></li></ul><p><strong>现实世界漏洞搜索：</strong></p><ul><li><p>研究人员收集了来自三个供应商（TP-Link、Mercury和Fast）的12个RTOS固件图像，进行了1天漏洞搜索任务。他们构建了一个包含62605个函数的存储库，跨两种不同架构（ARM32和MIPS32）。在TP-Link WDR7620固件中手动识别了5个CVE和10个易受攻击函数，并将这些易受攻击函数用作查询。</p></li><li><p>对于每个查询函数，研究人员将存储库中的函数分为三组：c1代表与查询函数具有完全相同源代码构建的函数，c2代表与查询函数具有相同符号但源代码略有不同的函数，c3代表其他从不同源代码编译的函数。</p></li><li><p>通过使用HermesSim和其他基准方法进行相似性搜索，并手动检查前20个结果。</p><blockquote><p>理想情况下，BCSD 系统应将 c1 中的函数排在 c2 和 c3 中的函数之前，并将 c2 中的函数排在 c3 中的函数之前。</p></blockquote></li><li><p><strong>结果</strong>：HermesSim在失败次数、RECALL@1和MRR方面明显优于其他基准方法。它能够有效地识别和排名易受攻击函数，包括那些在源代码略有不同或不同架构之间的情况。</p></li></ul><blockquote><p>Appendix B 展示漏洞的详细信息</p></blockquote><h3 id="讨论（潜在改进）">讨论（潜在改进）</h3><p><strong>Dirty Effect</strong> <strong>Problem：</strong></p><ul><li><p><strong>编译器引入</strong>与effect相关的指令</p></li><li><p><strong>堆栈临时变量</strong>的数量取决于体系结构和优化级别，在effect flow中包含堆栈内存访问可能没有好处</p></li><li><p>解决方案：<strong>load-store elimination analysis</strong></p></li></ul><p><strong>I/O Effect Model</strong>：**本文只研究了memory effect model。 ** I/O Effect 涉及到与I/O设备交互的指令。</p><p><strong>Extra Information and Encoding Ability</strong>：本研究不处理对字符串、整数、外部函数符号和其他相关实体的引用。</p><p><strong>Addressing Analysis Failures</strong>：</p><ul><li><p>当前的传统程序分析算法可能无法完全恢复间接分支的控制流关系，这一限制影响了SOG表示。</p></li><li><p>探索如何向深度神经网络提供必要的信息（例如，引用的数据），以使它们能够推断间接分支的控制流，可能是值得的。</p></li></ul><h3 id="结论">结论</h3><p>在本文中，作者提出了一种语义完整的二进制代码表示方法，即语义导向图（SOG），用于二进制代码相似性检测（BCSD）。这种表示方法不仅利用了代码结构、语义和约定的明确定义，而且还清除了嵌入在低级机器代码中与语义无关的元素。作者详细介绍了SOG的构建过程，并讨论了对这种表示方法的潜在改进。为了充分发挥SOG在BCSD中的潜力，作者提出了一种新颖的多头softmax聚合器，它允许有效融合图的多个方面。通过整合所提出的技术，作者构建了一个有效且高效的BCSD解决方案，HermesSim，该解决方案依赖于图神经网络（GNN）模型来捕获SOG的结构信息，并采用先进的训练策略。广泛的实验表明，HermesSim在实验室实验和现实世界的漏洞搜索中都显著优于现有的最先进方法。此外，评估证明了揭示二进制代码的完整语义结构和清除与语义无关的元素的价值。作者还展示了所提出的聚合器的有效性和HermesSim的高效性。</p><hr><h3 id="附：部分基础概念解释">附：部分基础概念解释</h3><h4 id="基于边距的成对损失-Margin-based-Pairwise-Loss">基于边距的成对损失 (Margin-based Pairwise Loss)</h4><ol><li><strong>定义与目的</strong>: 这种损失函数主要用于学习数据点之间的相对距离或相似度。它通常用于诸如人脸识别、推荐系统等领域，其中需要判断两个数据点是否相似或不同。</li><li><strong>工作原理</strong>: 基于边距的损失函数会考虑成对的数据点（例如，两个不同的图像）。对于每一对相似的点（正样本对），它试图将它们的表示拉近；对于不相似的点（负样本对），则推远它们的表示。</li><li><strong>边距 (Margin)</strong>: 损失函数中的“边距”是一个预设的阈值，用于区分正样本对和负样本对之间的距离。如果一对数据点的距离小于这个边距，模型会受到惩罚，因此模型会学习使正样本对的距离尽可能小，而负样本对的距离大于这个边距。</li></ol><h4 id="距离加权负采样策略-Distance-Weighted-Negative-Sampling-Strategy">距离加权负采样策略 (Distance-Weighted Negative Sampling Strategy)</h4><ol><li><strong>背景</strong>: 在训练过程中，选择合适的负样本对（即不相似的数据点对）对模型性能至关重要。</li><li><strong>策略含义</strong>: 距离加权负采样是一种选择负样本对的方法。这种策略根据数据点之间的距离来加权选择负样本。与随机选择不同，这种方法倾向于选择那些与正样本对距离相近但实际上是负样本的数据点。</li><li><strong>优势</strong>: 这种策略可以提高模型对困难负样本（即那些与正样本在特征空间中较为接近的负样本）的识别能力。通过这种方式，模型可以更好地学习区分相似但不同的数据点，从而提高泛化能力。</li></ol><h4 id="图神经网络（GNN）">图神经网络（GNN）</h4><ol><li><strong>基本概念</strong>：图神经网络是一种专门处理图结构数据的神经网络。在图神经网络中，图由节点（代表实体）和边（代表实体间的关系）组成。</li><li><strong>功能</strong>：GNN的目标是学习节点的表示（embedding），这些表示可以捕捉节点的特征以及它们与其他节点的关系。</li></ol><h4 id="门控图神经网络（GGNN）">门控图神经网络（GGNN）</h4><ol><li><strong>门控机制</strong>：GGNN引入了门控机制，类似于LSTM（长短期记忆）网络中的门控。这种机制可以帮助网络更有效地控制信息的流动，特别是在处理图中的长距离依赖时。</li><li><strong>工作原理</strong>：在GGNN中，每个节点根据其邻居节点的信息来更新自己的状态，这个过程涉及到信息的聚合和门控操作。</li></ol><h4 id="间接分支的几个典型例子">间接分支的几个典型例子</h4><ol><li><strong>基于变量的跳转</strong>：例如，C语言中的<code>switch</code>语句可能被编译成使用跳转表的间接跳转，其中具体的跳转目标取决于<code>switch</code>语句的条件变量。</li><li><strong>函数指针调用</strong>：当通过函数指针调用函数时，具体调用哪个函数是在运行时决定的，这也是一种间接分支。</li><li><strong>虚拟调用</strong>：在面向对象编程中，如C++或Java，虚函数的调用通常是间接的，因为直到运行时才能确定具体调用哪个派生类的方法。</li></ol><h3 id="附">附</h3><h4 id="SOG-Construction-Algorithm">SOG Construction Algorithm</h4><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240512231104401.png" alt="image-20240512231104401" style="zoom:80%;"><p>2: 输入是一个二进制函数<code>f</code>，是汇编语言或线性中间表示（IR）形式的函数。</p><p>3: 创建一个新的<code>DefState</code>对象，用于跟踪和管理在构建SOG过程中所有变量的定义状态。</p><p>4: 创建一个新的<code>SOGConstructor</code>对象，这是构建SOG的工具。</p><p>5: 调用<code>GetAbstractEffectNodes</code>函数获取所有抽象的效应节点，这些节点代表程序中可能影响状态的操作（如内存写操作）。</p><p>6: 计算函数<code>f</code>的控制流图（CFG）的支配树（Dominator Tree），它是理解代码结构的一种方法，可以确定某个特定节点必须通过哪些路径才能被到达。</p><p>7: 在函数<code>f</code>中插入Phi节点，Phi节点用于合并来自支配树中不同路径的变量定义。</p><p>8: 准备函数<code>f</code>的控制流相关数据，可能涉及到设置控制流节点和边的关系。</p><p>9: 处理函数<code>f</code>的每个基本块，使用<code>defState</code>来跟踪定义状态，<code>f.start</code>是处理的起始点，<code>effectNodes</code>包含了所有需要考虑的effect节点。</p><p>10: 返回构建的语义导向图<code>g</code></p><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240512231110294.png" style="zoom:80%;"><p>13: 遍历函数<code>f</code>中的所有基本块（<code>bb</code>）。</p><p>14-15: 检查每个基本块是否以分支指令结束。如果不是，添加一个虚拟的分支指令，这是为了确保每个基本块在图中都正确地表示其控制流。</p><p>16: 创建一个新的节点（<code>node</code>）来表示基本块中的最后一条指令，这里假设基本块的最后一条指令是与控制流相关的。</p><p>17: 在<code>defState</code>中记录这个基本块与新创建的节点之间的关系。</p><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240512231140789.png" alt="image-20240512231140789" style="zoom:80%;"><p>20: 提交当前的定义状态，这相当于在处理每个基本块之前保存当前的变量定义状态。</p><p>21: 调用<code>BuildInBlock</code>函数，为当前的基本块<code>bb</code>构建内部结构</p><p>22-23: 对于基本块的每个子节点，递归地调用<code>ProcessBlock</code>函数来处理。</p><p>24: <code>defState.revert()</code>回滚到最后一次提交的定义状态。这是为了在处理完当前基本块及其子代后，能够恢复到进入基本块之前的状态，以便准确地处理其他基本块。</p><img src="/2024/05/12/HermesSim_Code%20is%20not%20Natural%20Language/image-20240512231126095.png" alt="image-20240512231126095" style="zoom:80%;"><p>28: 遍历基本块<code>bb</code>中的每一条指令<code>inst</code>。</p><p>29: 为每条指令创建一个对应的SOG节点<code>node</code>。</p><p>30: 将创建的节点<code>node</code>添加到SOG中。</p><p><strong>data flow</strong></p><p>32-34: 对于指令的每个输入操作数，创建或获取一个对应的<code>inpNode</code>，并将其作为data-use添加到节点<code>node</code>。</p><p>35-36: 对于指令的每个输出操作数，更新<code>defState</code>以反映最新的定义状态</p><p><strong>effect flow</strong></p><p>38-39: 遍历所有的<code>effect</code>，如果节点<code>node</code>使用了这个effect，则添加一个effect-use关系。</p><p>40-42: 如果节点<code>node</code>定义了某个效应，则更新<code>defState</code>以反映这个effect的最新定义状态。</p><p><strong>control flow</strong></p><p>44-48：如果节点<code>node</code>是一个控制节点（例如条件分支），则对其前驱节点进行处理，可能包括用<code>MayWrapWithProj</code>包装多个后继的情况，并添加控制使用关系。</p><p>49-52：对于基本块的每个后继节点<code>succ</code>，处理与Phi节点相关的控制流，这可能涉及到在Phi节点中设置正确的输入顺序。</p><p>最后，过程返回，完成对当前基本块内部结构的构建。</p>]]></content>
    
    
    <categories>
      
      <category>Binary Similarity论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>Binary Similarity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文笔记】jTrans（ISSTA 22）</title>
    <link href="/2024/05/11/jTrans/"/>
    <url>/2024/05/11/jTrans/</url>
    
    <content type="html"><![CDATA[<h2 id="ISSTA-22-jTrans（个人阅读笔记）">[ISSTA 22] jTrans（个人阅读笔记）</h2><p>论文：《<a href="https://arxiv.org/abs/2205.12713">jTrans: Jump-Aware Transformer for Binary Code Similarity</a>》</p><p>仓库：<a href="https://github.com/vul337/jTrans">https://github.com/vul337/jTrans</a></p><h3 id="提出的问题"><strong>提出的问题</strong></h3><ul><li>二进制代码相似性检测（BCSD）对于发现已知漏洞、恶意软件检测、软件抄袭检测、补丁分析以及软件供应链分析等众多应用至关重要。</li><li>随着二进制程序数量的不断增加以及二进制分析任务的普遍性，迫切需要开发更具可扩展性和准确性的BCSD解决方案。</li><li>现有方法仍存在一些局限性：<ul><li>首先，基于 NLP 的汇编语言建模只考虑指令的顺序和指令之间的关系，而不考虑程序的实际执行信息（如控制流）。因此，仅依赖 NLP 的方法将缺乏对所分析二进制文件的语义理解，也不能很好地适应编译器优化后代码可能发生的重大变化。</li><li>其次，仅仅依靠 CFG 会遗漏每个基本块中指令的语义。部分解决方案使用 GNN 来处理 CFG，而 GNN 只能捕捉结构信息。GNN 的训练和并行应用也相对困难，这限制了其在现实世界中的应用。</li><li>现有的数据集不够大或多样化，导致模型可能过度拟合，评估往往不能反映真实世界的案例。</li></ul></li></ul><h3 id="方法">方法</h3><p>jTrans基于Transformer的模型，专门设计用于解决上述问题。</p><h4 id="二进制函数表示建模"><strong>二进制函数表示建模</strong></h4><p>在jTrans 沿用了 BERT 用于文本建模的一般方法，即为每个token（即单词）创建嵌入，并使用 BERT 强大的注意力机制来有效地建模二进制代码。然而，二进制代码与自然语言在几个方面有所不同：</p><ol><li><strong>词汇量过多</strong>：二进制代码中有许多词汇（例如常量和字面量）。</li><li><strong>跳转指令</strong>：二进制代码中存在跳转指令。对于跳转指令，将其操作数token表示为source token，指定跳转目标指令的地址。为简单起见，将目标指令的助记符token表示为target token，并表示这对跳转对为&lt;source token, target token&gt;。</li></ol><p>因此，要应用BERT，需要解决以下两个问题：</p><ul><li><strong>词汇表外（OOV）token</strong>：和NLP领域一样，需要在包含分析语料中最常见标记的固定大小词汇表上训练jTrans。不包含在词汇表中的标记需要以一种方式表示，使得Transformer能够有效地处理它们。</li><li><strong>建模跳转指令</strong>（Modeling jump instructions）：二进制代码在预处理后，对于跳转对的source token和target token，留下的信息很少。BERT很难推断出它们之间的联系。这个问题由源和目标之间可能的大距离加剧，这使得上下文推断变得更加困难。</li></ul><p><strong>预处理指令（Preprocessing instructions）</strong></p><p>旨在缓解词汇表外（OOV）问题。使用先进的反汇编工具IDA Pro 7.5来分析输入的二进制程序，生成汇编指令序列。为了规范化汇编代码并减小其词汇量，应用以下tokenization策略：</p><ul><li><p>使用助记符和操作数作为token</p></li><li><p>将字符串字面量替换为特殊标记<code>&lt;str&gt;</code></p></li><li><p>将常量值替换为特殊标记<code>&lt;const&gt;</code></p></li><li><p>对于外部函数调用，保留它们的名称和标签作为标记，而将内部函数调用的名称替换为 <code>&lt;function&gt;</code>。</p><ul><li>原因：外部函数调用反映了模块间的接口，并且在不同版本的二进制文件之间不会频繁更改，但内部函数调用则没有这种性质。</li></ul></li><li><p>对于每对跳转指令，用<code>JUMP_XXX</code>标记替换其source token（跳转目标的绝对或相对地址），其中<code>XXX</code>是这对跳转对中target token的为序。通过这种方式，可以消除二进制文件随机基址的影响。</p></li></ul><p><strong>为跳转指令建模（Modeling jump instructions）</strong></p><p>jTrans采用了Transformer架构中的关键部分——<strong>位置编码（positional encodings）</strong>。位置编码使模型能够确定token之间的距离，通常距离越大，token之间的相互影响越弱。然而，<strong>跳转指令</strong>会将代码中可能相距很远的区域联系起来，因此jTrans修改了位置编码机制，以反映跳转指令的影响。通过**参数共享（parameter sharing）**来实现：</p><ul><li><p>对于每个跳转对，源标记的嵌入（见图 3 中的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>J</mi><mi>U</mi><mi>M</mi><mi>P</mi><mi mathvariant="normal">_</mi><mn>14</mn></mrow></msub></mrow><annotation encoding="application/x-tex">E_{JUMP\_14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0503em;vertical-align:-0.367em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">U</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">MP</span><span class="mord mtight">_14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.367em;"><span></span></span></span></span></span></span></span></span></span>）被用作目标标记（见 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>14</mn></msub></mrow><annotation encoding="application/x-tex">P_{14}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）的位置编码。</p><p><img src="/2024/05/11/jTrans/image-20240123160544181.png" alt="image-20240123160544181"></p><blockquote><p>然后，每个token被转换为token embedding和position embedding，而其最终的输入嵌入则是这两个嵌入的总和。</p></blockquote><p>这种表示法实现了两个重要目标：首先，共享嵌入使Transformer能够识别source token和target token之间的上下文联系。其次，这种强上下文联系在训练过程中保持不变，因为shared parameters会同时为两个标记更新。</p><blockquote><p>对于间接跳转，尽管它们可能对控制流信息的表示也很重要，但如何识别间接跳转的目标仍是一个公开的挑战，目前尚未包含在jTrans的工作范围内。</p></blockquote></li></ul><p><strong>提出方法的原理</strong></p><p>jTrans模型的设计理念是<strong>通过共享跳转对（jump pair）中source token和target token之间的参数，从而在它们的表示中创建高度的相似性</strong>。这样做的结果是，当jTrans的注意力机制分配高权重给这些token之一（即确定它对理解或分析二进制代码很重要）时，它们也会自动给对应的配对token分配高权重。因此，这种表示确保了跳转指令的两部分——以及在代码中与它们相邻的指令——都将包括在推理过程中。</p><p>公式分析：</p><p>对于给定的二元函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mo stretchy="false">[</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f = [x_1, · · · , x_n]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个标记。所有token在输入 jTrans 之前将被转换为混合嵌入向量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><mi>E</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">{E (x_1), · · ·, E (x_n)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>。将第 m 层的嵌入表示为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>m</mi></msub><mo>=</mo><mo stretchy="false">[</mo><msub><mi>E</mi><mi>m</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">⋅</mo><mo separator="true">,</mo><msub><mi>E</mi><mi>m</mi></msub><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">E_m = [E_m (x_1), · · · , E_m (x_n)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,⋅⋅⋅,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)]</span></span></span></span></p><ul><li><img src="/2024/05/11/jTrans/image-20240123205236392.png" alt="image-20240123205236392" style="zoom: 80%;"><ul><li>这是标准的-Transformer模型中的注意力机制。模型首先计算查询（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Q</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">Q_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）、键（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">K_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0715em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）和值（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">V_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>）矩阵。注意力得分是通过查询和键的缩放点积计算得到的，然后对这些得分应用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Softmax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span></span></span></span>函数来获得概率分布，最后用这个分布来加权值矩阵，得到该层的注意力输出。</li></ul></li><li><img src="/2024/05/11/jTrans/image-20240123205604570.png" alt="image-20240123205604570" style="zoom: 80%;"><ul><li>在有多个注意力头的情况下，每个头产生的更新嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>E</mi><mi>m</mi><mi>h</mi></msubsup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">E^h_m+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0961em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-2.453em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>是通过应用注意力机制到相应的查询、键和值上获得的。这里的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">h</span></span></span></span>代表注意力头的编号。</li></ul></li><li><img src="/2024/05/11/jTrans/image-20240123205738674.png" alt="image-20240123205738674" style="zoom: 80%;"><ul><li>在获取了所有注意力头的输出后，它们被连接在一起，并通过输出转换矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>W</mi><mi>m</mi><mi>O</mi></msubsup></mrow><annotation encoding="application/x-tex">W^O_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.453em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>来获得下一层的嵌入表示<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">E_{m+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span></span></span></span>。然后，这个表示通过一个前馈网络<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>F</mi><msub><mi>N</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">FFN_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">FF</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.109em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来进一步转换。</li></ul></li><li><img src="/2024/05/11/jTrans/image-20240123211133057.png" alt="image-20240123211133057" style="zoom: 80%;"><ul><li>jTrans的最终输出是模型最后一层的输出。函数嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">E_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>是通过将特殊标记<code>&lt;CLS&gt;</code>的嵌入与函数嵌入权重矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>W</mi><mi>F</mi></msup></mrow><annotation encoding="application/x-tex">W^F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span></span></span></span></span></span></span>进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>a</mi><mi>n</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">Tanh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">anh</span></span></span></span>非线性激活函数处理后获得的。</li></ul></li><li><img src="/2024/05/11/jTrans/image-20240123211332073.png" alt="image-20240123211332073" style="zoom: 80%;"><ul><li>这个公式说明了source token<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>通常比其他任何token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>给予target token<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>更多的注意力。<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{ij}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">ij</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>代表token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>对token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>的注意力权重，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>l</mi></mrow></msub></mrow><annotation encoding="application/x-tex">A_{il}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>对token <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>的注意力权重。</li><li>在Appendix部分有对这个公式的具体注明，我还没细看</li></ul></li></ul><h4 id="预训练模型">预训练模型</h4><p><strong>第一个任务：掩码语言模型任务（The Masked Language Model Task, MLM）</strong></p><ul><li><p>它使用了BERT的掩码策略，其中80%的选择标记被一个特殊的<code>&lt;MASK&gt;</code>标记替换，10%被其他随机标记替换，剩下的10%保持不变。MLM任务的目标是重构这些被掩盖的标记，其目标函数公式如下：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mrow><mi>min</mi><mo>⁡</mo></mrow><mi mathvariant="normal">Θ</mi></msub><msub><mi>L</mi><mrow><mi>M</mi><mi>L</mi><mi>M</mi></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>f</mi><mrow><mi>m</mi><mi>l</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\min_{\Theta} L_{MLM}(\Theta) = \sum_{i} -\log P(x_i | f_{mlm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mop">min</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>l</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{mlm}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表含有掩码标记的函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">Θ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Θ</span></span></span></span>代表模型参数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>是被掩码的标记的索引。</p><blockquote><ul><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Θ</mi></mrow><annotation encoding="application/x-tex">\Theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Θ</span></span></span></span>：代表模型的参数。优化这个目标函数意味着我们想要调整模型的参数以最小化损失函数的值。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mrow><mi>M</mi><mi>L</mi><mi>M</mi></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L_{MLM}(\Theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span><span class="mord mathnormal mtight">L</span><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span></span></span></span>：是损失函数，特定于MLM任务。这个函数衡量的是模型对于被掩码标记正确预测的准确性。这个值越低，表示模型的预测越准确。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>∑</mo><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\sum_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span></span></span></span>：表示对所有被掩码的标记进行求和。这意味着我们会计算每个被掩码标记的预测损失，并将它们加起来得到总损失。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>f</mi><mrow><mi>m</mi><mi>l</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\log P(x_i | f_{mlm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>：是对给定的掩码序列 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>l</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{mlm}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个被掩码标记的负对数似然。这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>f</mi><mrow><mi>m</mi><mi>l</mi><mi>m</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">P(x_i | f_{mlm})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 表示模型预测实际标记 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的概率。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>m</mi><mi>l</mi><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{mlm}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mord mathnormal mtight">m</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>：是经过掩码处理后的函数或代码序列。在这个序列中，一些标记被特殊的 <code>&lt;MASK&gt;</code> 标记替换，模型需要预测这些标记原来的值。</p></li></ul></blockquote></li></ul><p><strong>第二个任务：跳转目标预测任务（Jump Target Prediction, JTP）</strong></p><ul><li>JTP任务要求模型预测给定source token的target token。这个任务对于模型来说很有挑战性，因为它需要模型深入理解CFG。JTP任务通过先选择一部分可用的跳转source token，然后用<code>&lt;LOC&gt;</code>替换这些token来进行。JTP任务的目标函数可以表述为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi mathvariant="normal">Θ</mi></msub><msub><mi>L</mi><mrow><mi>J</mi><mi>T</mi><mi>P</mi></mrow></msub><mo stretchy="false">(</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mi>i</mi></msub><mo>−</mo><mi>log</mi><mo>⁡</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><msub><mi>f</mi><mrow><mi>j</mi><mi>t</mi><mi>p</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min_{\Theta} L_{JTP}(\Theta) = \sum_{i} -\log P(x_i | f_{jtp})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">mi</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.09618em;">J</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">TP</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">Θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.162em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2997em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight">tp</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>j</mi><mi>t</mi><mi>p</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{jtp}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9805em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1076em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mord mathnormal mtight">tp</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>代表含有<code>&lt;LOC&gt;</code>token的函数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>是跳转符号的位置集合。</li></ul><p>预训练阶段jTrans的总体损失函数是MLM和JTP目标函数的和：<br>$min_{\Theta} L_{P}(\Theta) = L_{MLM}(\Theta) + L_{JTP}(\Theta) $</p><h4 id="二进制相似性检测的微调">二进制相似性检测的微调</h4><p>目标是训练jTrans最大化相似二进制函数对之间的相似性，同时最小化不相关函数对的相似性。使用余弦相似度作为函数相似性的度量。</p><p>目标函数：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><msub><mi>n</mi><mi>θ</mi></msub><msub><mi>L</mi><mi>F</mi></msub><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mo>∑</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo separator="true">,</mo><msup><mi>g</mi><mo>+</mo></msup><mo separator="true">,</mo><msup><mi>g</mi><mo>−</mo></msup><mo stretchy="false">)</mo><mo>∈</mo><mi mathvariant="script">D</mi></mrow></msub><mi>max</mi><mo>⁡</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mi>ϵ</mi><mo>−</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>E</mi><mi>f</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><msup><mi>g</mi><mo>+</mo></msup></msub><mo stretchy="false">)</mo><mo>+</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><msub><mi>E</mi><mi>f</mi></msub><mo separator="true">,</mo><msub><mi>E</mi><msup><mi>g</mi><mo>−</mo></msup></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">min_{\theta} L_{F}(\theta) = \sum_{(f,g^+,g^-) \in \mathcal{D}} \max(0, \epsilon - \cos(E_f, E_{g^+}) + \cos(E_f, E_{g^-}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">mi</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">F</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2247em;vertical-align:-0.4747em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2253em;"><span style="top:-2.4003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span><span class="mpunct mtight">,</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span><span class="mrel mtight">∈</span><span class="mord mathcal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4747em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">ϵ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0361em;vertical-align:-0.2861em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span><br>其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 表示模型参数，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span> 是一个超参数（通常在0到0.5之间选择），<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mi>f</mi></msub></mrow><annotation encoding="application/x-tex">E_f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><msup><mi>g</mi><mo>+</mo></msup></msub></mrow><annotation encoding="application/x-tex">E_{g^+}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><msup><mi>g</mi><mo>−</mo></msup></msub></mrow><annotation encoding="application/x-tex">E_{g^-}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3419em;"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7027em;"><span style="top:-2.786em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span> 分别表示函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>、相似函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">g^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9658em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> 和不相关函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">g^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9658em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span> 的嵌入向量。这个目标函数试图确保查询函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的嵌入与相似函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo>+</mo></msup></mrow><annotation encoding="application/x-tex">g^+</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9658em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">+</span></span></span></span></span></span></span></span></span></span></span> 的嵌入的余弦相似度比与不相关函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>g</mi><mo>−</mo></msup></mrow><annotation encoding="application/x-tex">g^-</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9658em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7713em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">−</span></span></span></span></span></span></span></span></span></span></span> 的余弦相似度大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">ϵ</span></span></span></span>。</p><h4 id="大规模数据集的构建">大规模数据集的构建</h4><p>数据集是基于ArchLinux官方仓库和Arch用户仓库构建的。</p><ul><li><p>出于编译兼容性的考虑，选择了C/C++项目来构建数据集。（根据PKGBUILD文件判断）</p></li><li><p>修改后的编译器会更改与优化级别相关的命令行参数，并将预期的编译参数附加到原始参数中。</p></li><li><p>收集标签需要首先获取unstripped的二进制文件并获取函数的偏移量。许多实际项目在编译过程中会调用strip。故用修改后的strip版本替换了strip，无论传入参数如何，它都不会剥离符号表。</p></li></ul><h3 id="实验和效果">实验和效果</h3><p><strong>BinaryCorp数据集</strong>：包含了由自动编译管道生成的大量二进制文件。这些文件是基于官方ArchLinux包和Arch用户仓库使用gcc和g++编译的，其中包含了48,130个不同优化级别的二进制程序。</p><img src="/2024/05/11/jTrans/image-20240124184047031.png" alt="image-20240124184047031" style="zoom:80%;"><p><img src="/2024/05/11/jTrans/image-20240124183745240.png" alt="image-20240124183745240"></p><p><strong>二进制相似性检测性能</strong>：</p><p>jTrans明显优于baseline</p><p><strong>池大小对性能的影响</strong>：</p><p>随着池大小的增加，所有基准模型的相对性能均不如jTrans。此外，jTrans的性能没有出现急剧下降，而基准模型的性能在池大小达到100时通常会更快地下降。（详见论文Figure 6）</p><p><strong>现实世界的漏洞搜索</strong>：</p><p>对一个已知漏洞数据集中的八个CVE（公共漏洞和曝光）进行了漏洞函数搜索。为每个函数制作了10个不同编译器（gcc、clang）和不同优化级别的变体。评估指标为recall@10。</p><img src="/2024/05/11/jTrans/image-20240124184618667.png" alt="image-20240124184618667" style="zoom:80%;"><p><strong>Jump-aware设计的影响</strong>：</p><p>研究团队训练了一个标准的BERT模型，该模型不使用跳转信息的表示，并将其与jTrans进行比较。</p><p>在BinaryCorp3M数据集上，使用池大小为10,000的Recall@1指标评估了标准BERT模型和jTrans。评估结果表明，标准BERT的性能显著低于jTrans，jTrans平均优于BERT 7.3%。</p><p>另外，在BinaryCorp-3M数据集上进行的实验显示，jTrans能够高效地预测跳转位置。预训练模型可以以92.9%的top-1准确率和99.5%的top-10准确率预测跳转指令的目标。</p><p><strong>预训练的有效性</strong>：</p><p>为了评估预训练方法（包括掩蔽语言模型（MLM）和跳转目标预测（JTP））的有效性，研究团队评估了一个未进行任何微调的模型版本，称为jTrans-zero。</p><p>即使没有微调，jTrans-zero在池大小为10000的设置中仍然超过了所有基准模型。</p><p>在池大小为32的设置中，jTrans-zero超过了除SAFE以外的所有基准模型</p><h3 id="结论"><strong>结论</strong></h3><blockquote><p>在讨论中，作者指出：尽管jTrans目前专注于x86架构，但提出的技术也可应用于其他架构。</p><p>在现实世界场景中，池大小可能会更大。直接以两个二进制函数作为输入的模型可能更好地捕获函数间关系，即使在大型池中也能进一步提高BCSD的性能。然而，直接比较两个函数的模型训练将具有更高的开销。如何在实际BCSD任务中平衡jTrans的准确性和开销，将作为未来的研究工作。</p></blockquote><p>这项工作提出了jTrans，这是首个将控制流信息嵌入基于Transformer的语言模型的解决方案。该方法采用了一种新颖的跳转感知架构设计，不依赖于图神经网络（GNNs）。自注意力的理论分析证明了设计的合理性。实验结果表明，该方法在二进制代码相似度检测（BCSD）任务上始终大幅度超过现有最先进方法。通过深入评估，作者还发现了当前最先进方法评估中的弱点。此外，作者还向社区呈现并发布了一个新创建的数据集，名为BinaryCorp。该数据集包含了迄今为止最大量的多样化二进制文件，作者相信它可以作为未来这一领域研究的高质量基准。</p>]]></content>
    
    
    <categories>
      
      <category>Binary Similarity论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>Binary Similarity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文笔记】Order Matters （AAAI 20）</title>
    <link href="/2024/05/04/Order%20Matters/"/>
    <url>/2024/05/04/Order%20Matters/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：部分内容参考自GPT生成的内容</p></blockquote><h2 id="论文笔记：Order-Matters（AAAI-20）">论文笔记：Order Matters（AAAI 20）</h2><p>用于二进制代码相似性检测的语义感知神经网络</p><p>论文:《<a href="https://keenlab.tencent.com/en/whitepapers/Ordermatters.pdf">Order Matters: Semantic-Aware Neural Networks for Binary Code Similarity Detection</a>》（<strong>AAAI 2020</strong>)</p><blockquote><p>笔记参考：<a href="https://keenlab.tencent.com/zh/2019/12/10/Tencent-Keen-Security-Lab-Order-Matters/">AAAI-20论文解读：基于图神经网络的二进制代码分析 | 腾讯科恩实验室官方博客 (tencent.com)</a></p></blockquote><h3 id="动机">动机</h3><p>传统方法通常使用图匹配算法，但这些方法慢且不准确。尽管基于神经网络的方法取得了进展（如Gemini），但它们每个基本块都是以人工选择特征的低维嵌入来表示的，通常不能充分捕获二进制代码的语义信息。其次，节点的顺序在表示二进制函数时起着重要作用，而以往的方法并没有设计提取节点顺序的方法。</p><blockquote><p>另外，在Related Work中提到，(Zuo et al 2018) 使用的NLP模型也有缺点。他们通过修改编译器，在每个生成的汇编块中添加一个基本块特殊注释器，该注释器为每个生成的块注释一个唯一ID。这样，可以将来自同一源代码片段编译的两个基本块视为等效。获取相似块对是一个有监督的过程，不同操作系统或硬件架构需要训练不同的模型</p></blockquote><h3 id="方法">方法</h3><p><strong>提出的模型</strong>：</p><p>模型的输入是二进制代码函数的控制流图（CFGs），其中每个块是带有中间表示的token序列。在语义感知上，模型使用BERT预训练接受CFG作为输入，并预训练token嵌入和块嵌入。在结构感知上，使用带GRU更新函数的MPNN来计算图的语义和结构嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{ss}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ss</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。在顺序感知上，采用CFG的邻接矩阵作为输入，并使用CNN来计算图的顺序嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>o</mi></msub></mrow><annotation encoding="application/x-tex">g_{o}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。最后将它们连接起来，并使用一个MLP层来计算图嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>f</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>M</mi><mi>L</mi><mi>P</mi><mo stretchy="false">(</mo><mo stretchy="false">[</mo><msub><mi>g</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub><mo separator="true">,</mo><msub><mi>g</mi><mi>o</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_{final} =MLP([g_{ss}, g_{o}])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7167em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10764em;">f</span><span class="mord mathnormal mtight">ina</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">([</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ss</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">])</span></span></span></span></p><img src="/2024/05/04/Order%20Matters/image-20240121203627839-17058476037342.png" alt="image-20240121203627839" style="zoom:80%;"><h4 id="语义感知模块-Semantic-aware-Modeling">语义感知模块 (Semantic-aware Modeling)</h4><p>使用BERT进行预训练，包括四个任务：掩码语言模型任务（MLM）、邻接节点预测任务（ANP）、块内图任务（BIG）和图分类任务（GC）。这些任务帮助模型提取CFG的token级别、块级别和图级别的语义信息。</p><img src="/2024/05/04/Order%20Matters/image-20240121204851147-17058476023021.png" alt="image-20240121204851147" style="zoom: 80%;"><ul><li><strong>掩码语言模型任务（MLM）</strong>：通过在输入层掩盖token并在输出层预测它们来提取<strong>块内的语义信息</strong>。这是一个自监督任务，模型在训练过程中某些token会被隐藏，模型必须基于其他token提供的上下文来预测缺失的token。</li><li><strong>邻接节点预测任务（ANP）</strong>：因为块的信息不仅与块本身的内容相关，还与其邻近的块相关，ANP任务旨在让模型学习这种<strong>邻接信息</strong>。它涉及提取图中所有相邻块对，并在同一图中随机抽样多个块对，以预测它们是否相邻。</li><li><strong>图内块任务（BIG</strong>）：与ANP类似，BIG任务旨在帮助模型判断两个节点是否存在于同一图中。它涉及随机抽样可能在同一图中或不在同一图中的块对，并预测它们的关系。这有助于模型理解<strong>块与整个图之间的关系</strong>。</li><li><strong>图分类任务（GC）</strong>：使模型能够基于不同平台、架构或优化选项来分类块，特别是在不同编译条件下。GC任务要求模型<strong>区分由于这些不同条件而产生的图和块信息的差异</strong>。</li></ul><h4 id="结构感知模块-Structural-aware-Modeling">结构感知模块 (Structural-aware Modeling)</h4><p>使用消息传递神经网络（MPNN）结合GRU（门控循环单元）更新函数，以提取CFG的全图语义和结构嵌入(the whole graph semantic &amp; structural embedding)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{ss}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ss</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p><img src="/2024/05/04/Order%20Matters/image-20240121215922638.png" alt="image-20240121215922638" style="zoom: 67%;"><ul><li><p><strong>消息传递（Message Passing）</strong></p><ul><li>公式(2)表示的是消息传递阶段。对于图中的每个节点v，它计算了节点v在时间t+1的消息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>m</mi><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">m^{t+1}_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>。这个消息是通过聚合节点v的所有邻居节点w的信息（使用消息函数M）来得到的。这里，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">h^t_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0406em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>w</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">h^t_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0406em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>分别代表节点v和它的邻居节点w在时间t的嵌入，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mrow><mi>v</mi><mi>w</mi></mrow></msub></mrow><annotation encoding="application/x-tex">e_{vw}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是节点v和w之间边的特征。</li><li>公式(5)中，论文使用了多层感知机（Multi-Layer Perceptron, <strong>MLP</strong>）对邻居节点w的嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>w</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">h^t_w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0406em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>进行处理。</li></ul></li><li><p><strong>更新（Update）</strong></p><ul><li><p>公式(3)表示的是更新阶段。在这一步中，节点v的新嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">h^{t+1}_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>是通过更新函数U，结合节点v在时间t的嵌入和它在时间t+1收到的消息来计算的。</p></li><li><p>公式(6)说明了论文中的更新函数是通过GRU实现的，GRU考虑了节点的历史信息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mi>t</mi></msubsup></mrow><annotation encoding="application/x-tex">h^t_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0406em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7936em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>和新的消息<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>m</mi><mi>v</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">m^{t+1}_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>，来学习图的时序信息。</p></li></ul></li><li><p><strong>读出（Readout）</strong></p><ul><li>公式(4)定义了读出函数R，它计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>s</mi><mi>s</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{ss}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ss</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。这是通过对图中所有节点v的最终嵌入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">h^T_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>进行聚合来实现的。</li><li>公式(7)中，读出函数是通过对所有节点的初始嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mn>0</mn></msubsup></mrow><annotation encoding="application/x-tex">h^0_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>和最终嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">h^T_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0883em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>使用多层感知机（MLP）并进行求和来实现的。这里<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>h</mi><mi>v</mi><mn>0</mn></msubsup></mrow><annotation encoding="application/x-tex">h^0_v</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0611em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathnormal">h</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.453em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">v</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>是由BERT预训练得到的初始块嵌入。</li></ul></li></ul><img src="/2024/05/04/Order%20Matters/image-20240121220012016.png" alt="image-20240121220012016" style="zoom:67%;"><h4 id="顺序感知模块-Order-aware-Modeling"><strong>顺序感知模块</strong> (Order-aware Modeling)</h4><p>通过卷积神经网络（CNN）处理邻接矩阵，以提取CFG节点的顺序信息。</p><img src="/2024/05/04/Order%20Matters/image-20240122001434356.png" alt="image-20240122001434356" style="zoom:80%;"><p>如图，CNN能捕获从(a)到(b)的变化信息，当 CNN 看到大量训练数据时，它具有<strong>平移不变性</strong>（translation invariance）</p><p>对于(b)-&gt;©，与图像放缩类似，在看到足够多的训练数据后，CNN 也可以学习这种伸缩不变性（scale invariance）。</p><p>由于二进制代码函数在不同平台上编译时节点顺序通常不会大改变，<strong>CNN</strong>能够处理由此引起的添加、删除或交换节点等小变化，优势如下：</p><ol><li>使用CNN直接在邻接矩阵上的操作相比于传统的图特征提取算法要快得多。</li><li>CNN可以处理不同大小的输入，这允许模型处理不同大小的图而无需预处理，如填充或裁剪。</li></ol><p>使用具有 3 个残差块的 11 层 Resnet，所有的feature map大小均为3*3，最后使用最大池化层来计算图的顺序嵌入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mi>o</mi></msub><mo>=</mo><mi>M</mi><mi>a</mi><mi>x</mi><mi>p</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo stretchy="false">(</mo><mi>R</mi><mi>e</mi><mi>s</mi><mi>n</mi><mi>e</mi><mi>t</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_o = Maxpooling(Resnet(A))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">o</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mord mathnormal">p</span><span class="mord mathnormal">oo</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">in</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">es</span><span class="mord mathnormal">n</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mclose">))</span></span></span></span></p><h3 id="效果">效果</h3><p><strong>数据集：</strong></p><ul><li><p>任务1是跨平台二进制代码检测，目的是确认相同的源代码在不同平台上编译成的CFG是否具有较高的相似性得分。</p><ul><li>与Gemini模型类似，使用孪生网络（siamese network）来减少损失，并使用余弦距离来计算图的相似性。</li></ul></li><li><p>任务2是图分类，对图嵌入进行优化选项分类</p><ul><li>使用softmax函数并选择交叉熵作为损失函数</li></ul></li></ul><p>由于模型具有三个组成部分：语义感知、结构感知和顺序感知，因此进行了不同的实验来找出每个部分的效果。</p><p><img src="/2024/05/04/Order%20Matters/image-20240122012435397.png" alt="image-20240122012435397"><img src="/2024/05/04/Order%20Matters/image-20240122012444904.png" alt="image-20240122012444904" style="zoom: 67%;"></p><blockquote><p>表中：</p><ul><li><p>第一个分块是整体模型，包括graph kernel，Gemini以及MPNN模型。</p></li><li><p>第二个分块是语义感知模块的对比实验，分别使用了word2vec[5]，skip thought[6]，以及BERT，其中BERT2是指原始BERT论文中的两个task（即MLM和ANP），BERT4是指在此基础上加入两个graph-level task（BIG和GC）。</p></li><li><p>第三个分块是对顺序感知模块的对比实验，基础CNN模型使用3层CNN以及7、11层的Resnet，CNN_random是对训练集中控制流图的节点顺序随机打乱再进行训练，MPNN_ws是去除控制流图节点中的语义信息（所有block向量设为相同的值）再用MPNN训练。</p></li><li><p>最后是本文的最终模型，即BERT (4 tasks) + MPNN + 11layer Resnet。</p></li></ul></blockquote><blockquote><p>MPNN （即加上结构感知模块）在所有数据集上都优于 Gemini，这是因为 GRU 更新函数可以存储更多信息，因此在所有其他模型中都使用 MPNN。</p></blockquote><p>基于NLP的块预训练特征比手动特征好得多，并且顺序感知模块在两个任务上也有很好的结果。</p><p>在跨平台二进制代码检测任务中，语义信息比顺序信息更有用。不同的CFG可能具有相似的节点顺序，因此仅使用节点顺序信息是不够的。</p><p>最后，最终模型优于所有其他模型。</p><p><strong>分开观察各个模块的有效性</strong>：</p><blockquote><p><img src="/2024/05/04/Order%20Matters/image-20240122014527423.png" alt="image-20240122014527423" style="zoom: 50%;"> <img src="/2024/05/04/Order%20Matters/image-20240122014536191.png" alt="image-20240122014536191" style="zoom:50%;"></p><p>“语义感知（Semantic-aware）”：</p><ul><li>表中的第二块显示，BERT模型的性能优于word2vec和skip thought模型。这是因为BERT在预训练过程中不仅考虑了块级别的预测，还包括了token级别的预测，并且双向Transformer结构能够提取更多有用的信息。</li><li>当BERT模型加入了BIG和GC两个图级任务后，性能有了1%到2%的提升，表明引入图级任务对预训练是有益的。</li><li>图6展示了4个控制流图（CFG）的块嵌入可视化，使用K-means算法将预训练后的块嵌入分成四个类别，每个类别用不同颜色表示。从图中可以观察到，同一控制流图中的块倾向于拥有相同的颜色，而不同控制流图的主要颜色也不同。</li></ul><p>“顺序感知（Order-aware）”：</p><ul><li>表中的第三块显示，基于CNN的模型在两个任务上都取得了良好的效果，其中11层的Resnet略优于3层的CNN和7层的Resnet。</li><li>与不含语义信息的MPNN（MPNN_ws）相比，基于CNN的模型表现出更好的性能。</li><li>节点顺序被随机打乱后，CNN的效果显著下降，这证明CNN模型确实能够学习到图的节点顺序信息。</li><li>图7展示了两个由相同源代码编译而成的CFG变化的例子，尽管左图的节点3在右图中被分成了节点3和4，但其他节点的顺序和边的连接方式保持不变。通过CNN模型的计算，这两个CFG的余弦相似度为0.971，并且在整个平台中的代码检测排名中位列第一。这意味着CNN模型能够从邻接矩阵中有效提取控制流图的节点顺序信息，与假设相符。</li></ul></blockquote><h3 id="结论">结论</h3><p>这篇论文提出了一个新颖的二进制代码图学习框架，包含了语义感知组件、结构感知组件和顺序感知组件。作者观察到，语义信息和节点顺序信息对于表示控制流图（CFGs）都非常重要。为了捕捉语义特征，作者提出了针对CFGs块的BERT预训练，包括两个原始任务MLM和ANP，以及两个额外的图级任务BIG和GC。然后作者使用MPNN来提取结构信息。作者进一步提出了一个基于CNN的模型来捕捉节点顺序信息。作者在两个任务上使用了四个数据集进行了实验，实验结果表明本文提出的模型超越了当时最先进的方法。</p><h3 id="附：部分基础概念解释">附：部分基础概念解释</h3><blockquote><p>由于是第一次精读深度学习相关的技术论文，我翻看了很多基础概念</p></blockquote><h4 id="MLM和NSP">MLM和NSP</h4><p>MLM（Masked language model）和NSP（next sentence prediction）是BERT模型中两个重要的训练任务，它们共同帮助BERT学习理解语言的深层次结构和关系。以下是对这两个任务的具体介绍：</p><p><strong>掩码语言模型任务（MLM）</strong></p><ul><li><strong>目的</strong>：MLM旨在使模型能够更好地理解语言本身的规律和结构。它通过在文本中随机掩盖一些单词（即使用特殊的“[MASK]”标记替换），然后要求模型预测这些掩盖单词的原始值来实现。</li><li><strong>训练过程</strong>：在训练时，BERT模型会尝试根据上下文中的其他单词来猜测被掩盖的单词是什么。例如，在句子“The cat sat on the [MASK]”中，模型需要预测被掩盖的词是“mat”。</li><li><strong>作用</strong>：这种训练方式使得BERT能够有效地学习单词的上下文关系和语义信息，从而更好地理解语言。</li></ul><p><strong>下一个句子预测任务（NSP）</strong></p><ul><li><strong>目的</strong>：NSP的目标是使模型能够理解句子之间的关系。这对于很多NLP任务（如问答系统、自然语言推理等）至关重要。</li><li><strong>训练过程</strong>：在训练时，模型被给予一对句子，并需要判断第二个句子是否在原文中紧跟在第一个句子之后。训练集由两种类型的句子对组成：一种是真实的相邻句子对，另一种是随机组合的非相邻句子对。</li><li><strong>作用</strong>：通过这种方式，BERT学习理解句子之间的逻辑和关系，增强对文本的整体理解能力。</li></ul><h4 id="消息传递神经网络（MPNN）">消息传递神经网络（MPNN）</h4><p>消息传递神经网络（Message Passing Neural Network）是一类图神经网络，它通过在图的节点之间交换信息来学习节点的表示。它们基于以下步骤工作：</p><ol><li><strong>消息传递</strong>：每个节点接收其邻居节点的信息，并根据这些信息生成“消息”。</li><li><strong>聚合</strong>：将所有接收到的消息聚合成单个表示，这可以通过不同的函数实现，如求和、求平均或更复杂的操作。</li><li><strong>更新</strong>：使用聚合的信息来更新节点的状态。</li></ol><p>MPNN的核心思想是通过迭代这些步骤来精炼每个节点的表示，从而捕捉图的结构特征和节点之间的关系。</p><h4 id="门控循环单元（GRU）">门控循环单元（GRU）</h4><p>GRU（gated recurrent unit）是循环神经网络（RNN）的一种变体，用于处理序列数据。与传统的RNN相比，GRU通过引入门控机制来解决梯度消失和梯度爆炸的问题，使得网络能够捕捉长距离依赖关系。GRU包含两个门：</p><ol><li><strong>更新门</strong>：决定状态信息应该如何更新。</li><li><strong>重置门</strong>：决定过去的状态信息在计算新状态时应保留多少。</li></ol><p>在每个时间步，GRU可以选择保留旧状态的信息并融入新输入的信息，这使得它在处理具有复杂依赖结构的数据时非常有效。</p><h4 id="多层感知机-MLP"><strong>多层感知机 (MLP)</strong></h4><ul><li><strong>定义</strong>：多层感知机是一种基础的人工神经网络，由一个输入层、若干隐藏层和一个输出层组成。每一层由多个神经元组成，相邻层之间的神经元通过权重连接。</li><li><strong>功能</strong>：MLP主要用于分类和回归问题，能够识别和建模输入数据中的非线性关系。</li><li><strong>工作原理</strong>：在MLP中，数据从输入层进入，每个神经元对输入进行加权求和，再加上一个偏置项，最后通过激活函数进行非线性转换。这个过程在每个隐藏层中重复进行，直到输出层。在输出层，数据被转换为最终的输出格式（如分类标签或回归值）。</li></ul><h4 id="卷积神经网络-CNN"><strong>卷积神经网络 (CNN)</strong></h4><ul><li><strong>定义</strong>：卷积神经网络是一种深度学习网络，特别适用于处理具有网格结构的数据，如图像（2D网格）和声音（1D网格）。</li><li><strong>功能</strong>：CNN广泛应用于图像和视频识别、图像分类、医学图像分析、自然语言处理等领域。</li><li><strong>工作原理</strong>：CNN通过一系列卷积层、池化层和全连接层处理数据。卷积层使用卷积核提取空间特征，池化层（如最大池化）则减小特征维度并提供一定程度的位置不变性。最后，全连接层将提取的特征用于分类或回归任务。</li></ul><h4 id="最大池化-MaxPooling"><strong>最大池化 (MaxPooling)</strong></h4><ul><li><strong>定义</strong>：最大池化是一种池化操作，常在卷积神经网络中使用，用于减小特征图的空间尺寸。</li><li><strong>功能</strong>：最大池化通过降低参数数量和计算量来减少过拟合，同时保持重要特征。</li><li><strong>工作原理</strong>：最大池化通过在输入特征图的不同区域上应用一个固定大小的窗口，并从每个窗口中选择最大值来实现。这样做可以提取最显著的特征，并且对小的位置变化保持不变性。</li></ul><h4 id="残差网络-ResNet"><strong>残差网络 (ResNet)</strong></h4><ul><li><strong>定义</strong>：ResNet是一种深度卷积神经网络，通过引入残差学习框架来易于优化，并能够构建更深的网络。</li><li><strong>功能</strong>：ResNet在图像识别、分类和其他计算机视觉任务中表现优异。</li><li><strong>工作原理</strong>：在ResNet中，残差块的引入允许输入跳过一些层。每个残差块学习输入和输出的残差（差异），而不是直接学习输出。这帮助网络学习恒等映射，解决了深层网络中的梯度消失问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Binary Similarity论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>Binary Similarity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【论文笔记】关于“二进制函数相似性检测”的调研（Security 22）</title>
    <link href="/2024/05/03/How%20Machine%20Learning%20Is%20Solving%20the%20Binary%20Function%20Similarity%20Problem/"/>
    <url>/2024/05/03/How%20Machine%20Learning%20Is%20Solving%20the%20Binary%20Function%20Similarity%20Problem/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注：部分内容参考自GPT生成的内容</p></blockquote><h2 id="Security-22-关于“二进制函数相似性检测”的调研（个人阅读笔记）">[Security 22] 关于“二进制函数相似性检测”的调研（个人阅读笔记）</h2><p>论文：《<em><a href="https://link.zhihu.com/?target=https%3A//www.usenix.org/conference/usenixsecurity22/presentation/marcelli">How Machine Learning Is Solving the Binary Function Similarity Problem</a></em>》（<strong>Usenix Security 2022</strong>）</p><p>仓库：<a href="https://github.com/Cisco-Talos/binary_function_similarity">https://github.com/Cisco-Talos/binary_function_similarity</a></p><h3 id="动机">动机</h3><p>二进制函数相似性问题在系统安全研究领域扮演着重要角色，现有技术演变很快。但还没有研究能解答一些重要的研究问题，如：使用相同的数据集和相同的指标对不同的方法进行评估时，它们的比较结果如何？与简单的模糊哈希算法相比，新型机器学习解决方案的主要贡献是什么？不同特征集的作用是什么？不同的方法对不同的任务是否更有效？不同的方法对不同的任务是否更有效？跨架构比较是否比单一架构更难解决？在设计新技术的未来方向上，是否有任何特定的研究方向看起来更有前景？</p><p>要回答这些问题，有以下挑战：</p><ol><li>现有研究难以复现或复制先前的结果</li><li>研究结果的不透明性：不同的解决方案通常针对不同的目标定制，使用不同的相似性概念和操作粒度。</li><li>研究方向的不确定性：该领域的研究方向和原因不清晰，研究方法多样且分散</li></ol><blockquote><p>另外，论文在第二章从度量函数相似性的方法和特征表示方法两方面探讨了二进制函数相似性问题</p></blockquote><h3 id="实现的方法"><strong>实现的方法</strong></h3><p>这篇论文<strong>挑选方法的标准</strong>：</p><ol><li>可扩展性和实际应用性</li><li>关注有代表性的方法，而不是具体的论文</li><li>覆盖不同社区：安全、程序语言和机器学习，也考虑工业界</li><li>优先考虑最新趋势</li></ol><p>挑选出的方法，根据研究团队和功能相似性，<strong>划分</strong>如下：</p><img src="/2024/05/03/How%20Machine%20Learning%20Is%20Solving%20the%20Binary%20Function%20Similarity%20Problem/image-20240121161933831.png" alt="image-20240121161933831"><p>作者从中有些许<strong>发现</strong>：</p><ol><li><p>有些论文通过比较得到的结论是错误的，比如将跨架构、基于比对函数的方法与单一架构、比对二进制文件的方法进行比较。</p></li><li><p>不同领域的论文通常都很封闭，很少与其他领域的论文进行比较。</p></li><li><p>一个明显的趋势：随着时间的推移，解决方案的复杂性和机器学习的使用不断增加</p></li></ol><p>从以上挑选的方法中，作者<strong>挑选了十个具有可扩展性、代表性和最新性的最先进方法</strong>，准备进行评估。方法包括：</p><ul><li>Bytes fuzzy hashing: <strong>Catalog1</strong></li><li>CFG fuzzy hashing: <strong>FunctionSimSearch</strong></li><li>Attributed CFG and GNN: <strong>Gemini</strong></li><li>Attributed CFG, GNN, and GMN: <strong>Li et al. 2019</strong></li><li>IR, data flow analysis and neural network: <strong>Zeek</strong></li><li>Assembly code embedding: <strong>Asm2Vec</strong></li><li>Assembly code embedding and self-attentive encoder: <strong>SAFE</strong></li><li>Assembly code embedding, CFG and GNN: <strong>Massarelli et al., 2019</strong></li><li><strong>CodeCMR/BinaryAI</strong></li><li><strong>Trex</strong></li></ul><p><strong>以统一的方式实现了评估的各个阶段</strong>，包括：</p><ul><li><p>二进制分析（IDA Pro 7.3）</p></li><li><p>特征提取（a set of Python scripts using the IDA Pro APIs, Capstone , and NetworkX ）</p></li><li><p>机器学习的实现（Tensorflow 1.14, with the only exception of Trex , which was built on top of Fairseq）</p></li></ul><p><strong>创建了两个新数据集</strong>：旨在捕捉现实世界软件的复杂性和可变性，同时涵盖二进制函数相似性的不同挑战：(i) 多种编译器系列和版本，(ii) 多种编译器优化，(iii) 多种体系结构和位宽，以及 (iv) 不同性质的软件（命令行实用程序与图形用户界面应用程序）。</p><p><strong>确定了六种不同的评估任务</strong>：XO、XC、XC+XB、XA、XA+XO、XM。</p><blockquote><p>O：Optimizations，C：Compiler and Compiler Versions，B：Bitness，A：Architecture，M：Mixed</p></blockquote><h3 id="结果与讨论">结果与讨论</h3><ol><li><p>对Catalog1和FunctionSimSearch进行了<strong>Fuzzy-hashing Comparison</strong>：它们在面对多变量变化的任务时，表现有限。</p></li><li><p><strong>Machine-learning Models Comparison</strong>：</p><p>论文直接提供的结论如下：</p><ul><li>一种机器学习模型，来自 Li 等人的 GNN[40]在六个评估任务中优于所有其他变体，实现了与可扩展性较差的 GMN 版本类似的性能。</li><li>其他基于嵌入的模型[45, 49, 60, 76]显示出较低但相似的准确性。</li><li>Zeek[67]采用直接比较方法，其在处理大型函数时的AUC表现更好。</li><li>Asm2Vec[14]模型在多个任务中的表现并不优于其他模型。</li></ul><p>此外还在4.5节进行了多方面的讨论。</p></li><li><p><strong>Vulnerability Discovery Use Case</strong></p><ul><li><p>使用操作码特征的GMN模型表现最佳，但其可扩展性受限。</p></li><li><p>同时，特定配置下的FSS模型也意外地显示了良好的实用性能，但这种性能并不一定适用于所有配置。</p></li><li><p>表6包含了Netgear R7000固件中易受攻击函数的实际排名结果，显示即使MRR10值很高，实际排名可能仍然很低。</p></li></ul></li></ol><p>最后，在<strong>5 Discussion</strong>部分中，作者回答了开头提出的几个重要的研究问题，比如：</p><ul><li><p><strong>机器学习解决方案与模糊散列方法相比的主要贡献</strong>：机器学习模型即使在多个编译变量同时改变时也能达到高准确率，并且能够从大型训练数据集中受益，这些数据集是基于由编译选项定义的可靠基准。</p></li><li><p><strong>不同特征集的作用</strong>：</p><ul><li>使用基本块特征（例如，ACFG）提供更好的结果，但在精心手工设计的特征和更简单的特征（如基本块操作码的词袋）之间差异很小。</li><li>令人惊讶的是，指令嵌入[45]并没有提高GNN模型的性能，但作者认为需要进行广泛测试来评估其他可能的组合。</li></ul></li><li><p><strong>不同方法在不同任务中的表现</strong>：</p><ul><li>大多数机器学习模型在所有评估任务中表现相似，无论是在相同架构还是跨架构中。</li><li>不需要针对特定任务进行训练，因为使用最通用的任务数据（XM）就能达到接近每个任务最佳的性能。但这对于模糊散列方法并不适用。</li></ul></li><li><p><strong>哪些研究方向更有前途</strong>：深度学习模型、GNN与汇编指令编码器的结合、结合中间表示和数据流信息、训练策略和损失函数等补充方面。</p></li></ul><blockquote><p>更多讨论详见论文</p></blockquote><hr><h3 id="结论">结论</h3><p>本文进行了首次对超过五年来解决二进制函数相似性问题的研究工作的测量研究。作者识别了该研究领域中的一些挑战，以及这些挑战如何使得有意义的比较变得困难，甚至几乎不可能。本文工作旨在弥合这一差距，并帮助社区在这一研究领域获得更清晰的认识。作者希望通过发布所有的实现、数据集和原始结果，社区将拥有一个起点，以开始构建新的方法，并将其与一个共同的框架进行比较，以更好地辨别哪些新颖的方面实际上改进了现有技术状态，以及哪些方面只是看似如此。</p><h3 id="附：部分概念解释">附：部分概念解释</h3><h4 id="一些评估标准">一些评估标准</h4><ol><li><strong>ROC曲线（Receiver Operating Characteristic Curve）</strong>：<ul><li>ROC曲线是一个图形工具，用于评估二元分类器的性能。</li><li>它过将**真阳性率（True Positive Rate，TPR）<strong>和</strong>假阳性率（False Positive Rate，FPR）**作为横纵坐标来描绘分类器在不同阈值下的性能。</li><li>ROC曲线下的面积（AUC）用于量化分类器的整体性能。AUC值越接近1，表明分类器的性能越好。</li></ul></li><li><strong>top-n</strong>：<ul><li>top-n通常用于信息检索和推荐系统中，指的是从一系列项目中选择“最好”的n个项目。</li><li>例如，在推荐系统中，如果你想推荐5个最相关的项目，那么这就是一个top-5的任务。</li><li>在评估时，通常会查看这些top-n项目中有多少是真正相关或准确的。</li></ul></li><li><strong>MRR10（Mean Reciprocal Rank at 10）</strong>：<ul><li>MRR是一种评估信息检索系统效果的指标，特别是当查询返回一个项目列表时。</li><li>MRR10指的是在前10个返回项目中找到第一个正确答案的倒数的平均值。</li><li>例如，如果正确的答案在返回列表的第一个位置，其倒数排名是1；如果在第二个位置，其倒数排名是1/2，依此类推。计算所有查询的这个倒数排名的平均值即得到MRR10。</li></ul></li><li><strong>召回率 (Recall@K)</strong>：<ul><li>这个度量标准关注的是模型能够在前K个结果中检索到多少相关项目。</li><li>例如，如果一个模型能够在前10个返回的项目中找到所有相关项目，则Recall@10将是100%。</li></ul></li></ol><h4 id="pipeline">pipeline</h4><ol><li><strong>Pipeline</strong>:<ul><li>在计算机科学中，pipeline通常指的是一系列数据处理步骤或任务，这些步骤按照特定的顺序组织，每个步骤的输出成为下一个步骤的输入。</li><li>在软件工程和数据科学的背景下，pipeline涉及到从原始数据提取、处理、分析到最终产出的整个过程。例如，一个机器学习pipeline可能包括数据清洗、特征提取、模型训练和预测评估等步骤。</li></ul></li><li><strong>Non-trivial Pipelines</strong>:<ul><li>“Non-trivial”这个词用来描述那些不简单、复杂或需求高的任务或过程。</li><li>当文本中提到“non-trivial pipelines”，它指的是那些在设计和实现上具有一定复杂性和挑战性的数据处理流程。这些pipeline可能包含多个步骤，每个步骤都需要特别的注意，可能涉及复杂的算法或大量的数据处理。</li><li>在二进制函数相似性问题的背景下，non-trivial pipelines可能包括诸如确定函数边界、反汇编代码、提取控制流图等复杂步骤。这些步骤在技术上可能很复杂，需要深入理解底层的计算机架构和编程原理。</li></ul></li></ol><h4 id="“配对选择”（Pair-Selection）">“配对选择”（Pair Selection）</h4><ul><li>配对选择是指如何选择正负样本对（即相似和不相似的函数对）进行模型训练和评估。</li><li>这一方面对于适当的评估至关重要，因为它直接影响到训练任务的难度和评估结果的有效性。</li></ul><h4 id="“词袋”（Bag-of-Words）">“词袋”（Bag of Words）</h4><p>词袋模型将文本（如句子或文档）转换为一个词的集合，忽略了文本中词的顺序和语法结构。</p>]]></content>
    
    
    <categories>
      
      <category>Binary Similarity论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>Binary Similarity</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【Notice】2024年1月记</title>
    <link href="/2024/01/19/Open2024/"/>
    <url>/2024/01/19/Open2024/</url>
    
    <content type="html"><![CDATA[<h1>【Notice】2024年1月记</h1><p>上周刚考完期末考…研一上学期快结束了。</p><p>一直感觉最近一年没有做科研的状态！好像一直在摆烂。虽然了解了一些以后海外读博的信息，但是光了解有什么用呢。</p><p>本科期间的博客在这里都隐藏起来了，不过可以在CSDN找到它们：<a href="https://blog.csdn.net/qq_40025866?type=blog">Yuhan_2001-CSDN博客</a>。</p><p><strong>接下来我尽量更新一些自己看的文献（或许不是精读），或者一点技术相关的东西。</strong></p><p>Just finished finals last week … First semester of grad school is almost over.</p><p>Been feeling like I haven’t been in a state of doing research for the last year! I seems to be constantly slacking off. Although I have learnt some information about studying for a PhD overseas in the future, what’s the use of just knowing about it.</p><p>The blogs during my undergraduate years are hidden here, but you can find them on CSDN: <a href="https://blog.csdn.net/qq_40025866?type=blog">Yuhan_2001-CSDN Blog</a>.</p><p><strong>Next I’ll try to update with some papers I’ve read (maybe not intensively), or a bit of tech-related stuff.</strong></p>]]></content>
    
    
    <categories>
      
      <category>个人经历</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人经历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欢迎来到我的个人博客！</title>
    <link href="/2021/07/01/hello-world/"/>
    <url>/2021/07/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to my blog！</p><p>About me：<a href="https://yuhan2001.github.io/about/">关于页</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
