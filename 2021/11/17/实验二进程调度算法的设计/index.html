

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wu Yuhan">
  <meta name="keywords" content="">
  
    <meta name="description" content="操作系统的课程实验，C++编程实现进程调度算法（FCFS和RR）。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++编程实现进程调度算法">
<meta property="og:url" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="Yuhan&#39;s blog">
<meta property="og:description" content="操作系统的课程实验，C++编程实现进程调度算法（FCFS和RR）。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111101042496-16386246286605.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111182747792-16386243688573.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211112102915716-16386246370376.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116174257026-16386296754991.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173854064-16386296786083.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173837962-16386296818855.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173854064-16386296834527.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173935445-16386296849179.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173951387-163862968718611.png">
<meta property="article:published_time" content="2021-11-16T16:00:00.000Z">
<meta property="article:modified_time" content="2022-11-11T13:06:57.563Z">
<meta property="article:author" content="Wu Yuhan">
<meta property="article:tag" content="操作系统实验">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yuhan2001.github.io/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111101042496-16386246286605.png">
  
  
  <title>C++编程实现进程调度算法 - Yuhan&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://lib.baomitu.com/highlight.js/10.7.3/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yuhan2001.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"6da93a2e5d7f160e0f40b273ddbbddac","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuhan&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/3.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="C++编程实现进程调度算法">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-17 00:00" pubdate>
        2021年11月17日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.8k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      82 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">C++编程实现进程调度算法</h1>
            
            <div class="markdown-body">
              <h1 id="实验二-进程调度算法的设计"><a href="#实验二-进程调度算法的设计" class="headerlink" title="实验二 进程调度算法的设计"></a>实验二 进程调度算法的设计</h1><h2 id="实验题目"><a href="#实验题目" class="headerlink" title="实验题目"></a>实验题目</h2><ol>
<li><p>先来先服务（FCFS）调度算法</p>
<ul>
<li><p>原理：每次调度是从就绪队列中，选择一个最先进入就绪队列的进程，把处理器分配给该进程，使之得到执行。该进程一旦占有了处理器，它就一直运行下去，直到该进程完成或因发生事件而阻塞，才退出处理器。</p>
</li>
<li><p>将用户作业和就绪进程按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务的方式进行调度处理，是一种最普遍和最简单的方法。它优先考虑在系统中等待时间最长的作业，而不管要求运行时间的长短。</p>
</li>
<li><p>按照就绪进程进入就绪队列的先后次序进行调度，简单易实现，利于长进程，CPU繁忙型作业，不利于短进程，排队时间相对过长。</p>
<p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111101042496-16386246286605.png" srcset="/img/loading.gif" lazyload alt="image-20211111101042496"></p>
</li>
</ul>
</li>
<li><p>时间片轮转调度算法RR</p>
<ul>
<li>原理：时间片轮转法主要用于进程调度。采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度按一定时间片(q)轮番运行各个进程。</li>
<li>进程按到达时间在就绪队列中排队，调度程序每次把CPU分配给就绪队列首进程使用一个时间片，运行完一个时间片释放CPU，排到就绪队列末尾参加下一轮调度，CPU分配给就绪队列的首进程。</li>
</ul>
<p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211111182747792-16386243688573.png" srcset="/img/loading.gif" lazyload alt="image-20211111182747792"></p>
<ul>
<li>固定时间片轮转法：<ol>
<li>所有就绪进程按 FCFS 规则排队。</li>
<li>处理机总是分配给就绪队列的队首进程。</li>
<li>如果运行的进程用完时间片，则系统就把该进程送回就绪队列的队尾，重新排队。</li>
<li>因等待某事件而阻塞的进程送到阻塞队列。</li>
<li>系统把被唤醒的进程送到就绪队列的队尾</li>
</ol>
</li>
<li><p>可变时间片轮转法：</p>
<ol>
<li><p>进程状态的转换方法同固定时间片轮转法。</p>
</li>
<li><p>时间片的长短依据就绪队列进程数量的多少由$T=N*(q+t)$的关系调整（T为响应时间（固定），N为就绪队列进程数，q为时间片的长短，t为上下文切换时间。其中q为毫秒级及以上，上下文切换时间t为纳秒级而忽略不计）。即就绪队列进程数有变化时，时间片需要调整。</p>
<p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211112102915716-16386246370376.png" srcset="/img/loading.gif" lazyload alt="image-20211112102915716"></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="程序中使用的数据结构及符号说明"><a href="#程序中使用的数据结构及符号说明" class="headerlink" title="程序中使用的数据结构及符号说明"></a>程序中使用的数据结构及符号说明</h2><ul>
<li><p>结构体表示进程，结构体数组记录各个进程的信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span><br>&#123;<br>	<span class="hljs-type">int</span> id; <span class="hljs-comment">//编号</span><br>	<span class="hljs-type">int</span> pos; <span class="hljs-comment">//排序后的位置</span><br>	<span class="hljs-type">int</span> arrive; <span class="hljs-comment">//到达时间</span><br>	<span class="hljs-type">int</span> work; <span class="hljs-comment">//区间时间</span><br>	<span class="hljs-type">int</span> begin; <span class="hljs-comment">//开始时间</span><br>	<span class="hljs-type">int</span> end; <span class="hljs-comment">//完成时间</span><br>	<span class="hljs-type">int</span> turnaround; <span class="hljs-comment">//周转时间</span><br>	<span class="hljs-type">int</span> wait; <span class="hljs-comment">//等待时间</span><br>	<span class="hljs-type">bool</span> in; <span class="hljs-comment">//是否进入过就绪队列</span><br>	<span class="hljs-type">bool</span> finish; <span class="hljs-comment">//是否完成</span><br>	<span class="hljs-type">int</span> rest; <span class="hljs-comment">//剩余区间时间（RR）</span><br>	<span class="hljs-type">int</span> block_p; <span class="hljs-comment">//最近一次被阻塞的时间点</span><br>	<span class="hljs-type">int</span> <span class="hljs-type">block_t</span>; <span class="hljs-comment">//阻塞时间长度（RR）</span><br>&#125; proc[N];<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>使用数据结构queue（队列）:</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue &lt;process&gt; ready; <span class="hljs-comment">//就绪队列</span><br>queue &lt;process&gt; block; <span class="hljs-comment">//阻塞队列（RR）</span><br>queue &lt;process&gt; block_new; <span class="hljs-comment">//(临时)新阻塞队列,用于阻塞队列的更新（RR）</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>整型变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> k, k_RR, n, q;<br><span class="hljs-comment">/* 	k：算法类型（0:FCFS 1:RR）</span><br><span class="hljs-comment">	k_RR：RR算法类型（0:时间片固定 1:可变）</span><br><span class="hljs-comment">	n：进程数</span><br><span class="hljs-comment">	q：时间片</span><br><span class="hljs-comment">*/</span><br><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><br><span class="hljs-comment">//FCFS_And_RR函数内部</span><br><span class="hljs-type">int</span> left = n; <span class="hljs-comment">//剩余的未完成进程数</span><br><span class="hljs-type">int</span> once_max; <span class="hljs-comment">//一个时间片内一个进程最大运行时间</span><br><span class="hljs-type">int</span> once; <span class="hljs-comment">//记录一个时间片内的运行时间</span><br><span class="hljs-type">int</span> min_arrive = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//未到达进程的最小到达时间（可能有多个进程）</span><br><span class="hljs-type">int</span> in_flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间是否有进程入就绪队列</span><br></code></pre></div></td></tr></table></figure>
</li>
<li><p>函数：</p>
<p><code>bool cmp_FCFS(process a, process b)</code>：FCFS规则排队的比较函数；</p>
<p><code>bool cmp_id(process a, process b)</code>：按编号顺序的排序函数</p>
<p><code>void init()</code> :输入信息进行初始化的函数</p>
<p><code>void block_check()</code>: 查看阻塞队列中是否有进程被唤醒的函数</p>
<p><code>void FCFS_And_RR()</code>:FCFS调度算法和RR调度算法的函数</p>
<p><code>void display()</code>：用于输出结果的函数</p>
</li>
</ul>
<h2 id="源程序及注释："><a href="#源程序及注释：" class="headerlink" title="源程序及注释："></a>源程序及注释：</h2><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100001</span><br><span class="hljs-comment">//算法类型（0:FCFS 1:RR），RR算法类型（0:时间片固定 1:可变）,进程数，时间片</span><br><span class="hljs-type">int</span> k, k_RR, n, q;<br><br><span class="hljs-type">int</span> now = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">process</span><br>&#123;<br>	<span class="hljs-type">int</span> id; <span class="hljs-comment">//编号</span><br>	<span class="hljs-type">int</span> pos; <span class="hljs-comment">//排序后的位置</span><br>	<span class="hljs-type">int</span> arrive; <span class="hljs-comment">//到达时间</span><br>	<span class="hljs-type">int</span> work; <span class="hljs-comment">//区间时间</span><br>	<span class="hljs-type">int</span> begin; <span class="hljs-comment">//开始时间</span><br>	<span class="hljs-type">int</span> end; <span class="hljs-comment">//完成时间</span><br>	<span class="hljs-type">int</span> turnaround; <span class="hljs-comment">//周转时间</span><br>	<span class="hljs-type">int</span> wait; <span class="hljs-comment">//等待时间</span><br>	<span class="hljs-type">bool</span> in; <span class="hljs-comment">//是否进入过就绪队列</span><br>	<span class="hljs-type">bool</span> finish; <span class="hljs-comment">//是否完成</span><br>	<span class="hljs-type">int</span> rest; <span class="hljs-comment">//剩余区间时间</span><br>	<span class="hljs-type">int</span> block_p; <span class="hljs-comment">//最近一次被阻塞的时间点</span><br>	<span class="hljs-type">int</span> <span class="hljs-type">block_t</span>; <span class="hljs-comment">//阻塞时间长度</span><br>&#125; proc[N];<br>queue &lt;process&gt; ready; <span class="hljs-comment">//就绪队列</span><br>queue &lt;process&gt; block; <span class="hljs-comment">//阻塞队列（RR）</span><br>queue &lt;process&gt; block_new; <span class="hljs-comment">//(临时)新阻塞队列,用于阻塞队列的更新（RR）</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_FCFS</span><span class="hljs-params">(process a, process b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (a.arrive != b.arrive)<br>		<span class="hljs-keyword">return</span> a.arrive &lt; b.arrive;<br>	<span class="hljs-keyword">else</span><br>		<span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp_id</span><span class="hljs-params">(process a, process b)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> a.id &lt; b.id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;请输入算法类型（0:FCSS 1:RR）：&quot;</span>;<br>	cin &gt;&gt; k;<br>	cout &lt;&lt; <span class="hljs-string">&quot;请输入进程个数：&quot;</span>;<br>	cin &gt;&gt; n;<br>	<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;请输入时间片大小：&quot;</span>;<br>		cin &gt;&gt; q;<br>		cout &lt;&lt; <span class="hljs-string">&quot;请输入RR算法类型（0:时间片固定 1:时间片可变）:&quot;</span>;<br>		cin &gt;&gt; k_RR;<br>	&#125;<br>	cout &lt;&lt; <span class="hljs-string">&quot;请按进程到达先后输入进程信息（1~n）：到达时间 区间时间&quot;</span> &lt;&lt;<br>		endl; <span class="hljs-comment">//要求按到达先后顺序输入，以便于到达时间相同时判断先后</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;:&quot;</span>;<br>		cin &gt;&gt; proc[i].arrive &gt;&gt; proc[i].work;<br>		<span class="hljs-comment">//信息初始化</span><br>		proc[i].id = i;<br>		proc[i].in = <span class="hljs-number">0</span>;<br>		proc[i].begin = <span class="hljs-number">-1</span>; <span class="hljs-comment">//表示还没开始</span><br>		proc[i].finish = <span class="hljs-number">0</span>;<br>		proc[i].<span class="hljs-type">block_t</span> = <span class="hljs-number">0</span>;<br>		proc[i].rest = proc[i].work;<br>	&#125;<br>	<span class="hljs-built_in">sort</span>(proc, proc + n + <span class="hljs-number">1</span>, cmp_FCFS);<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		proc[i].pos = i;<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">block_check</span><span class="hljs-params">()</span> <span class="hljs-comment">//查看阻塞队列中是否有进程被唤醒</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">while</span> (!block.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//遍历旧阻塞队列一次</span><br>	&#123;<br>		process t2 = block.<span class="hljs-built_in">front</span>();<br>		block.<span class="hljs-built_in">pop</span>();<br>		<span class="hljs-keyword">if</span> (t2.block_p != now) <span class="hljs-comment">//如果不是刚被阻塞，则有唤醒的可能</span><br>		&#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">2</span>) <span class="hljs-comment">//设定阻塞进程有1/2的概率被唤醒</span><br>			&#123;<br>				t2.<span class="hljs-type">block_t</span> += (now - t2.block_p); <span class="hljs-comment">//更新阻塞时长</span><br>				cout &lt;&lt; <span class="hljs-string">&quot;在时刻&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;，进程&quot;</span> &lt;&lt; t2.id &lt;&lt; <span class="hljs-string">&quot;被唤醒&quot;</span> &lt;&lt; endl;<br>				ready.<span class="hljs-built_in">push</span>(t2);<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-comment">//仍被阻塞，入新阻塞队列</span><br>			&#123;<br>				block_new.<span class="hljs-built_in">push</span>(t2);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-comment">//刚被阻塞，入新阻塞队列</span><br>		&#123;<br>			block_new.<span class="hljs-built_in">push</span>(t2);<br>		&#125;<br>	&#125;<br>	block = block_new; <span class="hljs-comment">//阻塞队列更新</span><br>	<span class="hljs-keyword">while</span> (!block_new.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//清空临时的阻塞队列</span><br>	&#123;<br>		block_new.<span class="hljs-built_in">pop</span>();<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FCFS_And_RR</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">srand</span>((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>))); <span class="hljs-comment">//随机数生成种子随系统时间变化</span><br>	<span class="hljs-type">int</span> left = n; <span class="hljs-comment">//剩余的未完成进程数</span><br>	<span class="hljs-type">int</span> once_max; <span class="hljs-comment">//一个进程最大连续运行时间</span><br>	<span class="hljs-type">int</span> once; <span class="hljs-comment">//记录一个进程一次的运行时间</span><br>	<span class="hljs-keyword">while</span> (left &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//有进程没有完成</span><br>	&#123;<br>		<span class="hljs-type">int</span> min_arrive = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//未到达进程的最小到达时间（可能有多个进程）</span><br>		<span class="hljs-type">int</span> in_flag = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间是否有进程入就绪队列</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>		&#123;<br>			<span class="hljs-keyword">if</span> (!proc[i].in &amp;&amp; proc[i].arrive &lt; min_arrive)<br>			&#123;<br>				min_arrive = proc[i].arrive;<br>				in_flag = <span class="hljs-number">1</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (min_arrive &gt;= now &amp;&amp; in_flag)<br>		&#123;<br>			<span class="hljs-comment">//若当前时间小于剩余未完成进程（存在时in_flag=1）的最小到达时间，则输出以下信息并更新值</span><br>			<span class="hljs-keyword">if</span> (min_arrive &gt; now)<br>				cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; min_arrive &lt;&lt; <span class="hljs-string">&quot;内,没有进程在运行&quot;</span> &lt;&lt; endl;<br>			now = min_arrive;<br>			<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>			&#123;<br>				<span class="hljs-keyword">if</span> (proc[i].arrive == min_arrive)<br>				&#123;<br>					proc[i].in = <span class="hljs-number">1</span>;<br>					ready.<span class="hljs-built_in">push</span>(proc[i]);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (!ready.<span class="hljs-built_in">empty</span>())<br>		&#123;<br>			process t = ready.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取出就绪队列队首</span><br>			ready.<span class="hljs-built_in">pop</span>();<br>			<span class="hljs-keyword">if</span> (t.begin == <span class="hljs-number">-1</span>) <span class="hljs-comment">//如果是第一次出就绪队列</span><br>			&#123;<br>				t.begin = now; <span class="hljs-comment">//开始时间=当前时间</span><br>			&#125;<br>			<span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) <span class="hljs-comment">//FCFS</span><br>			&#123;<br>				once_max = t.rest; <span class="hljs-comment">//一个进程单次最大运行时间为剩余区间时间（即不发生阻塞的情况）</span><br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-comment">//RR</span><br>			&#123;<br>				once_max = <span class="hljs-built_in">min</span>(q, t.rest);<br>				<span class="hljs-comment">//一个进程单次最大运行时间为时间片长度和剩余区间时间的相比较的最小值</span><br>			&#125;<br>			once = <span class="hljs-number">0</span>;<br>			<span class="hljs-keyword">while</span> (once &lt; once_max) <span class="hljs-comment">//一个进程运行中</span><br>			&#123;<br>				now++; <span class="hljs-comment">//当前时间加1</span><br>				once++; <span class="hljs-comment">//单次进程运行时间加1</span><br>				t.rest--; <span class="hljs-comment">//剩余时间减1</span><br>				<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-comment">//遍历所有进程</span><br>				&#123;<br>					<span class="hljs-keyword">if</span> (!proc[i].in &amp;&amp; proc[i].arrive == now) <span class="hljs-comment">//若有进程还没有进入过就绪队列，且当前到达</span><br>					&#123;<br>						proc[i].in = <span class="hljs-number">1</span>; <span class="hljs-comment">//更改标记</span><br>						ready.<span class="hljs-built_in">push</span>(proc[i]); <span class="hljs-comment">//进入就绪队列</span><br>					&#125;<br>				&#125;<br>				<span class="hljs-built_in">block_check</span>(); <span class="hljs-comment">//查看阻塞队列中是否有进程被唤醒</span><br>				<span class="hljs-keyword">if</span> (<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; t.rest != <span class="hljs-number">0</span>)	<span class="hljs-comment">//设定当前进程单位时间有1/10的概率发生阻塞</span><br>				&#123;<br>					t.block_p = now; <span class="hljs-comment">//更新最近一次被阻塞的时间点</span><br>					block.<span class="hljs-built_in">push</span>(t); <span class="hljs-comment">//阻塞，入阻塞队列队尾</span><br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (t.rest &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//剩余时间大于0</span><br>			&#123;<br>				cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now - once &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;内,进程&quot;</span> &lt;&lt; t.id &lt;&lt; <span class="hljs-string">&quot;在运行&quot;</span>;<br>				<span class="hljs-keyword">if</span> (t.block_p == now) <span class="hljs-comment">//说明阻塞</span><br>				&#123;<br>					cout &lt;&lt; <span class="hljs-string">&quot;,后阻塞&quot;</span>;<br>				&#125;<br>				<span class="hljs-keyword">else</span> <span class="hljs-comment">//没阻塞则入就绪队列</span><br>				&#123;<br>					ready.<span class="hljs-built_in">push</span>(t);<br>				&#125;<br>				cout &lt;&lt; endl;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-comment">//剩余时间等于0，表示运行完成</span><br>			&#123;<br>				cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now - once &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; now &lt;&lt; <span class="hljs-string">&quot;内,进程&quot;</span> &lt;&lt; t.id &lt;&lt; <span class="hljs-string">&quot;在运行。该进程完成。&quot;</span> &lt;&lt; endl;<br>				t.end = now; <span class="hljs-comment">//完成时间=当前时间</span><br>				t.finish = <span class="hljs-number">1</span>; <span class="hljs-comment">//更新标记：已完成</span><br>				t.turnaround = t.end - t.arrive; <span class="hljs-comment">//周转时间=完成时间-到达时间</span><br>				t.wait = t.turnaround - t.work - t.<span class="hljs-type">block_t</span>; <span class="hljs-comment">//等待时间=周转时间-区间时间-阻塞时间</span><br>				proc[t.pos] = t; <span class="hljs-comment">//更新（已完成的）进程信息</span><br>				left--; <span class="hljs-comment">//剩余进程数减1</span><br>				<span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span> &amp;&amp; k_RR == <span class="hljs-number">1</span>) <span class="hljs-comment">//时间片可变的RR算法</span><br>				&#123;<br>					q = ((<span class="hljs-type">double</span>)n / left) * q;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">else</span> <span class="hljs-comment">//可能当就绪队列为空时，也有进程在阻塞队列</span><br>		&#123;<br>			<span class="hljs-type">int</span> in_block = <span class="hljs-number">0</span>; <span class="hljs-comment">//停留在阻塞队列的时间</span><br>			<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>			&#123;<br>				<span class="hljs-built_in">block_check</span>();<span class="hljs-comment">//查看阻塞队列中是否有进程被唤醒</span><br>				<span class="hljs-keyword">if</span> (left == block.<span class="hljs-built_in">size</span>() &amp;&amp; left &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//如果未完成的进程都在阻塞队列里</span><br>				&#123;<br>					in_block++; <span class="hljs-comment">//更新停留在阻塞队列的时间，继续进行循环</span><br>					now++;<br>				&#125;<br>				<span class="hljs-keyword">else</span><br>				&#123;<br>					<span class="hljs-keyword">break</span>; <span class="hljs-comment">//否则只进行一次遍历，因为还有其他没有在阻塞队列的进程</span><br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">if</span> (in_block &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//只剩阻塞队列中的进程，且没运行，输出信息</span><br>			&#123;<br>				cout &lt;&lt; <span class="hljs-string">&quot;在时间&quot;</span> &lt;&lt; now - in_block &lt;&lt; <span class="hljs-string">&quot;-&quot;</span> &lt;&lt; now  &lt;&lt; <span class="hljs-string">&quot;内,没有进程在运行&quot;</span> &lt;&lt; endl;<br>			&#125;<br>		&#125;<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">//输出结果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">sort</span>(proc, proc + n + <span class="hljs-number">1</span>, cmp_id);<br>	cout &lt;&lt; <span class="hljs-string">&quot;所有进程已完成，结果如下：&quot;</span> &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; <span class="hljs-string">&quot;进程编号&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;到达时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;区间时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;开始时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<br>		<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;完成时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;周转时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;等待时间&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;阻塞时间&quot;</span>;<br>	cout &lt;&lt; endl;<br>	<span class="hljs-type">int</span> sum_work = <span class="hljs-number">0</span>, sum_turnaround = <span class="hljs-number">0</span>, sum_wait = <span class="hljs-number">0</span>, sum_block = <span class="hljs-number">0</span>;<br>	<span class="hljs-comment">//总区间（服务）时间，总周转时间，总等待时间，平均阻塞时间</span><br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>	&#123;<br>		sum_work += proc[i].work;<br>		sum_turnaround += proc[i].turnaround;<br>		sum_block += proc[i].<span class="hljs-type">block_t</span>;<br>		sum_wait += proc[i].wait;<br>		cout &lt;&lt; left &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].id &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].arrive &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].work &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].begin &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].end &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].turnaround &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].wait &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; proc[i].<span class="hljs-type">block_t</span> &lt;&lt; endl;<br>	&#125;<br>	cout &lt;&lt; <span class="hljs-string">&quot;平均周转时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_turnaround / n &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;平均带权周转时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_turnaround / sum_work / n &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_wait / n &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;平均阻塞时间：&quot;</span> &lt;&lt; (<span class="hljs-type">double</span>)sum_block / n &lt;&lt; endl;<br>	<span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">init</span>();<br>	<span class="hljs-built_in">FCFS_And_RR</span>();<br>	<span class="hljs-built_in">display</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h2 id="程序运行时的初值和运行结果"><a href="#程序运行时的初值和运行结果" class="headerlink" title="程序运行时的初值和运行结果"></a>程序运行时的初值和运行结果</h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><h4 id="初值"><a href="#初值" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116174257026-16386296754991.png" srcset="/img/loading.gif" lazyload alt="image-20211116174257026"></p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173854064-16386296786083.png" srcset="/img/loading.gif" lazyload alt="image-20211116173854064"></p>
<h3 id="RR-时间片固定"><a href="#RR-时间片固定" class="headerlink" title="RR-时间片固定"></a>RR-时间片固定</h3><h4 id="初值-1"><a href="#初值-1" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173837962-16386296818855.png" srcset="/img/loading.gif" lazyload alt="image-20211116173837962"></p>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173854064-16386296834527.png" srcset="/img/loading.gif" lazyload alt="image-20211116173854064"></p>
<h3 id="RR-可变时间片"><a href="#RR-可变时间片" class="headerlink" title="RR-可变时间片"></a>RR-可变时间片</h3><h4 id="初值-2"><a href="#初值-2" class="headerlink" title="初值"></a>初值</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173935445-16386296849179.png" srcset="/img/loading.gif" lazyload alt="image-20211115234014542"></p>
<h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><p><img src="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%BA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1/image-20211116173951387-163862968718611.png" srcset="/img/loading.gif" lazyload alt="image-20211116173951387"></p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ul>
<li><p>根据上面的观察结果，比较这两种算法各自的优缺点，根据结果再和其他的算法比较。</p>
<ul>
<li><p>FCFS（先到先服务）调度算法优点：</p>
<ul>
<li>简单，容易理解。</li>
</ul>
</li>
<li><p>FCFS（先到先服务）调度算法缺点：</p>
<ul>
<li><p>所有其他进程都等待一个大进程释放 CPU，与让较短进程先进行相比，这会导致 CPU 和设备的使用率降低。</p>
</li>
<li><p>FCFS 调度算法是非抢占的。一旦 CPU 分配给了一个进程，该进程就会使用 CPU 直到释放 CPU 为止，不适用于分时系统。</p>
</li>
</ul>
</li>
<li><p>RR（轮转法）调度算法优点：</p>
<ul>
<li>适合分时系统，公平性较好。</li>
</ul>
</li>
<li><p>RR（轮转法）调度算法缺点：</p>
<ul>
<li>紧迫任务响应较慢。</li>
<li>时间片选取若太小，会频繁发生中断、进程上下文切换，增加系统开销，但利于短作业；若太大，退化成FCFS</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实验心得"><a href="#实验心得" class="headerlink" title="实验心得"></a>实验心得</h2><ul>
<li>这个程序是我三番五次精心打磨写成的。在最开始的时候，我先不考虑阻塞队列，分别完成了FCFS算法和RR算法，并且没有逐时刻去模拟入队出队情况，而是在用FCFS规则排序的基础上，逐进程/时间片去模拟并打印一个时间段的信息。但是后来考虑阻塞后，因为阻塞队列中的进程随时可能被唤醒，则使得程序要逐时刻地去查看进程出队入队情况，在这方面的修改我花了一番功夫。同时需要注意对于时间的模拟是连续的，这要求更改当前时间的代码位置和关系式需要合适，否则可能出现时间不正常跨越等异常情况。</li>
<li>在打印信息方面，在进程调度过程中，某时刻进程被唤醒的信息和各个时间段进程的运行情况将会输出到屏幕上。对于最终结果，我则是在输出每个进程“开始时间”、“完成时间”、“周转时间”、“等待时间“的基础上额外添加了总体的平均周转时间、平均加权周转时间、平均等待时间、平均阻塞时间，方便不同的算法进行比较。提及时间，在时间片可变的轮转法调度中，何时改变时间片也是需要考虑的：根据要求，响应时间一定，时间片的长短依据就绪队列进程数量的多少由$T=N*(q+t)$的关系调整（T为响应时间（固定），N为就绪队列进程数，q为时间片的长短，t为上下文切换时间。其中q为毫秒级及以上，上下文切换时间t为纳秒级而忽略不计）。即就绪队列进程数有变化时，时间片需要调整。</li>
<li>后来我还发现FCFS算法和RR算法只有在一个进程最大连续运行时间（代码中为<code>once_max</code>）上有所不同。故我把两个算法的函数合并在一起写，即在FCFS算法的基础上增加关于<code>once_max</code>的判断和是否改变时间片的判断。同时，我将使用两次查看阻塞队列中是否有进程被唤醒的过程提取出来单独作一个函数（代码中为<code>block_check()</code>）。这两个修改大大减少了代码量（从400+行减至260+行）。整个实验过程中还出现了不少bug（死循环等），这时候我通常通过使用调试工具来解决问题，改进代码。</li>
<li>总之，通过本次实验，我对进程的调度算法有了更深的理解。在从课堂中学到的知识基础上，只有当自己实现代码来模拟算法时，才能切身感受到进程调度算法的精妙之处。因为编写这个代码除了了解进程各个时间的含义和计算方法，还有知道在调度过程中进程何时出入就绪队列和阻塞队列，选用哪种数据结构更合适等细节问题。整个实验加深了对进程的“先入先服务”和“时间片轮转”这两种调度方式的理解，有效地提高了我的逻辑思维和编程能力。</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AF%BE%E7%A8%8B%E5%AE%9E%E9%AA%8C/">操作系统课程实验</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C/">操作系统实验</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均为博客作者本人编写整理，转载请联系作者！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/11/17/%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++编程实现模拟中断处理</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/29/Shellshock/">
                        <span class="hidden-mobile">Shellshock Lab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"gI9ZupcpBXTdxJvxZZrrxydJ-gzGzoHsz","appKey":"Eew9XWCbMWVcoNrQzrg87EP3","path":"window.location.pathname","placeholder":"说点什么","avatar":"mp","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":"trut","recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="" target="_blank" rel="nofollow noopener"><span>Copyrights © 2021 Yuhan</span></a> <i class="iconfont icon-love"></i> <a href="" target="_blank" rel="nofollow noopener"><span>Xiayan</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.3/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?6da93a2e5d7f160e0f40b273ddbbddac";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
